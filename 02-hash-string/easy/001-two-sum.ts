/**
 * 📝 题目：两数之和
 * 🔗 链接：https://leetcode.cn/problems/two-sum/
 * 🏷️ 难度：Easy
 * 🏷️ 标签：数组、哈希表
 *
 * 📋 题目描述：
 * 给定一个整数数组 nums 和一个整数目标值 target，
 * 请你在该数组中找出 和为目标值 target 的那两个整数，并返回它们的数组下标。
 *
 * 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。
 *
 * 示例：
 * 输入：nums = [2,7,11,15], target = 9
 * 输出：[0,1]
 * 解释：因为 nums[0] + nums[1] == 9，返回 [0, 1]
 */

// ============================================================
// 💡 思路分析：这道题的解法是怎么想出来的？
// ============================================================
//
// 这是哈希表的经典入门题！
//
// 1. 暴力思路：两层循环，枚举所有两数组合 → O(n²)
//
// 2. 优化思考：
//    - 对于每个 nums[i]，需要找的另一个数是 target - nums[i]
//    - 问题变成：如何快速查找 target - nums[i] 是否存在？
//    - 答案：用哈希表！O(1) 查找
//
// 3. 关键技巧：一边遍历，一边存入哈希表
//    - 遍历到 nums[i] 时，查找 complement = target - nums[i]
//    - 如果 complement 在哈希表中，找到答案
//    - 否则，把 nums[i] 存入哈希表，继续遍历
//
// 📊 为什么是「先查后存」？
//
//    如果「先存后查」，可能会找到自己！
//    例如 nums = [3, 3], target = 6
//    如果先存 {3: 0}，查找 6-3=3，会找到自己

// ============================================================
// 解法一：暴力枚举
// ============================================================
// ⏱️ 时间复杂度：O(n²) | 空间复杂度：O(1)
function twoSum_v1(nums: number[], target: number): number[] {
  const n = nums.length;

  for (let i = 0; i < n; i++) {
    for (let j = i + 1; j < n; j++) {
      if (nums[i] + nums[j] === target) {
        return [i, j];
      }
    }
  }

  return [];
}

// ============================================================
// 解法二：哈希表（推荐）
// ============================================================
// ⏱️ 时间复杂度：O(n) | 空间复杂度：O(n)

/**
 * 📊 执行过程图解：
 *
 * nums = [2, 7, 11, 15], target = 9
 *
 *   i=0: num=2, complement=9-2=7
 *        map 中没有 7
 *        存入 map: {2: 0}
 *
 *   i=1: num=7, complement=9-7=2
 *        map 中有 2! 下标是 0
 *        返回 [0, 1] ✓
 *
 * 🔄 流程图 (Mermaid):
 * ```mermaid
 * flowchart TD
 *     A[遍历数组 i: 0 到 n-1] --> B[计算 complement = target - nums[i]]
 *     B --> C{map.has complement?}
 *     C -->|Yes| D[返回 map.get complement, i]
 *     C -->|No| E[map.set nums[i], i]
 *     E --> A
 * ```
 */
function twoSum_v2(nums: number[], target: number): number[] {
  const map = new Map<number, number>(); // 值 -> 下标

  for (let i = 0; i < nums.length; i++) {
    const complement = target - nums[i];

    // 先查：看 complement 是否已经在 map 中
    if (map.has(complement)) {
      return [map.get(complement)!, i];
    }

    // 后存：把当前数存入 map
    map.set(nums[i], i);
  }

  return [];
}

// ============================================================
// 解法三：使用 Object 代替 Map
// ============================================================
// ⏱️ 时间复杂度：O(n) | 空间复杂度：O(n)
// ⚠️ 注意：Object 的键会转成字符串，对于本题没问题
function twoSum_v3(nums: number[], target: number): number[] {
  const obj: Record<number, number> = {};

  for (let i = 0; i < nums.length; i++) {
    const complement = target - nums[i];

    if (complement in obj) {
      return [obj[complement], i];
    }

    obj[nums[i]] = i;
  }

  return [];
}

// ============================================================
// 🔄 解法对比
// ============================================================
/**
 * | 解法     | 时间   | 空间  | 特点                     |
 * |---------|--------|-------|-------------------------|
 * | 暴力    | O(n²)  | O(1)  | 简单，但慢               |
 * | Map     | O(n)   | O(n)  | 推荐，代码清晰           |
 * | Object  | O(n)   | O(n)  | 也可以，但键转字符串      |
 *
 * 为什么用 Map 而不是 Object？
 * - Map 的键可以是任意类型（本题是数字）
 * - Map 保持插入顺序
 * - Map 的 has/get/set 方法更语义化
 */

// ============================================================
// ⚠️ 易错点
// ============================================================
/**
 * 1. 先查后存的顺序：
 *    - 必须先查找 complement，再存入当前数
 *    - 如果先存后查，可能会找到自己（当 2*num = target 时）
 *
 * 2. 同一元素不能使用两次：
 *    - 题目要求返回两个不同位置的下标
 *    - 先查后存的方式自然满足这个条件
 *
 * 3. 返回值：
 *    - 返回的是下标，不是值
 *    - 下标从 0 开始
 */

// ============================================================
// 🔗 举一反三：相似题目
// ============================================================
/**
 * - 两数之和 II - 输入有序数组 → 双指针（已在 Step 01）
 * - 三数之和 → 排序 + 双指针（已在 Step 01）
 * - 四数之和 → 排序 + 双层循环 + 双指针
 * - 四数相加 II → 分组 + 哈希表
 *
 * 共同模式：a + b = target → 哈希表查找 target - a
 */

// ============================================================
// 🏢 前端业务场景
// ============================================================
/**
 * 1. 购物车凑单：找出哪两件商品的价格刚好等于优惠金额
 * 2. 数据匹配：在两个数据源中找出 ID 匹配的记录
 * 3. 表单验证：验证两个字段的值之和是否等于某个值
 * 4. 配对系统：找出两个用户的评分之和等于某个值
 */

// 导出主解法
export { twoSum_v1, twoSum_v2, twoSum_v3 };
export default twoSum_v2;

