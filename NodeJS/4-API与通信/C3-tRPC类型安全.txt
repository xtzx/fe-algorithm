
================================================================================
【C3】tRPC 端到端类型安全
================================================================================

```text
你现在是「Node.js tRPC 与全栈类型安全专家 & 资深面试官」，
要为一位「7-8 年资深前端工程师」深入讲解 tRPC，面向中高级面试。

【本次主题】C3：tRPC 端到端类型安全

必须覆盖以下内容（每项都要有详细讲解 + 代码示例）：

1）tRPC 概述
   - 什么是 tRPC：
     - 无需 Schema 的端到端类型安全
     - TypeScript 类型自动推断
     - 前后端类型共享
   - 与其他方案对比：
     - vs REST + OpenAPI：无需代码生成
     - vs GraphQL：更轻量，无需学习新语法
   - 适用场景：
     - 全栈 TypeScript 项目
     - Next.js / Nuxt.js 项目
     - 团队同时控制前后端

2）核心概念 ⭐
   - Router：路由定义
   - Procedure：过程（接口）
     - query：查询操作
     - mutation：修改操作
   - Context：上下文
   - Middleware：中间件
   - Input/Output：输入输出验证

3）服务端实现 ⭐⭐⭐⭐⭐
   - 初始化 tRPC：
     ```typescript
     import { initTRPC } from '@trpc/server';
     const t = initTRPC.context<Context>().create();
     export const router = t.router;
     export const publicProcedure = t.procedure;
     ```
   - 定义 Router：
     ```typescript
     export const appRouter = router({
       user: router({
         list: publicProcedure.query(() => { ... }),
         byId: publicProcedure
           .input(z.object({ id: z.string() }))
           .query(({ input }) => { ... }),
         create: publicProcedure
           .input(createUserSchema)
           .mutation(({ input }) => { ... }),
       }),
     });
     ```
   - 导出类型：
     ```typescript
     export type AppRouter = typeof appRouter;
     ```

4）Zod 输入验证 ⭐
   - tRPC + Zod 集成
   - Schema 定义：
     ```typescript
     const createUserSchema = z.object({
       name: z.string().min(1),
       email: z.string().email(),
     });
     ```
   - 自动类型推断
   - 验证错误处理

5）Context 上下文
   - 创建 Context：
     ```typescript
     export const createContext = async (opts) => {
       const user = await getUser(opts.req);
       return { user, db };
     };
     ```
   - 在 Procedure 中访问 Context
   - 请求级别数据

6）Middleware 中间件
   - 认证中间件：
     ```typescript
     const isAuthed = t.middleware(async ({ ctx, next }) => {
       if (!ctx.user) throw new TRPCError({ code: 'UNAUTHORIZED' });
       return next({ ctx: { user: ctx.user } });
     });
     const protectedProcedure = t.procedure.use(isAuthed);
     ```
   - 日志中间件
   - 组合中间件

7）客户端使用 ⭐⭐⭐⭐⭐
   - Vanilla Client：
     ```typescript
     import { createTRPCProxyClient } from '@trpc/client';
     const client = createTRPCProxyClient<AppRouter>({...});
     const users = await client.user.list.query();
     ```
   - React Query 集成：
     ```typescript
     const { data } = trpc.user.list.useQuery();
     const mutation = trpc.user.create.useMutation();
     ```
   - 类型自动推断

8）与框架集成
   - Express 集成
   - Next.js 集成（App Router / Pages Router）
   - Fastify 集成

9）错误处理
   - TRPCError
   - 错误码：UNAUTHORIZED, NOT_FOUND, BAD_REQUEST
   - 自定义错误

10）最佳实践
   - Router 组织
   - 类型导出
   - 开发体验优化

11）面试高频问题（至少 5 个问题 + 加分回答）
   - tRPC 和 GraphQL 有什么区别？
   - tRPC 是怎么实现类型安全的？
   - tRPC 适合什么场景？
   - tRPC 的 Procedure 是什么？
   - 如何在 tRPC 中实现认证？

【输出形式要求：多文件、多格式】

/node-trpc/
├── README.md
├── docs/
│   ├── 01-trpc-overview.md
│   ├── 02-server-setup.md
│   ├── 03-client-usage.md
│   ├── 04-middleware-and-auth.md
│   └── 05-interview-questions.md
├── examples/
│   ├── server/
│   │   ├── trpc.ts
│   │   ├── context.ts
│   │   ├── routers/
│   │   │   ├── index.ts
│   │   │   ├── user.ts
│   │   │   └── post.ts
│   │   ├── middlewares/
│   │   │   └── auth.ts
│   │   └── server.ts
│   ├── client/
│   │   ├── client.ts
│   │   └── react-example.tsx
│   └── schemas/
│       ├── user.ts
│       └── post.ts
└── scripts/
    └── run-server.sh

要求：

1. 先输出完整目录树。
2. 包含完整的服务端和客户端示例。
3. 包含 Zod 验证和中间件。
4. 使用 TypeScript。

请从项目结构开始，然后依次输出每个文件的完整内容。
```

================================================================================

