/**
 * 📝 题目：二叉树中的最大路径和
 * 🔗 链接：https://leetcode.cn/problems/binary-tree-maximum-path-sum/
 * 🏷️ 难度：Hard
 * 🏷️ 标签：树、深度优先搜索、动态规划、二叉树
 *
 * 📋 题目描述：
 * 二叉树中的 路径 被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。
 * 同一个节点在一条路径序列中 至多出现一次。该路径 至少包含一个 节点，且不一定经过根节点。
 *
 * 路径和 是路径中各节点值的总和。
 *
 * 给你一个二叉树的根节点 root，返回其 最大路径和。
 *
 * 示例：
 *        -10
 *        /  \
 *       9   20
 *          /  \
 *         15   7
 *
 * 输入：root = [-10,9,20,null,null,15,7]
 * 输出：42
 * 解释：最优路径是 15 -> 20 -> 7，路径和为 15 + 20 + 7 = 42
 *
 *     1
 *    / \
 *   2   3
 *
 * 输入：root = [1,2,3]
 * 输出：6
 * 解释：最优路径是 2 -> 1 -> 3，路径和为 2 + 1 + 3 = 6
 */

class TreeNode {
  val: number;
  left: TreeNode | null;
  right: TreeNode | null;
  constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
    this.val = val === undefined ? 0 : val;
    this.left = left === undefined ? null : left;
    this.right = right === undefined ? null : right;
  }
}

// ============================================================
// 💡 思路分析：这道题的解法是怎么想出来的？
// ============================================================
//
// 难点理解：
// 1. 路径可以不经过根节点
// 2. 路径可以是任意节点到任意节点
// 3. 但路径不能分叉（不能同时往左右两边走后再回来）
//
// 关键洞察：
// 对于每个节点，它可能是：
// 1. 路径的一部分（向上贡献）
// 2. 路径的最高点（左-根-右形成完整路径）
//
// 递归时返回的是"向上贡献的最大值"
// 但同时要更新"经过当前节点的最大路径和"

// ============================================================
// 解法：递归 + 全局变量
// ============================================================
// ⏱️ 时间复杂度：O(n) | 空间复杂度：O(h)

/**
 * 📊 递归思路图解：
 *
 *        -10
 *        /  \
 *       9   20
 *          /  \
 *         15   7
 *
 * 对于节点 20：
 *   - 左子树贡献: 15
 *   - 右子树贡献: 7
 *   - 经过 20 的最大路径: 15 + 20 + 7 = 42（更新全局最大值）
 *   - 向上贡献: max(15, 7) + 20 = 35（只能选一边）
 *
 * 对于节点 -10：
 *   - 左子树贡献: 9
 *   - 右子树贡献: 35（从 20 来的）
 *   - 经过 -10 的最大路径: 9 + (-10) + 35 = 34
 *   - 但全局最大值已经是 42 了
 *
 * 🔄 两种角色 (Mermaid):
 * ```mermaid
 * flowchart TD
 *     A[当前节点] --> B{作为路径最高点}
 *     A --> C{向上贡献}
 *     B --> D[左贡献 + 根 + 右贡献]
 *     C --> E[max左贡献, 右贡献 + 根]
 *     D --> F[更新全局最大值]
 *     E --> G[返回给父节点]
 * ```
 */
function maxPathSum(root: TreeNode | null): number {
  let maxSum = -Infinity;

  /**
   * 返回以 node 为起点向下的最大路径和
   * 同时更新经过 node 的最大路径和
   */
  function maxGain(node: TreeNode | null): number {
    if (!node) return 0;

    // 递归计算左右子树的最大贡献值
    // 如果贡献为负，不如不选（取 0）
    const leftGain = Math.max(maxGain(node.left), 0);
    const rightGain = Math.max(maxGain(node.right), 0);

    // 经过当前节点的最大路径和
    const pathSum = node.val + leftGain + rightGain;

    // 更新全局最大值
    maxSum = Math.max(maxSum, pathSum);

    // 返回当前节点向上贡献的最大值
    // 只能选择左或右一边
    return node.val + Math.max(leftGain, rightGain);
  }

  maxGain(root);
  return maxSum;
}

// ============================================================
// ⚠️ 易错点
// ============================================================
/**
 * 1. 贡献值可以为负：
 *    - 子树贡献为负时，选择不要（Math.max(gain, 0)）
 *    - 但当前节点本身必须选（不能跳过）
 *
 * 2. 两种计算要分开：
 *    - 经过当前节点的路径：左 + 根 + 右
 *    - 向上贡献的值：max(左, 右) + 根
 *
 * 3. 全局最大值初始化：
 *    - 用 -Infinity，因为节点值可能为负
 *
 * 4. 空节点返回 0：
 *    - 不是返回 -Infinity
 */

// ============================================================
// 🔗 举一反三：相似题目
// ============================================================
/**
 * - 路径总和 → 根到叶子的路径
 * - 二叉树的直径 → 路径长度（边数）
 * - 最长同值路径 → 相同值的最长路径
 */

// ============================================================
// 🏢 前端业务场景
// ============================================================
/**
 * 1. 组织架构：计算某条汇报链的最大总绩效
 * 2. 路由优化：计算某条路由的最大权重
 */

export { TreeNode, maxPathSum };
export default maxPathSum;

