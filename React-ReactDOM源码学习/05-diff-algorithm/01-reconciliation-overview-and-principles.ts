/**
 * ============================================================
 * 📚 Phase 5: Diff 算法 - Part 1: Reconciliation 概览与核心原则
 * ============================================================
 *
 * 📁 核心源码位置:
 * - packages/react-reconciler/src/ReactChildFiber.new.js
 * - packages/react-reconciler/src/ReactFiberBeginWork.new.js
 *
 * ⏱️ 预计时间：1-2 小时
 * 🎯 面试权重：⭐⭐⭐⭐⭐
 */

// ============================================================
// Part 1: 什么是 Reconciliation（协调）
// ============================================================

/**
 * 📊 Reconciliation 的概念
 */

const whatIsReconciliation = `
📊 什么是 Reconciliation（协调）？

定义:
═══════════════════════════════════════════════════════════════════════════════

Reconciliation（协调）是 React 的核心算法，用于：
• 比较"上一帧的 UI 表示"和"下一帧的 UI 表示"
• 决定最小更新集合
• 生成 Fiber 树的增删改标记（Placement, Deletion, Update）


为什么需要 Reconciliation？
═══════════════════════════════════════════════════════════════════════════════

┌─────────────────────────────────────────────────────────────────────────────┐
│                                                                             │
│   目标：让 DOM 操作最小化                                                    │
│   ───────────────────────                                                   │
│                                                                             │
│   渲染前:                                                                   │
│   ┌─────────────────────┐                                                   │
│   │ <ul>                │                                                   │
│   │   <li>A</li>        │                                                   │
│   │   <li>B</li>        │                                                   │
│   │ </ul>               │                                                   │
│   └─────────────────────┘                                                   │
│                                                                             │
│   渲染后:                                                                   │
│   ┌─────────────────────┐                                                   │
│   │ <ul>                │                                                   │
│   │   <li>A</li>        │  ← 没变                                           │
│   │   <li>B-updated</li>│  ← 文本变了                                       │
│   │   <li>C</li>        │  ← 新增                                           │
│   │ </ul>               │                                                   │
│   └─────────────────────┘                                                   │
│                                                                             │
│   如果直接替换整个 DOM？                                                    │
│   • 销毁所有旧节点 → 重建所有新节点                                         │
│   • 浪费性能，用户体验差（输入框失焦、动画中断等）                          │
│                                                                             │
│   使用 Reconciliation？                                                     │
│   • 复用 li[0]（不变）                                                      │
│   • 更新 li[1] 的文本内容                                                   │
│   • 插入 li[2]（新增）                                                      │
│   • 最小化 DOM 操作！                                                       │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
`;

// ============================================================
// Part 2: 算法复杂度与设计权衡
// ============================================================

/**
 * 📊 Diff 算法的复杂度选择
 */

const algorithmComplexity = `
📊 Diff 算法的复杂度与设计权衡

完美 Diff vs 启发式 Diff:
═══════════════════════════════════════════════════════════════════════════════

┌─────────────────────────────────────────────────────────────────────────────┐
│                                                                             │
│   完美的树 Diff（传统算法）                                                 │
│   ──────────────────────────                                                │
│                                                                             │
│   复杂度：O(n³)                                                             │
│                                                                             │
│   原因：                                                                    │
│   • 比较两棵树需要 O(n²)（每个节点都可能和另一棵树的每个节点配对）          │
│   • 每次比较可能需要 O(n) 的编辑操作                                        │
│   • 总共 O(n³)                                                              │
│                                                                             │
│   问题：                                                                    │
│   • 1000 个节点 → 1,000,000,000 次操作                                      │
│   • 在 UI 场景中完全不可接受                                                │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│                                                                             │
│   React 的启发式 Diff                                                       │
│   ────────────────────                                                      │
│                                                                             │
│   复杂度：O(n)                                                              │
│                                                                             │
│   通过三个假设/限制，将复杂度降到 O(n)：                                    │
│                                                                             │
│   1️⃣  同层比较                                                              │
│   • 只比较同一层级的节点                                                    │
│   • 不跨层级移动节点                                                        │
│   • 如果节点跨层级移动，视为删除+新建                                       │
│                                                                             │
│   2️⃣  类型决定复用                                                          │
│   • 不同类型的元素 → 删除旧树，创建新树                                     │
│   • 相同类型的元素 → 复用 Fiber，更新属性                                   │
│                                                                             │
│   3️⃣  key 标识节点                                                          │
│   • 列表中通过 key 识别节点身份                                             │
│   • 相同 key → 可能是同一个节点（再比较 type）                              │
│   • 不同 key → 不是同一个节点                                               │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘


为什么这些假设是合理的？
═══════════════════════════════════════════════════════════════════════════════

假设 1: 同层比较
─────────────────────────────────────────────────────────────────
在真实的 UI 开发中，跨层级移动 DOM 节点非常罕见。
例如：一个按钮从 header 移动到 footer 的情况几乎不存在。
即使发生，删除+重建的代价也可以接受。

假设 2: 类型决定复用
─────────────────────────────────────────────────────────────────
不同类型的组件通常有完全不同的结构。
<div> → <span> 的变化，内部结构可能完全不同，复用没有意义。
组件也一样：<Counter /> → <Timer /> 内部逻辑完全不同。

假设 3: key 标识节点
─────────────────────────────────────────────────────────────────
开发者最清楚列表项的"身份"。
通过 key，开发者可以告诉 React "这个节点是哪个"。
React 不需要猜测，可以精确匹配。
`;

// ============================================================
// Part 3: 三个核心原则详解
// ============================================================

/**
 * 📊 Diff 的三个核心原则
 */

const threePrinciples = `
📊 Diff 的三个核心原则

原则 1: 同层比较（Level by Level）
═══════════════════════════════════════════════════════════════════════════════

┌─────────────────────────────────────────────────────────────────────────────┐
│                                                                             │
│   旧树:                        新树:                                        │
│   ─────                        ─────                                        │
│        A                            A                                       │
│       /|\\                          /|\\                                      │
│      B C D                        B C E    ← 只在这一层比较                 │
│     / \\                          / \\                                       │
│    F   G                        F   G                                       │
│                                                                             │
│   比较过程:                                                                 │
│   • 比较 A 层：A vs A ✓                                                     │
│   • 比较第二层：B vs B ✓, C vs C ✓, D vs E                                 │
│   • D 和 E 类型不同 → 删除 D（及其子树），创建 E                            │
│   • 比较第三层：F vs F ✓, G vs G ✓                                         │
│                                                                             │
│   ⚠️ 注意：                                                                 │
│   如果 D 移动到了 A 的上一层，React 不会识别为"移动"，                      │
│   而是视为 D 被删除 + 在新位置创建一个新节点。                              │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘


原则 2: 类型决定复用（Type Comparison）
═══════════════════════════════════════════════════════════════════════════════

┌─────────────────────────────────────────────────────────────────────────────┐
│                                                                             │
│   情况 1: 类型相同 → 复用                                                   │
│   ──────────────────────────                                                │
│                                                                             │
│   旧: <div className="old">Hello</div>                                      │
│   新: <div className="new">World</div>                                      │
│                                                                             │
│   结果:                                                                     │
│   • 复用同一个 Fiber                                                        │
│   • 更新 className: "old" → "new"                                           │
│   • 更新文本: "Hello" → "World"                                             │
│   • DOM 节点不变，只更新属性                                                │
│                                                                             │
│   情况 2: 类型不同 → 删除+新建                                              │
│   ──────────────────────────                                                │
│                                                                             │
│   旧: <div>Hello</div>                                                      │
│   新: <span>Hello</span>                                                    │
│                                                                             │
│   结果:                                                                     │
│   • 标记旧 div 为 Deletion                                                  │
│   • 创建新的 span Fiber                                                     │
│   • 标记新 span 为 Placement                                                │
│   • commit 阶段：删除 div DOM，插入 span DOM                                │
│                                                                             │
│   情况 3: 组件类型不同 → 整棵子树重建                                       │
│   ──────────────────────────                                                │
│                                                                             │
│   旧: <Counter count={1} />                                                 │
│   新: <Timer duration={1} />                                                │
│                                                                             │
│   结果:                                                                     │
│   • Counter 及其所有子树被删除                                              │
│   • 创建全新的 Timer 及其子树                                               │
│   • Counter 的状态丢失                                                      │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘


原则 3: key 标识节点身份（Key Identification）
═══════════════════════════════════════════════════════════════════════════════

┌─────────────────────────────────────────────────────────────────────────────┐
│                                                                             │
│   没有 key 时（使用索引）:                                                  │
│   ─────────────────────────                                                 │
│                                                                             │
│   旧: [<li>A</li>, <li>B</li>, <li>C</li>]                                  │
│        index: 0      1         2                                            │
│                                                                             │
│   新: [<li>B</li>, <li>C</li>, <li>D</li>]                                  │
│        index: 0      1         2                                            │
│                                                                             │
│   React 的理解（按索引匹配）:                                               │
│   • index 0: A → B（类型相同，更新文本）                                    │
│   • index 1: B → C（类型相同，更新文本）                                    │
│   • index 2: C → D（类型相同，更新文本）                                    │
│                                                                             │
│   ⚠️ 问题：所有节点都被"更新"了，实际上只需要删 A，加 D！                   │
│                                                                             │
│   有 key 时:                                                                │
│   ──────────                                                                │
│                                                                             │
│   旧: [<li key="a">A</li>, <li key="b">B</li>, <li key="c">C</li>]         │
│   新: [<li key="b">B</li>, <li key="c">C</li>, <li key="d">D</li>]         │
│                                                                             │
│   React 的理解（按 key 匹配）:                                              │
│   • key="a": 旧有新无 → 删除                                               │
│   • key="b": 旧有新有 → 复用                                               │
│   • key="c": 旧有新有 → 复用                                               │
│   • key="d": 旧无新有 → 插入                                               │
│                                                                             │
│   ✅ 只需要 1 次删除 + 1 次插入！                                           │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
`;

// ============================================================
// Part 4: Diff 产生的标记（Flags）
// ============================================================

/**
 * 📊 Diff 产生的标记
 */

const diffFlags = `
📊 Diff 产生的标记（Flags）

Diff 的结果是在 Fiber 上打标记:
═══════════════════════════════════════════════════════════════════════════════

源码位置: packages/react-reconciler/src/ReactFiberFlags.js

┌─────────────────┬──────────────────────────────────────────────────────────┐
│ 标记            │ 说明                                                     │
├─────────────────┼──────────────────────────────────────────────────────────┤
│ Placement       │ 插入：新节点需要插入 DOM                                 │
│                 │ 包括：首次渲染、从其他位置移动过来                       │
├─────────────────┼──────────────────────────────────────────────────────────┤
│ Update          │ 更新：节点的 props 发生变化                              │
│                 │ 需要在 commit 阶段更新 DOM 属性                          │
├─────────────────┼──────────────────────────────────────────────────────────┤
│ Deletion        │ 删除：节点需要从 DOM 中移除                              │
│                 │ 标记在父 Fiber 的 deletions 数组中                       │
├─────────────────┼──────────────────────────────────────────────────────────┤
│ ChildDeletion   │ 表示有子节点被删除                                       │
│                 │ 用于在 commit 阶段处理删除                               │
└─────────────────┴──────────────────────────────────────────────────────────┘


标记的生成时机:
═══════════════════════════════════════════════════════════════════════════════

┌─────────────────────────────────────────────────────────────────────────────┐
│                                                                             │
│   Placement（插入）:                                                        │
│   ─────────────────                                                         │
│   • 新节点没有 alternate（首次创建）                                        │
│   • 节点被移动到新位置（index 变化）                                        │
│                                                                             │
│   代码位置：placeChild / placeSingleChild                                   │
│                                                                             │
│   function placeSingleChild(newFiber: Fiber): Fiber {                       │
│     if (shouldTrackSideEffects && newFiber.alternate === null) {            │
│       newFiber.flags |= Placement;  // ⭐ 首次创建，标记插入                │
│     }                                                                       │
│     return newFiber;                                                        │
│   }                                                                         │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│                                                                             │
│   Deletion（删除）:                                                         │
│   ─────────────────                                                         │
│   • 旧节点在新树中找不到对应                                                │
│   • 类型不同需要替换                                                        │
│                                                                             │
│   代码位置：deleteChild / deleteRemainingChildren                           │
│                                                                             │
│   function deleteChild(returnFiber: Fiber, childToDelete: Fiber): void {    │
│     const deletions = returnFiber.deletions;                                │
│     if (deletions === null) {                                               │
│       returnFiber.deletions = [childToDelete];                              │
│       returnFiber.flags |= ChildDeletion;                                   │
│     } else {                                                                │
│       deletions.push(childToDelete);                                        │
│     }                                                                       │
│   }                                                                         │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
`;

// ============================================================
// Part 5: 面试要点
// ============================================================

const interviewPoints = `
💡 Part 1 面试要点

Q1: 什么是 React 的 Reconciliation？
A: Reconciliation（协调）是 React 的核心算法，用于比较新旧虚拟 DOM 树，
   找出最小更新集合，生成 Fiber 树的增删改标记。
   目标是最小化实际的 DOM 操作，提升性能。

Q2: 传统树 Diff 的复杂度是多少？React 如何优化？
A: 传统完美树 Diff 是 O(n³)，React 通过三个假设优化到 O(n)：
   1. 同层比较：只比较同一层级的节点
   2. 类型决定复用：不同类型直接删旧建新
   3. key 标识节点：通过 key 在列表中识别节点身份

Q3: 为什么 React 的 Diff 不支持跨层级移动优化？
A: 1. 真实 UI 中跨层级移动非常罕见
   2. 跨层级移动的检测需要 O(n²) 复杂度
   3. 即使发生，删除+重建的代价也可以接受
   这是性能和复杂度的权衡。

Q4: 什么情况下组件会被完全重建？
A: 当组件类型改变时会完全重建。例如：
   - <div> → <span>
   - <Counter /> → <Timer />
   类型不同意味着结构可能完全不同，复用没有意义。

Q5: Diff 产生的标记有哪些？
A: 主要标记：
   - Placement：需要插入 DOM（新建或移动）
   - Update：需要更新 DOM 属性
   - Deletion：需要删除 DOM（存在父 Fiber 的 deletions 数组）
   - ChildDeletion：有子节点被删除
`;

export {
  whatIsReconciliation,
  algorithmComplexity,
  threePrinciples,
  diffFlags,
  interviewPoints,
};
