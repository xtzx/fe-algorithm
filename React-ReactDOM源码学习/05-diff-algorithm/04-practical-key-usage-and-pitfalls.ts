/**
 * ============================================================
 * 📚 Phase 5: Diff 算法 - Part 4: Key 的实际使用与常见陷阱
 * ============================================================
 *
 * 本文件不涉及源码细节，重点是：
 * • key 的正确使用方式
 * • 常见错误模式及其原因
 * • 用 Diff 算法原理解释现象
 *
 * ⏱️ 预计时间：1-2 小时
 * 🎯 面试权重：⭐⭐⭐⭐⭐
 */

// ============================================================
// Part 1: key 的作用回顾
// ============================================================

/**
 * 📊 key 在 Diff 中的核心作用
 */

const keyPurposeRecap = `
📊 key 在 Diff 中的核心作用

key 的本质:
═══════════════════════════════════════════════════════════════════════════════

key 是 React 用来识别"节点身份"的标识。

在列表 Diff 时，React 需要回答一个问题：
"新列表中的第 N 个节点，对应旧列表中的哪个节点？"

有 key 时:
─────────────────────────────────────────────────────────────────
按 key 匹配。相同 key 的节点被认为是"同一个节点"。

无 key 时:
─────────────────────────────────────────────────────────────────
按 index 匹配。位置相同的节点被认为是"同一个节点"。


复用的含义:
═══════════════════════════════════════════════════════════════════════════════

当 React 认为两个节点是"同一个"时，会复用 Fiber：
• 复用 = 保留 Fiber 对象
• 复用 = 保留 DOM 节点
• 复用 = 保留组件实例（对于 Class 组件）
• 复用 = 保留组件状态（useState 等）

但 props 会更新为新的值。


关键理解:
═══════════════════════════════════════════════════════════════════════════════

┌─────────────────────────────────────────────────────────────────────────────┐
│                                                                             │
│   "复用"不等于"完全不变"！                                                  │
│                                                                             │
│   复用只是说：                                                              │
│   • 不销毁旧的 Fiber/DOM/状态                                               │
│   • 用新的 props 更新它                                                     │
│                                                                             │
│   如果 key 匹配错了，会导致：                                               │
│   • 本应该是新节点 A，却复用了旧节点 B 的 Fiber                             │
│   • A 会继承 B 的状态！                                                     │
│   • A 的 DOM 是 B 的 DOM，只更新了 props                                    │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
`;

// ============================================================
// Part 2: 错误模式 - 使用 index 作为 key
// ============================================================

/**
 * 📊 错误模式：使用 index 作为 key
 */

const indexAsKeyPitfall = `
📊 错误模式：使用 index 作为 key

问题场景:
═══════════════════════════════════════════════════════════════════════════════

function TodoList() {
  const [todos, setTodos] = useState([
    { id: 1, text: 'Learn React' },
    { id: 2, text: 'Build App' },
    { id: 3, text: 'Ship It' },
  ]);

  const addTodoAtStart = () => {
    setTodos([
      { id: Date.now(), text: 'New Task' },
      ...todos
    ]);
  };

  return (
    <ul>
      {todos.map((todo, index) => (
        // ❌ 使用 index 作为 key
        <li key={index}>
          <input defaultValue={todo.text} />
        </li>
      ))}
    </ul>
  );
}


问题分析:
═══════════════════════════════════════════════════════════════════════════════

初始状态:
─────────────────────────────────────────────────────────────────
index:  0              1              2
text:   Learn React    Build App      Ship It
DOM:    <input v="Learn React"> <input v="Build App"> <input v="Ship It">


点击 addTodoAtStart 后:
─────────────────────────────────────────────────────────────────
index:  0              1              2              3
text:   New Task       Learn React    Build App      Ship It

React 的 Diff 过程（按 index 匹配）:
─────────────────────────────────────────────────────────────────
• index=0: 复用旧的 index=0 的 Fiber
  - 旧 text: Learn React → 新 text: New Task
  - DOM 复用，但 defaultValue 不会更新！

• index=1: 复用旧的 index=1 的 Fiber
  - 旧 text: Build App → 新 text: Learn React
  - DOM 复用

• index=2: 复用旧的 index=2 的 Fiber
  - 旧 text: Ship It → 新 text: Build App
  - DOM 复用

• index=3: 新建
  - 新 text: Ship It


实际表现:
═══════════════════════════════════════════════════════════════════════════════

┌─────────────────────────────────────────────────────────────────────────────┐
│                                                                             │
│   用户看到的结果:                                                           │
│                                                                             │
│   index:  0              1              2              3                    │
│   期望:   [New Task]     [Learn React]  [Build App]    [Ship It]            │
│   实际:   [Learn React]  [Build App]    [Ship It]      [Ship It]            │
│                ↑              ↑              ↑              ↑               │
│              旧DOM          旧DOM          旧DOM          新DOM             │
│           (复用了!)       (复用了!)       (复用了!)       (新建)             │
│                                                                             │
│   ⚠️ 输入框内容和列表项"错位"了！                                           │
│                                                                             │
│   原因：                                                                    │
│   • input 的 defaultValue 只在首次渲染时生效                                │
│   • DOM 被复用了，input 的内容没变                                          │
│   • 但 todo.text 作为 props 传给了不同的 input                              │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘


正确做法:
═══════════════════════════════════════════════════════════════════════════════

{todos.map(todo => (
  // ✅ 使用业务 id 作为 key
  <li key={todo.id}>
    <input defaultValue={todo.text} />
  </li>
))}

Diff 过程（按 id 匹配）:
─────────────────────────────────────────────────────────────────
• id=new: 新建（没有对应的旧节点）
• id=1: 复用旧的 id=1 的 Fiber（内容没变）
• id=2: 复用旧的 id=2 的 Fiber（内容没变）
• id=3: 复用旧的 id=3 的 Fiber（内容没变）

结果：只新建 1 个节点，其他节点完全不变！
`;

// ============================================================
// Part 3: 真实案例 - 输入框状态错乱
// ============================================================

/**
 * 📊 案例 B：输入框列表的状态错乱
 */

const inputStateConfusion = `
📊 案例 B：输入框列表的状态错乱

完整复现代码:
═══════════════════════════════════════════════════════════════════════════════

function ItemList() {
  const [items, setItems] = useState([
    { id: 'a', value: '' },
    { id: 'b', value: '' },
    { id: 'c', value: '' },
  ]);

  const moveFirstToEnd = () => {
    const [first, ...rest] = items;
    setItems([...rest, first]);
  };

  return (
    <div>
      <button onClick={moveFirstToEnd}>移动第一项到末尾</button>
      <ul>
        {items.map((item, index) => (
          // ❌ 使用 index 作为 key
          <li key={index}>
            <span>{item.id}: </span>
            <input
              placeholder={\`输入 \${item.id} 的内容\`}
              // 注意：这里用 uncontrolled input
            />
          </li>
        ))}
      </ul>
    </div>
  );
}


操作步骤与现象:
═══════════════════════════════════════════════════════════════════════════════

Step 1: 初始状态
─────────────────────────────────────────────────────────────────
index:  0          1          2
id:     a          b          c
input:  [空]       [空]       [空]


Step 2: 用户在第一个输入框输入 "Hello"
─────────────────────────────────────────────────────────────────
index:  0          1          2
id:     a          b          c
input:  [Hello]    [空]       [空]

DOM 状态：input[0].value = "Hello"


Step 3: 点击 "移动第一项到末尾"
─────────────────────────────────────────────────────────────────
数据变化: [a, b, c] → [b, c, a]

期望的界面:
index:  0          1          2
id:     b          c          a
input:  [空]       [空]       [Hello]  ← "Hello" 应该跟着 id=a 移动

实际的界面:
index:  0          1          2
id:     b          c          a
input:  [Hello]    [空]       [空]  ← "Hello" 留在了 index=0 的位置！


原因解析（Diff 角度）:
═══════════════════════════════════════════════════════════════════════════════

┌─────────────────────────────────────────────────────────────────────────────┐
│                                                                             │
│   使用 index 作为 key 时，React 的 Diff 理解:                               │
│                                                                             │
│   旧:  key=0(a)  →  key=1(b)  →  key=2(c)                                  │
│   新:  key=0(b)  →  key=1(c)  →  key=2(a)                                  │
│                                                                             │
│   匹配结果:                                                                 │
│   • key=0 复用：Fiber 不变，只更新 props.id: a → b                         │
│   • key=1 复用：Fiber 不变，只更新 props.id: b → c                         │
│   • key=2 复用：Fiber 不变，只更新 props.id: c → a                         │
│                                                                             │
│   问题:                                                                     │
│   • Fiber 复用 = DOM 复用                                                   │
│   • input[0] 的 DOM 没变，它的 value 还是 "Hello"                          │
│   • 但 id 从 'a' 变成了 'b'                                                 │
│   • 用户看到："b: [Hello]" — 完全错乱！                                     │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘


使用正确的 key 时:
═══════════════════════════════════════════════════════════════════════════════

{items.map(item => (
  <li key={item.id}>  {/* ✅ 使用 id 作为 key */}
    <span>{item.id}: </span>
    <input placeholder={\`输入 \${item.id} 的内容\`} />
  </li>
))}

React 的 Diff 理解:
─────────────────────────────────────────────────────────────────
旧:  key='a'  →  key='b'  →  key='c'
新:  key='b'  →  key='c'  →  key='a'

匹配结果:
• key='a': 复用，位置从 0 移动到 2（标记 Placement）
• key='b': 复用，位置从 1 移动到 0（或不移动，取决于算法）
• key='c': 复用，位置从 2 移动到 1（或不移动）

结果:
• 每个 DOM 节点跟随它的 key 一起移动
• input[a] 的 value="Hello" 跟着 id=a 移动到最后
• 用户看到："a: [Hello]" 正确显示在最后！
`;

// ============================================================
// Part 4: 其他常见 key 错误
// ============================================================

/**
 * 📊 其他常见 key 错误
 */

const otherKeyMistakes = `
📊 其他常见 key 错误

错误 1: 使用随机数作为 key
═══════════════════════════════════════════════════════════════════════════════

// ❌ 每次渲染都会生成新的 key
{items.map(item => (
  <li key={Math.random()}>
    {item.text}
  </li>
))}

问题:
─────────────────────────────────────────────────────────────────
• 每次渲染，所有节点的 key 都变了
• React 认为所有旧节点都被删除，所有新节点都是新建
• 完全失去了 Diff 的优化效果
• 所有 DOM 节点都会重建，状态丢失

性能影响:
• 每次更新 = 完全重渲染
• O(n) 次 DOM 删除 + O(n) 次 DOM 创建


错误 2: 使用不稳定的组合作为 key
═══════════════════════════════════════════════════════════════════════════════

// ❌ item 对象引用可能每次都不同
{items.map(item => (
  <li key={JSON.stringify(item)}>
    {item.text}
  </li>
))}

// ❌ 时间戳每次都不同
{items.map(item => (
  <li key={item.id + '-' + Date.now()}>
    {item.text}
  </li>
))}

问题:
─────────────────────────────────────────────────────────────────
• 与随机数类似，key 不稳定
• 无法正确匹配新旧节点


错误 3: 在条件渲染中忘记 key
═══════════════════════════════════════════════════════════════════════════════

// ❌ 可能导致警告或意外行为
{isLoggedIn ? <UserProfile /> : <LoginForm />}

// ✅ 如果需要重置状态，可以加 key
{isLoggedIn ? (
  <UserProfile key="profile" />
) : (
  <LoginForm key="login" />
)}

说明:
─────────────────────────────────────────────────────────────────
• 条件渲染不一定需要 key
• 但如果 type 相同（如两个都是 div），加 key 可以强制重建


错误 4: key 重复
═══════════════════════════════════════════════════════════════════════════════

// ❌ 有重复的 key
const items = [
  { id: 1, text: 'A' },
  { id: 1, text: 'B' },  // 重复的 id=1
  { id: 2, text: 'C' },
];

{items.map(item => (
  <li key={item.id}>{item.text}</li>
))}

问题:
─────────────────────────────────────────────────────────────────
• React 会在 DEV 模式下发出警告
• Map 中后面的会覆盖前面的
• 导致节点丢失或复用错误
`;

// ============================================================
// Part 5: key 最佳实践
// ============================================================

/**
 * 📊 key 最佳实践
 */

const keyBestPractices = `
📊 key 最佳实践

✅ 推荐做法
═══════════════════════════════════════════════════════════════════════════════

1. 使用业务唯一 ID
─────────────────────────────────────────────────────────────────
// 后端返回的数据通常有 id
{users.map(user => (
  <UserCard key={user.id} user={user} />
))}


2. 组合多个字段形成唯一 key
─────────────────────────────────────────────────────────────────
// 如果单个字段不唯一
{orders.map(order => (
  <OrderItem key={\`\${order.userId}-\${order.orderId}\`} order={order} />
))}


3. 使用 index 的安全场景
─────────────────────────────────────────────────────────────────
// ✅ 静态列表，不会重排序、不会增删
const tabs = ['Home', 'Profile', 'Settings'];
{tabs.map((tab, index) => (
  <Tab key={index}>{tab}</Tab>  // 这里 index 是安全的
))}

// ✅ 仅在末尾增删，不涉及重排序
{logs.map((log, index) => (
  <LogEntry key={index} log={log} />
))}


❌ 避免的做法
═══════════════════════════════════════════════════════════════════════════════

// ❌ 随机数
key={Math.random()}

// ❌ 时间戳（除非真的需要每次重建）
key={Date.now()}

// ❌ 在有重排序/首部增删的列表中使用 index
// 当列表会变化时，index 不是稳定的身份标识

// ❌ 重复的 key
// 确保同一级别的节点 key 唯一


🔑 判断是否可以用 index 的检查清单
═══════════════════════════════════════════════════════════════════════════════

问自己这些问题:
─────────────────────────────────────────────────────────────────
□ 列表项会重新排序吗？
□ 列表会在首部或中间插入/删除吗？
□ 列表项有内部状态吗（如 input value）？
□ 列表项有副作用吗（如 useEffect）？

如果以上任何一项回答"是"，就不要用 index 作为 key！
`;

// ============================================================
// Part 6: 面试要点
// ============================================================

const interviewPoints = `
💡 Part 4 面试要点

Q1: 什么情况下可以使用 index 作为 key？
A: 只有当列表满足以下所有条件时：
   1. 列表是静态的，不会重排序
   2. 只会在末尾增删，不会在首部或中间操作
   3. 列表项没有内部状态（如 input value）
   4. 列表项没有依赖位置的副作用

Q2: 使用 index 作为 key 会导致什么问题？
A: 1. 性能问题：本可以复用的节点却被"更新"
   2. 状态错乱：组件状态和错误的数据关联
   3. 动画问题：DOM 没有移动，动画不会触发
   4. 副作用问题：useEffect 等在错误的节点上执行

Q3: 为什么使用 Math.random() 作为 key 是错误的？
A: 每次渲染生成的 key 都不同，React 无法找到匹配的旧节点。
   结果是每次更新都会删除所有旧节点、创建所有新节点，
   完全失去 Diff 优化效果。

Q4: 从 Diff 算法角度解释"状态错乱"现象？
A: Diff 按 key 匹配节点。如果 key 错误匹配：
   1. React 认为"这是同一个节点"
   2. 复用旧 Fiber 和 DOM
   3. 组件实例和状态保留
   4. 只更新 props
   结果：旧状态和新数据混在一起，表现为"错乱"。

Q5: key 需要全局唯一吗？
A: 不需要。key 只需要在同一个父节点的兄弟节点中唯一。
   不同父节点下可以有相同的 key。

Q6: 如何强制 React 重建一个组件？
A: 给组件一个新的 key。React 会认为这是一个新节点，
   删除旧的、创建新的，重置所有状态。
   例如：<Form key={selectedId} data={data} />
`;

export {
  keyPurposeRecap,
  indexAsKeyPitfall,
  inputStateConfusion,
  otherKeyMistakes,
  keyBestPractices,
  interviewPoints,
};
