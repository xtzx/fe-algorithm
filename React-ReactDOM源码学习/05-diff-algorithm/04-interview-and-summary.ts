/**
 * ============================================================
 * 📚 Phase 5: Diff 算法 - Part 4: 面试题与总结
 * ============================================================
 */

// ============================================================
// Part 1: 数据结构总结
// ============================================================

/**
 * 📊 Diff 算法涉及的核心数据结构
 */

const dataStructureSummary = `
📊 Diff 相关数据结构汇总

┌─────────────────────────────────────────────────────────────────────────┐
│                         Fiber 节点                                      │
│ 📁 ReactFiber.new.js                                                   │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  Fiber {                                                                │
│    // ===== 用于 Diff 比较 =====                                        │
│    key: string | null;      // 唯一标识，来自 ReactElement              │
│    type: any;               // 类型（'div' | Component）                │
│    elementType: any;        // 元素类型（通常等于 type）                 │
│                                                                         │
│    // ===== 用于移动判断 =====                                          │
│    index: number;           // 在兄弟中的位置索引                        │
│                                                                         │
│    // ===== 用于复用判断 =====                                          │
│    alternate: Fiber | null; // 另一棵树的对应节点                        │
│                             // 不为 null 说明是复用的                    │
│                                                                         │
│    // ===== 用于标记副作用 =====                                        │
│    flags: Flags;            // 副作用类型                               │
│                             // Placement: 需要插入/移动                  │
│                             // ChildDeletion: 有子节点需删除             │
│                                                                         │
│    deletions: Fiber[];      // 要删除的子节点列表                        │
│                                                                         │
│    // ===== 链表结构 =====                                              │
│    child: Fiber | null;     // 第一个子节点                              │
│    sibling: Fiber | null;   // 下一个兄弟                               │
│    return: Fiber | null;    // 父节点                                   │
│  }                                                                      │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────┐
│                    existingChildren Map                                 │
│ 📁 ReactChildFiber.new.js - mapRemainingChildren                       │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  Map<string | number, Fiber>                                            │
│                                                                         │
│  作用：存储剩余旧节点，用于 O(1) 查找                                    │
│                                                                         │
│  键：                                                                   │
│    - 有 key: 使用 key 作为键                                            │
│    - 无 key: 使用 index 作为键                                          │
│                                                                         │
│  示例：                                                                 │
│  旧节点: [A(key='a'), B(key='b'), C(无key, index=2)]                    │
│                                                                         │
│  Map: {                                                                 │
│    'a' => FiberA,                                                       │
│    'b' => FiberB,                                                       │
│    2   => FiberC    // 数字类型的键                                     │
│  }                                                                      │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────┐
│                        Flags 副作用标记                                 │
│ 📁 ReactFiberFlags.js                                                   │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  // 二进制位掩码                                                        │
│  NoFlags         = 0b00000000000000000000000000;  // 无副作用            │
│  Placement       = 0b00000000000000000000000010;  // 插入/移动           │
│  Update          = 0b00000000000000000000000100;  // 更新                │
│  ChildDeletion   = 0b00000000000000000000010000;  // 删除子节点          │
│                                                                         │
│  使用方式：                                                             │
│  // 添加标记                                                            │
│  fiber.flags |= Placement;                                              │
│                                                                         │
│  // 检查标记                                                            │
│  if (fiber.flags & Placement) { ... }                                   │
│                                                                         │
│  // 移除标记                                                            │
│  fiber.flags &= ~Placement;                                             │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
`;

// ============================================================
// Part 2: 算法流程总结
// ============================================================

const algorithmFlowSummary = `
📊 Diff 算法完整流程图

                    reconcileChildFibers(returnFiber, currentFirstChild, newChild)
                                            │
                        ┌───────────────────┼───────────────────┐
                        ▼                   ▼                   ▼
                   单个对象              数组                其他
                        │                   │                   │
                        ▼                   ▼                   ▼
            reconcileSingleElement   reconcileChildrenArray   deleteAll
                        │                   │
                        │                   │
            ┌───────────┴───────────┐       │
            ▼                       ▼       │
        遍历旧链表               没找到     │
        找 key 相同的               │       │
            │                       │       │
       ┌────┴────┐                 ▼       │
       ▼         ▼           创建新 Fiber   │
    type 同    type 异             │       │
       │         │                 │       │
       ▼         ▼                 │       │
     复用    删除所有              │       │
       │         │                 │       ▼
       └────┬────┘                 │    ┌──────────────────────────────┐
            │                      │    │       两轮遍历               │
            ▼                      │    │                              │
        返回结果                   │    │  第一轮：从左到右比较 key    │
                                   │    │    ├── key 相同 → 复用/更新  │
                                   │    │    └── key 不同 → 跳出       │
                                   │    │                              │
                                   │    │  判断结束状态：              │
                                   │    │    ├── 新完旧剩 → 删除旧     │
                                   │    │    ├── 旧完新剩 → 新增       │
                                   │    │    └── 都有剩余 → 用 Map     │
                                   │    │                              │
                                   │    │  第二轮（用 Map）：          │
                                   │    │    ├── Map.get(key) 查找    │
                                   │    │    ├── placeChild 判断移动  │
                                   │    │    └── 删除 Map 剩余        │
                                   │    └──────────────────────────────┘
                                   │                    │
                                   └────────────────────┤
                                                        ▼
                                                   返回新链表
`;

// ============================================================
// Part 3: 面试高频题
// ============================================================

const interviewQuestions = `
💡 Q1: React Diff 算法的时间复杂度是多少？如何做到的？
A: O(n)。通过三个策略降低复杂度：
   1. 只同层比较，不跨层级
   2. 不同类型直接替换，不深度比较
   3. 通过 key 标识元素，避免全量比较

💡 Q2: 为什么不能用 index 作为 key？
A: 当列表发生重排时，index 会改变：
   
   旧: [A(key=0), B(key=1), C(key=2)]
   新: [C(key=0), A(key=1), B(key=2)]  // 反转
   
   React 认为 key=0 的元素从 A 变成了 C，会更新内容而不是移动。
   这导致：
   1. 不必要的 DOM 更新
   2. 组件状态错乱（如输入框内容）
   3. 性能下降

💡 Q3: 为什么不能用随机数作为 key？
A: 每次渲染 key 都变化，React 认为所有节点都是新的：
   - 全部销毁旧节点
   - 全部创建新节点
   - 比没有 key 还糟糕！

💡 Q4: 多节点 Diff 为什么要两轮遍历？
A: 针对不同场景优化：
   - 第一轮：处理「更新」（最常见场景），O(n) 线性扫描
   - 第二轮：处理「新增/删除/移动」，使用 Map 优化查找
   
   大多数情况第一轮就能完成，保证常见场景性能最优

💡 Q5: placeChild 中 lastPlacedIndex 的作用是什么？
A: 用于判断节点是否需要移动：
   - lastPlacedIndex 记录「最后一个不需要移动的节点」的旧位置
   - 如果当前节点的旧位置 < lastPlacedIndex，说明它需要移动
   - 这是一种「找最长递增子序列」的简化实现
   
   示例：旧 [A,B,C,D] → 新 [A,C,D,B]
   - A: oldIndex=0, lastPlacedIndex=0, 不移动
   - C: oldIndex=2 > 0, lastPlacedIndex=2, 不移动
   - D: oldIndex=3 > 2, lastPlacedIndex=3, 不移动
   - B: oldIndex=1 < 3, 需要移动！

💡 Q6: key 相同但 type 不同，为什么要删除所有兄弟节点？
A: 因为 key 是唯一标识。
   key 相同说明「这就是那个元素」，type 不同说明它变了。
   既然已经找到了目标元素，就不可能在其他兄弟中再找到匹配的。
   所以直接删除所有剩余节点。

💡 Q7: Diff 的结果是什么？副作用何时执行？
A: Diff 结果是给 Fiber 打上 flags 标记：
   - Placement: 需要插入或移动
   - ChildDeletion: 有子节点需要删除
   - Update: 需要更新属性
   
   副作用在 Commit 阶段的 Mutation 子阶段执行。

💡 Q8: React Diff 和 Vue Diff 有什么区别？
A: 
   React（单向遍历）:
   - 从左到右遍历
   - 使用 lastPlacedIndex 判断移动
   - 思路简单，但移动可能不是最优
   
   Vue2（双端比较）:
   - 新旧各两个指针
   - 头头、尾尾、头尾、尾头四种比较
   - 更快找到移动节点
   
   Vue3（最长递增子序列）:
   - 先双端比较处理两端不变的
   - 中间部分用最长递增子序列
   - 移动次数最少
   
   为什么 React 不用双端？
   - Fiber 是单向链表，没有 prev 指针
   - 增加 prev 会增加内存和维护成本

💡 Q9: 删除节点时做了什么？
A: deleteChild 函数：
   1. 将要删除的 Fiber 加入 returnFiber.deletions 数组
   2. 给 returnFiber 添加 ChildDeletion flag
   
   Commit 阶段：
   1. 递归调用 componentWillUnmount
   2. 从 DOM 树移除节点
   3. 清理 ref

💡 Q10: 为什么 Fiber 的结构是单向链表而不是数组？
A: 
   1. 增删更高效：链表 O(1)，数组 O(n)
   2. 遍历可中断：保存当前指针即可恢复
   3. 内存友好：不需要预分配空间
   4. 便于插入：不需要移动其他元素
`;

// ============================================================
// Part 4: 源码位置速查
// ============================================================

const sourceCodeLocations = `
📁 源码位置速查表

┌─────────────────────────────────────────────────────────────────────────┐
│ 功能                   │ 文件                           │ 行号          │
├────────────────────────┼────────────────────────────────┼───────────────┤
│ Diff 入口              │ ReactChildFiber.new.js        │ 1266-1387    │
│ reconcileChildFibers  │                                │              │
├────────────────────────┼────────────────────────────────┼───────────────┤
│ 单元素 Diff            │ ReactChildFiber.new.js        │ 1129-1205    │
│ reconcileSingleElement │                                │              │
├────────────────────────┼────────────────────────────────┼───────────────┤
│ 多元素 Diff            │ ReactChildFiber.new.js        │ 736-901      │
│ reconcileChildrenArray │                                │              │
├────────────────────────┼────────────────────────────────┼───────────────┤
│ 移动判断               │ ReactChildFiber.new.js        │ 329-357      │
│ placeChild             │                                │              │
├────────────────────────┼────────────────────────────────┼───────────────┤
│ 复用旧 Fiber           │ ReactChildFiber.new.js        │ 262-270      │
│ useFiber               │                                │              │
├────────────────────────┼────────────────────────────────┼───────────────┤
│ Map 构建               │ ReactChildFiber.new.js        │ 285-299      │
│ mapRemainingChildren   │                                │              │
├────────────────────────┼────────────────────────────────┼───────────────┤
│ 副作用标记             │ ReactFiberFlags.js            │ 14-32        │
│ Flags 定义             │                                │              │
├────────────────────────┼────────────────────────────────┼───────────────┤
│ Fiber 创建             │ ReactFiber.new.js             │ 118-200      │
│ FiberNode              │                                │              │
└────────────────────────┴────────────────────────────────┴───────────────┘
`;

// ============================================================
// Part 5: 学习检查清单
// ============================================================

const learningChecklist = `
✅ Phase 5 学习检查

□ 基础概念
  □ 能说出传统 Diff O(n³) 和 React O(n) 的区别
  □ 能说出 React Diff 的三个策略/限制
  □ 理解 key 的作用和为什么不能用 index

□ 单节点 Diff
  □ 理解 reconcileSingleElement 流程
  □ 理解 key 和 type 的比较顺序
  □ 能解释为什么 key 相同 type 不同要删除所有兄弟

□ 多节点 Diff（核心！）
  □ 理解两轮遍历的设计思想
  □ 理解第一轮遍历何时跳出
  □ 理解第二轮遍历的三种情况
  □ 理解 placeChild 和 lastPlacedIndex
  □ 能手写移动判断的过程

□ 数据结构
  □ 理解 Fiber 中与 Diff 相关的属性
  □ 理解 existingChildren Map 的作用
  □ 理解 Flags 的位运算

□ 源码位置
  □ 能找到 ReactChildFiber.new.js
  □ 能找到核心函数的位置
`;

export {
  dataStructureSummary,
  algorithmFlowSummary,
  interviewQuestions,
  sourceCodeLocations,
  learningChecklist,
};

