/**
 * ============================================================
 * 📚 Phase 2: Fiber 架构 - Part 1: 概览与设计动机
 * ============================================================
 *
 * 📁 核心源码位置:
 * - packages/react-reconciler/src/ReactFiber.new.js
 * - packages/react-reconciler/src/ReactFiberWorkLoop.new.js
 *
 * ⏱️ 预计时间：2-3 小时
 * 🎯 面试权重：⭐⭐⭐⭐⭐
 */

// ============================================================
// Part 1: Stack Reconciler 的问题
// ============================================================

/**
 * 📊 为什么需要 Fiber？从旧架构说起
 */

const whyFiber = `
📊 为什么需要 Fiber？从旧架构说起

┌─────────────────────────────────────────────────────────────────────────────┐
│                    Stack Reconciler（React 15 及之前）                       │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  React 15 使用的是 Stack Reconciler（栈调和器）                              │
│                                                                             │
│  工作方式：                                                                 │
│  ─────────────                                                              │
│  • 递归遍历组件树，一次性完成整棵树的比较和更新                             │
│  • 使用 JavaScript 调用栈来管理递归                                         │
│  • 一旦开始，无法中断，必须一次性完成                                       │
│                                                                             │
│  问题场景：                                                                 │
│  ─────────────                                                              │
│  假设有一个包含 1000 个节点的组件树需要更新，每个节点处理需要 1ms            │
│  → 整个更新需要 1000ms = 1 秒                                               │
│  → 在这 1 秒内，主线程被完全占用                                            │
│  → 用户的任何交互（点击、输入）都无法响应                                   │
│  → 动画卡顿、界面冻结                                                       │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

递归调用的问题图示:
═══════════════════════════════════════════════════════════════════════════════

┌─────────────────────────────────────────────────────────────────────────────┐
│                                                                             │
│   Stack Reconciler 的执行过程：                                             │
│                                                                             │
│   时间线 ──────────────────────────────────────────────────────▶            │
│                                                                             │
│   ┌──────────────────────────────────────────────────────────────┐          │
│   │                   整个更新过程                                │          │
│   │                   （不可中断）                                │          │
│   │                                                              │          │
│   │   render(A) → render(B) → render(C) → ... → render(Z)       │          │
│   │      ↓           ↓           ↓                   ↓          │          │
│   │   调用栈        调用栈       调用栈              调用栈      │          │
│   │   不断         不断         不断                 最终       │          │
│   │   加深         加深         加深                 返回       │          │
│   └──────────────────────────────────────────────────────────────┘          │
│                                                                             │
│   ⚠️ 问题：这期间用户输入、动画帧都在等待！                                 │
│                                                                             │
│   ┌──────────────────────────────────────────────────────────────┐          │
│   │  用户点击按钮...                                             │          │
│   │  等待...等待...等待...                                       │          │
│   │  终于响应了！（用户已经失去耐心）                            │          │
│   └──────────────────────────────────────────────────────────────┘          │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

人类感知的阈值：
─────────────────────────

• 100ms 以内：用户感觉"立即"响应
• 100-300ms：用户感觉"略有延迟"但可接受
• 300ms 以上：用户感觉"卡顿"、"慢"
• 1000ms 以上：用户可能认为"出了问题"

浏览器每帧的时间预算：
─────────────────────────

• 60fps → 每帧约 16.67ms
• React 需要在这个时间内完成：
  - JavaScript 执行
  - 样式计算
  - 布局
  - 绘制

如果 React 的 render 占用超过这个时间，就会掉帧！
`;

// ============================================================
// Part 2: Fiber 架构的目标
// ============================================================

/**
 * 📊 Fiber 架构要解决的问题
 */

const fiberGoals = `
📊 Fiber 架构的目标

┌─────────────────────────────────────────────────────────────────────────────┐
│                       Fiber 架构的核心目标                                   │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  1. 可中断（Interruptible）                                                 │
│     ─────────────────────────                                               │
│     渲染工作可以被暂停，把控制权交还给浏览器                                │
│     浏览器处理完用户交互后，再继续渲染                                      │
│                                                                             │
│  2. 可恢复（Resumable）                                                     │
│     ─────────────────────────                                               │
│     暂停后可以从断点继续，不需要重头开始                                    │
│     这需要保存中间状态                                                      │
│                                                                             │
│  3. 可放弃（Abortable）                                                     │
│     ─────────────────────────                                               │
│     如果有更高优先级的任务，可以放弃当前工作                                │
│     开始处理更紧急的更新                                                    │
│                                                                             │
│  4. 支持优先级（Priority-based）                                            │
│     ─────────────────────────                                               │
│     不同的更新有不同的优先级                                                │
│     用户交互 > 数据获取 > 预加载                                            │
│                                                                             │
│  5. 支持并发（Concurrent）                                                  │
│     ─────────────────────────                                               │
│     可以同时准备多个版本的 UI                                               │
│     在需要时快速切换                                                        │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

Fiber 如何实现可中断：
═══════════════════════════════════════════════════════════════════════════════

┌─────────────────────────────────────────────────────────────────────────────┐
│                                                                             │
│   Fiber 架构的执行过程：                                                    │
│                                                                             │
│   时间线 ──────────────────────────────────────────────────────▶            │
│                                                                             │
│   ┌─────┐ ┌─────┐ ┌─────┐     ┌─────┐ ┌─────┐ ┌─────┐                      │
│   │工作1│ │工作2│ │工作3│ ... │工作n│ │工作n+1│ │...  │                      │
│   └──┬──┘ └──┬──┘ └──┬──┘     └──┬──┘ └──┬──┘ └──┬──┘                      │
│      │       │       │           │       │       │                          │
│      ▼       ▼       ▼           ▼       ▼       ▼                          │
│   ┌─────────────────────┐     ┌─────────────────────┐                      │
│   │  第一个时间片        │     │  第二个时间片        │                      │
│   │  （5ms）             │     │  （5ms）             │                      │
│   └─────────────────────┘     └─────────────────────┘                      │
│                ↑                           ↑                                │
│                │                           │                                │
│           检查点：                      检查点：                            │
│           时间到了吗？                  时间到了吗？                        │
│           有更高优先级任务吗？          有更高优先级任务吗？                │
│                                                                             │
│   ┌──────────┐                                                              │
│   │ 用户输入 │  ← 可以在时间片之间被处理！                                  │
│   └──────────┘                                                              │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

关键变化：递归 → 循环
─────────────────────────

// Stack Reconciler（递归，无法中断）
function reconcile(element) {
  // ... 处理当前节点
  element.children.forEach(child => reconcile(child));  // 递归调用
}

// Fiber Reconciler（循环，可以中断）
function workLoop() {
  while (workInProgress !== null && !shouldYield()) {
    workInProgress = performUnitOfWork(workInProgress);  // 处理一个单元
  }
  // 时间到了或有更高优先级任务，退出循环
  // 下次继续从 workInProgress 开始
}
`;

// ============================================================
// Part 3: Fiber 是什么？
// ============================================================

/**
 * 📊 Fiber 的定义与比喻
 */

const whatIsFiber = `
📊 Fiber 是什么？

┌─────────────────────────────────────────────────────────────────────────────┐
│                       Fiber 的多重含义                                       │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  1. Fiber 作为架构名称                                                      │
│     ─────────────────────────                                               │
│     React 16+ 的新 Reconciler 架构，替代 Stack Reconciler                   │
│                                                                             │
│  2. Fiber 作为数据结构                                                      │
│     ─────────────────────────                                               │
│     一个 JavaScript 对象（FiberNode），描述组件和 DOM 节点                   │
│     包含：类型信息、状态、关系指针、副作用标记等                            │
│                                                                             │
│  3. Fiber 作为工作单元                                                      │
│     ─────────────────────────                                               │
│     每个 Fiber 节点代表一个"可以独立完成的工作单元"                          │
│     React 可以处理完一个 Fiber 后暂停，稍后继续下一个                        │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

直观比喻：
═══════════════════════════════════════════════════════════════════════════════

┌─────────────────────────────────────────────────────────────────────────────┐
│                                                                             │
│   📖 书签比喻                                                               │
│   ─────────────                                                             │
│                                                                             │
│   传统递归（Stack）就像：                                                   │
│   - 你必须一口气读完整本书                                                  │
│   - 如果中途被打断，就要从头开始                                            │
│   - 因为你不知道读到哪里了                                                  │
│                                                                             │
│   Fiber 架构就像：                                                          │
│   - 每读完一章，就夹一个书签                                                │
│   - 每个书签记录了你在这一章的进度                                          │
│   - 被打断后，可以从书签处继续                                              │
│   - Fiber 节点就是这些"书签"                                                │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│                                                                             │
│   🔗 链表比喻                                                               │
│   ─────────────                                                             │
│                                                                             │
│   传统虚拟 DOM 树：                                                         │
│   - 只有父子关系（children 数组）                                           │
│   - 遍历需要递归                                                            │
│                                                                             │
│   Fiber 树：                                                                │
│   - 链表化的虚拟 DOM                                                        │
│   - 每个节点知道：                                                          │
│     • 父节点是谁（return）                                                  │
│     • 第一个子节点是谁（child）                                             │
│     • 下一个兄弟是谁（sibling）                                             │
│   - 可以用循环遍历整棵树                                                    │
│                                                                             │
│   结构对比：                                                                │
│                                                                             │
│   ReactElement（树）：          FiberNode（链表化的树）：                   │
│                                                                             │
│        App                            App                                   │
│       /   \\                            │                                    │
│    Header  Main                      child                                  │
│      │      │                          ↓                                    │
│    Title  Content                   Header ──sibling──▶ Main                │
│                                        │                  │                 │
│                                      child              child               │
│                                        ↓                  ↓                 │
│                                      Title             Content              │
│                                                                             │
│   遍历：递归 DFS                   遍历：循环即可                            │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
`;

// ============================================================
// Part 4: Fiber 与 ReactElement / DOM 的关系
// ============================================================

/**
 * 📊 三种"节点"的对比
 */

const threeNodes = `
📊 ReactElement vs Fiber vs DOM 的关系

┌─────────────────────────────────────────────────────────────────────────────┐
│                       三种"节点"对比                                         │
├───────────────────┬─────────────────────────────────────────────────────────┤
│ 类型              │ 说明                                                     │
├───────────────────┼─────────────────────────────────────────────────────────┤
│ ReactElement      │ JSX 编译后的对象，描述"想要什么"                        │
│                   │ 每次渲染都会创建新的对象                                │
│                   │ 轻量、临时、只读                                        │
├───────────────────┼─────────────────────────────────────────────────────────┤
│ FiberNode         │ React 内部的工作单元，描述"如何工作"                    │
│                   │ 持久存在，在更新时复用/修改                             │
│                   │ 包含状态、副作用、优先级等                              │
├───────────────────┼─────────────────────────────────────────────────────────┤
│ DOM Node          │ 浏览器中的真实节点                                      │
│                   │ 只有 HostComponent 类型的 Fiber 才有对应的 DOM          │
│                   │ 存储在 Fiber.stateNode 中                               │
└───────────────────┴─────────────────────────────────────────────────────────┘

数据流转：
═══════════════════════════════════════════════════════════════════════════════

┌─────────────────────────────────────────────────────────────────────────────┐
│                                                                             │
│   [开发者写的代码]                                                          │
│         │                                                                   │
│         │  Babel / JSX 编译                                                 │
│         ▼                                                                   │
│   ┌─────────────────┐                                                       │
│   │  ReactElement   │  ← "我想要一个 <div className='app'>..."              │
│   │  (描述对象)     │                                                       │
│   └────────┬────────┘                                                       │
│            │                                                                │
│            │  createFiberFromElement()                                      │
│            ▼                                                                │
│   ┌─────────────────┐                                                       │
│   │   FiberNode     │  ← "这是一个 HostComponent，type='div'"               │
│   │  (工作单元)     │     "pendingProps={className:'app'}"                  │
│   │                 │     "需要 Placement 副作用"                            │
│   └────────┬────────┘                                                       │
│            │                                                                │
│            │  Commit 阶段                                                   │
│            ▼                                                                │
│   ┌─────────────────┐                                                       │
│   │   DOM Node      │  ← document.createElement('div')                     │
│   │  (真实节点)     │     div.className = 'app'                            │
│   └─────────────────┘                                                       │
│                                                                             │
│   Fiber.stateNode ──────────────────────▶ DOM Node                         │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

为什么需要 Fiber 这个中间层？
─────────────────────────

1. ReactElement 太"轻"，无法存储工作状态
   - 每次渲染都是新对象
   - 没有地方存储"处理到哪了"

2. DOM 操作太"重"，不适合频繁创建/比较
   - 创建 DOM 节点开销大
   - 直接操作 DOM 会触发重排重绘

3. Fiber 刚好在中间
   - 可以存储状态、副作用、优先级
   - 可以复用、可以中断
   - 在 Render 阶段不涉及真实 DOM
`;

// ============================================================
// Part 5: 面试要点
// ============================================================

const interviewPoints = `
💡 Part 1 面试要点

Q1: 什么是 Fiber？为什么 React 要引入 Fiber？
A: Fiber 是 React 16 引入的新的 Reconciler 架构。
   引入原因是解决 Stack Reconciler 的问题：
   - 递归渲染无法中断，长时间占用主线程
   - 导致用户交互无响应、动画卡顿
   Fiber 通过将渲染工作拆分为小单元，支持中断和恢复。

Q2: Fiber 架构的核心目标是什么？
A: 五个核心目标：
   1. 可中断：渲染可以暂停
   2. 可恢复：从断点继续，不需重头开始
   3. 可放弃：高优先级任务可以抢占
   4. 支持优先级：不同更新有不同优先级
   5. 支持并发：可以准备多个 UI 版本

Q3: Fiber 是如何实现可中断的？
A: 两个关键变化：
   1. 递归 → 循环：用 while 循环替代递归调用
   2. 树 → 链表：每个 Fiber 节点有 child/sibling/return 指针
   工作循环每处理一个单元后检查：
   - 时间片是否用完
   - 是否有更高优先级任务
   如果有，就暂停当前工作，下次从断点继续。

Q4: ReactElement、Fiber、DOM 节点有什么区别和关系？
A: - ReactElement：JSX 编译后的描述对象，临时、只读
   - Fiber：React 内部的工作单元，持久、可修改
   - DOM：浏览器真实节点，只有 HostComponent 才有
   数据流：ReactElement → Fiber → DOM
   Fiber.stateNode 指向对应的 DOM 节点

Q5: Fiber 的"工作单元"是什么意思？
A: 每个 Fiber 节点代表一个可以独立完成的工作单元。
   React 可以：
   - 处理完一个 Fiber 后暂停
   - 保存当前进度（workInProgress 指针）
   - 下次从断点继续处理下一个 Fiber
   这就像看书时用书签标记进度一样。
`;

export {
  whyFiber,
  fiberGoals,
  whatIsFiber,
  threeNodes,
  interviewPoints,
};

