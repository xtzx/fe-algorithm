/**
 * ============================================================
 * 📚 Phase 4: Hooks 原理 - Part 1: 概览与设计目标
 * ============================================================
 *
 * 📁 核心源码位置:
 * - packages/react-reconciler/src/ReactFiberHooks.new.js
 * - packages/react/src/ReactCurrentDispatcher.js
 *
 * ⏱️ 预计时间：1-2 小时
 * 🎯 面试权重：⭐⭐⭐⭐⭐
 */

// ============================================================
// Part 1: Hooks 的设计目标
// ============================================================

/**
 * 📊 为什么需要 Hooks？
 */

const whyHooks = `
📊 为什么需要 Hooks？

Class 组件的问题:
═══════════════════════════════════════════════════════════════════════════════

┌─────────────────────────────────────────────────────────────────────────────┐
│ 问题                                    │ 说明                               │
├─────────────────────────────────────────┼────────────────────────────────────┤
│ 1. 逻辑复用困难                         │ HOC / Render Props 导致组件嵌套深  │
│                                         │ "包装地狱"（Wrapper Hell）         │
├─────────────────────────────────────────┼────────────────────────────────────┤
│ 2. 生命周期方法拆分逻辑                 │ 相关逻辑分散在多个生命周期中       │
│                                         │ 如：订阅在 didMount，清理在 willUnmount │
├─────────────────────────────────────────┼────────────────────────────────────┤
│ 3. this 绑定复杂                        │ 事件处理需要 bind 或箭头函数       │
│                                         │ 新手容易出错                       │
├─────────────────────────────────────────┼────────────────────────────────────┤
│ 4. 类难以优化                           │ 类组件不利于代码压缩               │
│                                         │ 热重载体验差                       │
└─────────────────────────────────────────┴────────────────────────────────────┘


Hooks 的解决方案:
═══════════════════════════════════════════════════════════════════════════════

┌─────────────────────────────────────────────────────────────────────────────┐
│                                                                             │
│   ┌─────────────────┐                                                       │
│   │    函数组件     │  +  Hooks  =  完整的组件能力                          │
│   │  (无状态)       │                                                       │
│   └─────────────────┘                                                       │
│                                                                             │
│   Hooks 让函数组件拥有:                                                      │
│   ─────────────────────                                                     │
│   • useState        → 状态管理                                              │
│   • useEffect       → 副作用（生命周期替代）                                │
│   • useContext      → Context 消费                                          │
│   • useRef          → 可变引用                                              │
│   • useMemo         → 计算值缓存                                            │
│   • useCallback     → 函数缓存                                              │
│   • useReducer      → 复杂状态管理                                          │
│   • useLayoutEffect → 同步副作用                                            │
│   • ...                                                                     │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘


Hooks 的核心思想:
═══════════════════════════════════════════════════════════════════════════════

1. 以"函数"为核心，而不是"类"
   • 更符合 JavaScript 函数式编程范式
   • 更容易理解和测试

2. 按"关注点"组织代码，而不是按"生命周期"
   • 相关逻辑放在一起
   • 例如：订阅和清理写在同一个 useEffect 中

3. 逻辑复用通过"自定义 Hook"实现
   • 不需要 HOC 或 Render Props
   • 没有组件嵌套问题

4. 细粒度的状态更新
   • 每个状态独立
   • 不像 Class 需要合并到一个 this.state
`;

// ============================================================
// Part 2: Hooks 的内部核心概念
// ============================================================

/**
 * 📊 Hooks 内部核心概念
 */

const coreConceptsOverview = `
📊 Hooks 内部核心概念

三个关键概念:
═══════════════════════════════════════════════════════════════════════════════

┌─────────────────────────────────────────────────────────────────────────────┐
│                                                                             │
│   1️⃣  Hook 链表                                                             │
│   ────────────────────                                                      │
│                                                                             │
│   每个函数组件的所有 Hooks 形成一个链表，挂在 Fiber.memoizedState 上        │
│                                                                             │
│   Fiber.memoizedState ──▶ Hook1 ──▶ Hook2 ──▶ Hook3 ──▶ null               │
│                          (useState) (useMemo) (useEffect)                   │
│                                                                             │
│   • 每个 Hook 有自己的 memoizedState（存储状态/缓存值/effect 等）           │
│   • 通过 next 指针连接                                                      │
│   • 渲染时按顺序遍历                                                        │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│                                                                             │
│   2️⃣  Dispatcher（当前 Hooks 实现）                                         │
│   ────────────────────────────────                                          │
│                                                                             │
│   不同阶段使用不同的 Hooks 实现:                                             │
│                                                                             │
│   ┌───────────────────────┐     ┌───────────────────────┐                  │
│   │  HooksDispatcherOnMount │     │ HooksDispatcherOnUpdate │                  │
│   │  (首次渲染)             │     │ (更新渲染)              │                  │
│   └───────────────────────┘     └───────────────────────┘                  │
│   │ useState: mountState   │     │ useState: updateState   │                  │
│   │ useEffect: mountEffect │     │ useEffect: updateEffect │                  │
│   └───────────────────────┘     └───────────────────────┘                  │
│                                                                             │
│   通过 ReactCurrentDispatcher.current 切换                                  │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│                                                                             │
│   3️⃣  按顺序消费（为什么不能在条件中调用 Hook）                              │
│   ────────────────────────────────────────────                              │
│                                                                             │
│   渲染时通过"指针"按顺序遍历 Hook 链表:                                      │
│                                                                             │
│   首次渲染（mount）:                                                         │
│   ─────────────────                                                         │
│   每调用一个 Hook → 创建一个 Hook 节点 → 追加到链表末尾                      │
│                                                                             │
│   更新渲染（update）:                                                        │
│   ─────────────────                                                         │
│   每调用一个 Hook → 移动指针到下一个 Hook → 读取/更新该 Hook 的状态          │
│                                                                             │
│   ⚠️ 关键：必须保证每次渲染 Hook 调用顺序一致                                │
│   否则指针会错位，读取到错误的 Hook！                                        │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
`;

// ============================================================
// Part 3: Hook 链表的直观理解
// ============================================================

/**
 * 📊 Hook 链表图示
 */

const hookLinkedList = `
📊 Hook 链表的直观理解

示例组件:
═══════════════════════════════════════════════════════════════════════════════

function Counter() {
  const [count, setCount] = useState(0);        // Hook 1
  const doubledCount = useMemo(() => count * 2, [count]);  // Hook 2
  useEffect(() => { console.log(count); }, [count]);       // Hook 3
  return <div>{count} × 2 = {doubledCount}</div>;
}


对应的 Hook 链表:
═══════════════════════════════════════════════════════════════════════════════

┌─────────────────────────────────────────────────────────────────────────────┐
│                                                                             │
│   Fiber (Counter)                                                           │
│   ┌─────────────────────────────────────────────────────────────────────┐  │
│   │ memoizedState ─────────────────────────────────────────────────────▼│  │
│   └─────────────────────────────────────────────────────────────────────┘  │
│                                                                             │
│   ┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐     │
│   │ Hook 1 (useState)│     │ Hook 2 (useMemo) │     │ Hook 3 (useEffect)│     │
│   │─────────────────│     │─────────────────│     │─────────────────│     │
│   │ memoizedState:  │     │ memoizedState:  │     │ memoizedState:  │     │
│   │   0 (count值)   │     │   [0, [0]]      │     │   Effect对象    │     │
│   │                 │     │   (缓存值,deps) │     │   {create,deps..}│     │
│   │ queue:          │     │                 │     │                 │     │
│   │   UpdateQueue   │     │                 │     │                 │     │
│   │                 │     │                 │     │                 │     │
│   │ next: ──────────┼────▶│ next: ──────────┼────▶│ next: null      │     │
│   └─────────────────┘     └─────────────────┘     └─────────────────┘     │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘


首次渲染 vs 更新渲染:
═══════════════════════════════════════════════════════════════════════════════

首次渲染（mount）:
─────────────────────────────────────────────────────────────────

┌─────────────────────────────────────────────────────────────────────────────┐
│                                                                             │
│   useState(0)      → mountState → 创建 Hook1，memoizedState = 0            │
│         │                                                                   │
│         ▼                                                                   │
│   useMemo(...)     → mountMemo  → 创建 Hook2，memoizedState = [0, [0]]     │
│         │                                                                   │
│         ▼                                                                   │
│   useEffect(...)   → mountEffect→ 创建 Hook3，memoizedState = Effect       │
│                                                                             │
│   结果：创建 Hook1 → Hook2 → Hook3 链表                                     │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

更新渲染（update）:
─────────────────────────────────────────────────────────────────

┌─────────────────────────────────────────────────────────────────────────────┐
│                                                                             │
│   currentHook 指针从 null 开始                                              │
│         │                                                                   │
│         ▼                                                                   │
│   useState(0)      → updateState → 指针移到 Hook1，处理更新队列，返回状态   │
│         │                                                                   │
│         │  currentHook = Hook1                                              │
│         ▼                                                                   │
│   useMemo(...)     → updateMemo  → 指针移到 Hook2，比较 deps，返回缓存/重算 │
│         │                                                                   │
│         │  currentHook = Hook2                                              │
│         ▼                                                                   │
│   useEffect(...)   → updateEffect→ 指针移到 Hook3，比较 deps，标记 effect   │
│                                                                             │
│   结果：复用现有链表，按顺序更新                                            │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
`;

// ============================================================
// Part 4: 为什么 Hook 必须按顺序调用？
// ============================================================

/**
 * 📊 Hook 顺序规则
 */

const hookOrderRule = `
📊 为什么 Hook 必须按固定顺序调用？

规则：Hook 只能在函数组件的顶层调用，不能在条件/循环/嵌套函数中调用
═══════════════════════════════════════════════════════════════════════════════


❌ 错误示例：条件调用
─────────────────────────────────────────────────────────────────

function BadComponent({ showCount }) {
  // ❌ Hook 在条件中调用
  if (showCount) {
    const [count, setCount] = useState(0);  // 条件为 true 时才调用
  }

  const [name, setName] = useState('React'); // 总是调用

  return <div>{name}</div>;
}


这会导致什么问题？
─────────────────────────────────────────────────────────────────

┌─────────────────────────────────────────────────────────────────────────────┐
│                                                                             │
│   假设 showCount 从 true 变为 false:                                        │
│                                                                             │
│   第一次渲染（showCount = true）:                                           │
│   ─────────────────────────────                                             │
│                                                                             │
│   Hook 链表: Hook1(count) ──▶ Hook2(name) ──▶ null                         │
│                   ↑              ↑                                          │
│             useState(0)    useState('React')                                │
│                                                                             │
│   第二次渲染（showCount = false）:                                          │
│   ─────────────────────────────                                             │
│                                                                             │
│   Hook 链表: Hook1(count) ──▶ Hook2(name) ──▶ null                         │
│                   ↑                                                         │
│             useState('React')  ← ⚠️ 第一个 useState 指向了 Hook1(count)!   │
│                                                                             │
│   问题：name 状态读取到了 count 的值 (0)！                                  │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘


源码中的检查（DEV 模式）:
─────────────────────────────────────────────────────────────────

📁 ReactFiberHooks.new.js

function updateWorkInProgressHook(): Hook {
  // ...
  if (nextCurrentHook === null) {
    // ⚠️ 抛出错误
    throw new Error('Rendered more hooks than during the previous render.');
  }
  // ...
}

// 这个错误意味着：
// 更新渲染时调用的 Hook 数量比首次渲染多（或顺序不一致）


✅ 正确做法
─────────────────────────────────────────────────────────────────

function GoodComponent({ showCount }) {
  // ✅ Hook 始终在顶层调用
  const [count, setCount] = useState(0);
  const [name, setName] = useState('React');

  // 在渲染逻辑中处理条件
  return (
    <div>
      {showCount && <span>{count}</span>}
      <span>{name}</span>
    </div>
  );
}
`;

// ============================================================
// Part 5: 面试要点
// ============================================================

const interviewPoints = `
💡 Part 1 面试要点

Q1: Hooks 解决了 Class 组件的哪些问题？
A: 1. 逻辑复用困难 → 自定义 Hook
   2. 相关逻辑分散 → 一个 Hook 包含完整逻辑
   3. this 绑定复杂 → 函数组件没有 this
   4. 类难以优化 → 函数更易压缩和优化

Q2: Hooks 在内部是如何存储的？
A: Hooks 以链表形式存储在 Fiber.memoizedState 上。
   每个 Hook 是一个对象，包含 memoizedState、queue、next 等字段。
   函数组件的所有 Hook 通过 next 指针连接成链表。

Q3: 什么是 Dispatcher？有什么作用？
A: Dispatcher 是当前 Hooks 实现的集合。
   React 通过 ReactCurrentDispatcher.current 指向不同的 Dispatcher：
   - 首次渲染：HooksDispatcherOnMount（创建 Hook）
   - 更新渲染：HooksDispatcherOnUpdate（复用 Hook）
   这样同一个 useState 在不同阶段执行不同逻辑。

Q4: 为什么 Hook 必须按固定顺序调用？
A: React 通过"位置"来识别每个 Hook：
   - 首次渲染：按调用顺序创建 Hook 链表
   - 更新渲染：按调用顺序遍历链表，读取对应 Hook
   如果顺序改变，指针会错位，读取到错误的状态。

Q5: 在条件中调用 Hook 会发生什么？
A: 如果条件为 false，Hook 不被调用，链表中少了一个节点。
   后续 Hook 读取时指针错位，状态混乱。
   DEV 模式会报错："Rendered more hooks than during the previous render."
`;

export {
  whyHooks,
  coreConceptsOverview,
  hookLinkedList,
  hookOrderRule,
  interviewPoints,
};

