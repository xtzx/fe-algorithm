/**
 * ============================================================
 * 📚 Phase 7: 并发特性 - Part 1: 概览与核心思想
 * ============================================================
 *
 * 📁 核心源码位置:
 * - packages/react/src/ReactStartTransition.js
 * - packages/react-reconciler/src/ReactFiberWorkLoop.new.js
 * - packages/react-reconciler/src/ReactFiberLane.new.js
 *
 * ⏱️ 预计时间：3-4 小时
 * 🎯 面试权重：⭐⭐⭐⭐⭐
 */

// ============================================================
// Part 1: 并发模式解决的核心问题
// ============================================================

/**
 * 📊 传统同步渲染的问题
 *
 * React 17 及之前：一次更新开始后必须完成，无法中断
 */

const syncRenderingProblem = `
📊 同步渲染的问题

场景：用户在搜索框输入，同时需要过滤 10000 条数据

┌─────────────────────────────────────────────────────────────────────────────┐
│                        同步渲染模式                                          │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  用户输入 'a'                                                               │
│       │                                                                     │
│       ▼                                                                     │
│  ├────────────────────────────────────────────────────────────┤             │
│  │              渲染 10000 个列表项 (200ms)                    │             │
│  └────────────────────────────────────────────────────────────┘             │
│                                                                   ↑         │
│  用户继续输入 'ab'  ─────────────────────────────────────────────┘         │
│  （被阻塞，无法响应！）                                                      │
│                                                                             │
│  问题：                                                                     │
│  1. 输入框无响应 → 用户感知"卡顿"                                           │
│  2. 无法取消正在进行的渲染                                                  │
│  3. 渲染完成后，用户可能已经输入了新内容，结果过时                           │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
`;

/**
 * 📊 并发模式的解决方案
 */

const concurrentSolution = `
📊 并发模式的解决方案

┌─────────────────────────────────────────────────────────────────────────────┐
│                        并发渲染模式                                          │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  用户输入 'a'                                                               │
│       │                                                                     │
│       ▼                                                                     │
│  ├────┤ ├────┤ ├────┤        ← 低优先级（列表渲染）                         │
│  │渲染│ │渲染│ │渲染│...                                                    │
│  └────┘ └────┘ └────┘                                                       │
│           ↑                                                                 │
│           │                                                                 │
│  用户输入 'ab' ───────────────────────────────────────────────┐             │
│       │                                                       │             │
│       ▼                                                       ▼             │
│  ├──────────┤                                           中断旧渲染！         │
│  │ 更新输入框│  ← 高优先级（立即响应）                                       │
│  └──────────┘                                                               │
│       │                                                                     │
│       ▼                                                                     │
│  ├────┤ ├────┤ ├────┤ ├────┤ ├────┤                                        │
│  │渲染│ │渲染│ │渲染│ │渲染│ │渲染│ ← 重新开始渲染 'ab' 的结果              │
│  └────┘ └────┘ └────┘ └────┘ └────┘                                        │
│                                                                             │
│  优势：                                                                     │
│  1. 输入框始终保持响应                                                      │
│  2. 可以取消/丢弃过时的渲染                                                 │
│  3. 用户始终看到最新的结果                                                  │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
`;

// ============================================================
// Part 2: 核心术语解释
// ============================================================

/**
 * 📊 关键术语
 */

const keyTerminology = `
📊 并发特性关键术语

┌─────────────────────────────────────────────────────────────────────────────┐
│ 术语                    │ 含义                                              │
├─────────────────────────┼───────────────────────────────────────────────────┤
│                                                                             │
│ Concurrent Mode        │ 并发模式的总称，React 18 默认启用                  │
│ 并发模式               │                                                    │
│                                                                             │
│ Interruptible Rendering │ 可中断渲染，渲染过程可以被暂停和恢复              │
│ 可中断渲染              │                                                    │
│                                                                             │
│ Time Slicing           │ 时间切片，将长任务拆分成多个小任务                 │
│ 时间切片               │ 每个切片约 5ms，避免阻塞主线程                     │
│                                                                             │
│ Priority-based         │ 基于优先级的更新调度                               │
│ Scheduling             │ 高优先级更新可以打断低优先级更新                   │
│                                                                             │
│ Transition             │ 过渡更新，标记为低优先级的更新                     │
│ 过渡更新               │ 可以被用户交互打断                                 │
│                                                                             │
│ Urgent Update          │ 紧急更新，需要立即响应的更新                       │
│ 紧急更新               │ 如用户输入、点击等                                 │
│                                                                             │
│ Suspense               │ 挂起，组件等待异步数据时显示 fallback             │
│ 挂起                   │ 数据就绪后自动切换到真实内容                       │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
`;

// ============================================================
// Part 3: 同步 vs 并发 对比
// ============================================================

/**
 * 📊 同步模式 vs 并发模式
 */

const syncVsConcurrent = `
📊 同步模式 vs 并发模式 对比

┌───────────────────────────────────────────────────────────────────────────────┐
│ 特性              │ 同步模式（Legacy）        │ 并发模式（Concurrent）         │
├───────────────────┼───────────────────────────┼─────────────────────────────────┤
│                   │                           │                                 │
│ 渲染方式          │ 一次性完成，不可中断      │ 可分片，可中断，可恢复          │
│                   │                           │                                 │
│ 优先级            │ 所有更新同等优先级        │ 多优先级，高优可打断低优        │
│                   │                           │                                 │
│ 用户交互          │ 渲染期间无法响应          │ 随时可以响应                    │
│                   │                           │                                 │
│ 更新合并          │ 有限的批处理              │ 自动批处理 + 智能合并           │
│                   │                           │                                 │
│ 过时更新          │ 必须完成                  │ 可以丢弃                        │
│                   │                           │                                 │
│ 启用方式          │ ReactDOM.render()         │ ReactDOM.createRoot()           │
│                   │                           │                                 │
│ 支持特性          │ 基础功能                  │ Suspense、Transitions 等        │
│                   │                           │                                 │
└───────────────────┴───────────────────────────┴─────────────────────────────────┘

代码对比:

// 同步模式（React 17 风格，React 18 仍支持但不推荐）
import ReactDOM from 'react-dom';
ReactDOM.render(<App />, document.getElementById('root'));

// 并发模式（React 18 推荐）
import { createRoot } from 'react-dom/client';
const root = createRoot(document.getElementById('root'));
root.render(<App />);
`;

// ============================================================
// Part 4: 并发特性建立在哪些基础之上
// ============================================================

/**
 * 📊 并发特性的技术基础
 */

const technicalFoundation = `
📊 并发特性的技术基础

┌─────────────────────────────────────────────────────────────────────────────┐
│                                                                             │
│                         并发特性                                            │
│   ┌─────────────────────────────────────────────────────────────────────┐   │
│   │  startTransition  │  useTransition  │  useDeferredValue  │ Suspense │   │
│   └─────────────────────────────────────────────────────────────────────┘   │
│                                    │                                        │
│                                    │ 基于                                   │
│                                    ▼                                        │
│   ┌─────────────────────────────────────────────────────────────────────┐   │
│   │                          Lane 优先级模型                             │   │
│   │                                                                     │   │
│   │  SyncLane → InputContinuousLane → DefaultLane → TransitionLane     │   │
│   │  (最高)                                              (较低)         │   │
│   └─────────────────────────────────────────────────────────────────────┘   │
│                                    │                                        │
│                                    │ 基于                                   │
│                                    ▼                                        │
│   ┌─────────────────────────────────────────────────────────────────────┐   │
│   │                          Scheduler 调度器                           │   │
│   │                                                                     │   │
│   │  任务队列  │  优先级调度  │  时间切片  │  可中断执行                  │   │
│   └─────────────────────────────────────────────────────────────────────┘   │
│                                    │                                        │
│                                    │ 基于                                   │
│                                    ▼                                        │
│   ┌─────────────────────────────────────────────────────────────────────┐   │
│   │                          Fiber 架构                                 │   │
│   │                                                                     │   │
│   │  链表结构  │  可暂停遍历  │  workInProgress 双缓冲  │  增量更新     │   │
│   └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

为什么需要这些基础？

1. Fiber 架构（Phase 2）
   - 链表结构使得遍历可以暂停和恢复
   - 每个 Fiber 是独立的工作单元
   - workInProgress 保存中间状态

2. Scheduler（Phase 6）
   - 时间切片：每 5ms 检查是否让出
   - 优先级队列：高优先级任务优先执行
   - 可中断：shouldYield() 判断是否暂停

3. Lane 模型
   - 31 个优先级车道
   - 位运算高效合并和比较
   - TransitionLane 专门用于过渡更新
`;

// ============================================================
// Part 5: Lane 与并发更新的关系
// ============================================================

/**
 * 📊 Lane 优先级详解
 *
 * 📁 源码位置: packages/react-reconciler/src/ReactFiberLane.new.js
 */

const laneAndConcurrent = `
📊 Lane 与并发更新

┌─────────────────────────────────────────────────────────────────────────────┐
│                          Lane 优先级层级                                    │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  优先级从高到低：                                                           │
│                                                                             │
│  SyncLane                 (0b1)        │ 同步更新，不可中断                 │
│  ─────────────────────────────────────┼─────────────────────────────────────│
│  InputContinuousLane      (0b100)     │ 用户连续输入                        │
│  ─────────────────────────────────────┼─────────────────────────────────────│
│  DefaultLane              (0b10000)   │ 默认更新                           │
│  ─────────────────────────────────────┼─────────────────────────────────────│
│                                       │                                     │
│  TransitionLane1-16                   │ ⭐ 过渡更新（startTransition）      │
│  (0b1000000 ~ 0b1000000000000000000)  │ 可以被打断！                        │
│                                       │                                     │
│  ─────────────────────────────────────┼─────────────────────────────────────│
│  RetryLanes                           │ Suspense 重试                       │
│  ─────────────────────────────────────┼─────────────────────────────────────│
│  IdleLane                             │ 空闲时执行                          │
│  ─────────────────────────────────────┼─────────────────────────────────────│
│  OffscreenLane                        │ 离屏渲染                            │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

关键判断函数:

// 📁 ReactFiberLane.new.js

// 判断是否包含阻塞型 Lane（同步或用户输入）
function includesBlockingLane(root, lanes) {
  const SyncDefaultLanes = InputContinuousLane | DefaultLane;
  return (lanes & SyncDefaultLanes) !== NoLanes;
}

// 判断是否只有过渡 Lane
function includesOnlyTransitions(lanes) {
  return (lanes & TransitionLanes) === lanes;
}

// 📁 ReactFiberWorkLoop.new.js 第 877-883 行
// 决定是否使用时间切片（并发渲染）
const shouldTimeSlice =
  !includesBlockingLane(root, lanes) &&  // 不包含阻塞型 Lane
  !includesExpiredLane(root, lanes) &&   // 没有过期的 Lane
  !didTimeout;                           // 没有超时

// 如果 shouldTimeSlice = true，使用并发渲染
let exitStatus = shouldTimeSlice
  ? renderRootConcurrent(root, lanes)    // 可中断
  : renderRootSync(root, lanes);         // 不可中断
`;

// ============================================================
// Part 6: 心智模型
// ============================================================

/**
 * 📊 理解并发模式的心智模型
 */

const mentalModel = `
📊 心智模型：把 React 想象成一个餐厅厨房

┌─────────────────────────────────────────────────────────────────────────────┐
│                                                                             │
│  同步模式 = 传统厨房                                                        │
│  ─────────────────────────                                                  │
│                                                                             │
│  顾客A点餐 → 厨师开始做A的菜                                                │
│                │                                                            │
│                │ (厨师必须做完A的所有菜才能接新订单)                         │
│                ▼                                                            │
│  顾客B点餐 → 等待... 等待... 等待...                                        │
│                                                                             │
│  问题：B 等得不耐烦了！                                                     │
│                                                                             │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  并发模式 = 智能厨房                                                        │
│  ─────────────────────────                                                  │
│                                                                             │
│  顾客A点餐 → 厨师开始做A的菜（低优先级，大份）                              │
│                │                                                            │
│                │ 做一小部分...                                              │
│                ▼                                                            │
│  顾客B点餐 → 暂停A的菜！先做B的（高优先级，小份）                           │
│                │                                                            │
│                │ B的菜完成                                                  │
│                ▼                                                            │
│             继续做A的菜                                                     │
│                                                                             │
│  优势：                                                                     │
│  1. B 立即得到响应                                                          │
│  2. A 最终也会完成                                                          │
│  3. 如果A中途取消，可以立即停止（不浪费资源）                               │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

在 React 中的对应：

顾客A = startTransition(() => setSearchResults(filterData(query)))
顾客B = setInputValue(newValue)  // 用户输入

厨师 = React Reconciler + Scheduler
菜品 = Fiber 树（虚拟 DOM）
`;

// ============================================================
// Part 7: 面试要点
// ============================================================

const interviewPoints = `
💡 Phase 7 Part 1 面试要点

Q1: 什么是 React 并发模式？它解决什么问题？
A: 并发模式是 React 18 引入的渲染模式，通过可中断渲染和优先级调度，
   解决长任务阻塞用户交互的问题。核心能力：
   1. 渲染可中断：高优先级任务可以打断低优先级
   2. 时间切片：每 5ms 检查是否需要让出主线程
   3. 优先级调度：用户交互 > 普通更新 > 过渡更新

Q2: 同步模式和并发模式的区别？
A: 
   同步模式：render() 一旦开始必须完成，期间无法响应用户
   并发模式：createRoot()，渲染可暂停/恢复，始终保持响应

Q3: Transition 是什么？为什么需要它？
A: Transition 是标记为"可延迟"的更新。
   场景：搜索输入时，输入框要立即响应，但搜索结果可以稍后更新
   实现：startTransition 内的 setState 会被标记为 TransitionLane
   特点：可以被用户输入打断，不会阻塞 UI 响应

Q4: 并发模式是如何建立在 Fiber 和 Scheduler 之上的？
A: 
   - Fiber：链表结构支持暂停/恢复遍历
   - Scheduler：时间切片（5ms）+ 优先级队列
   - Lane：31 位二进制表示优先级，支持合并和比较
   三者配合：Fiber 提供可中断的结构，Scheduler 决定何时中断，
   Lane 决定执行顺序

Q5: 如何判断一次更新是否使用并发渲染？
A: 在 performConcurrentWorkOnRoot 中判断：
   shouldTimeSlice = !includesBlockingLane && !includesExpiredLane
   如果 shouldTimeSlice = true，使用 renderRootConcurrent（可中断）
   否则使用 renderRootSync（不可中断）
`;

export {
  syncRenderingProblem,
  concurrentSolution,
  keyTerminology,
  syncVsConcurrent,
  technicalFoundation,
  laneAndConcurrent,
  mentalModel,
  interviewPoints,
};

