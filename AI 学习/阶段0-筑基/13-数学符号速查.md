# ğŸ“ 13 - æ•°å­¦ç¬¦å·é€ŸæŸ¥

> AI è®ºæ–‡å’Œæ–‡æ¡£ä¸­å¸¸è§çš„æ•°å­¦ç¬¦å·ï¼Œçœ‹åˆ°ä¸å†æ‡µ

---

## ç›®å½•

1. [åŸºç¡€ç¬¦å·](#1-åŸºç¡€ç¬¦å·)
2. [å¾®ç§¯åˆ†ç¬¦å·](#2-å¾®ç§¯åˆ†ç¬¦å·)
3. [çº¿æ€§ä»£æ•°ç¬¦å·](#3-çº¿æ€§ä»£æ•°ç¬¦å·)
4. [æ¦‚ç‡ç»Ÿè®¡ç¬¦å·](#4-æ¦‚ç‡ç»Ÿè®¡ç¬¦å·)
5. [é›†åˆä¸é€»è¾‘ç¬¦å·](#5-é›†åˆä¸é€»è¾‘ç¬¦å·)
6. [æœºå™¨å­¦ä¹ å¸¸è§è¡¨ç¤º](#6-æœºå™¨å­¦ä¹ å¸¸è§è¡¨ç¤º)
7. [å¸Œè…Šå­—æ¯è¡¨](#7-å¸Œè…Šå­—æ¯è¡¨)
8. [å¸¸è§å…¬å¼é€ŸæŸ¥](#8-å¸¸è§å…¬å¼é€ŸæŸ¥)

---

## 1. åŸºç¡€ç¬¦å·

### 1.1 æ±‚å’Œä¸è¿ä¹˜

| ç¬¦å· | è¯»æ³• | å«ä¹‰ | Python |
|:----:|------|------|--------|
| âˆ‘ | sigma | æ±‚å’Œ | `sum()` |
| âˆ | pi (å¤§å†™) | è¿ä¹˜ | `math.prod()` |

```python
import numpy as np
from math import prod

# âˆ‘ æ±‚å’Œç¤ºä¾‹
# âˆ‘(i=1 to n) i = 1 + 2 + 3 + ... + n
n = 10
result = sum(range(1, n + 1))  # 55
# æˆ–è€…
result = np.sum(np.arange(1, n + 1))

# æ›´å¤æ‚çš„æ±‚å’Œ: âˆ‘(i=1 to n) iÂ²
result = sum(i**2 for i in range(1, n + 1))  # 385

# âˆ è¿ä¹˜ç¤ºä¾‹
# âˆ(i=1 to n) i = 1 Ã— 2 Ã— 3 Ã— ... Ã— n = n!
result = prod(range(1, n + 1))  # 3628800 (10!)
# æˆ–è€…
result = np.prod(np.arange(1, n + 1))
```

**AI ä¸­çš„å…¸å‹ç”¨æ³•**ï¼š

```
æŸå¤±å‡½æ•°: L = (1/n) âˆ‘(i=1 to n) â„“(yáµ¢, Å·áµ¢)
          å¹³å‡æŸå¤± = æ‰€æœ‰æ ·æœ¬æŸå¤±ä¹‹å’Œ / æ ·æœ¬æ•°

ä¼¼ç„¶å‡½æ•°: L(Î¸) = âˆ(i=1 to n) P(xáµ¢|Î¸)
          æ€»ä¼¼ç„¶ = å„æ ·æœ¬ä¼¼ç„¶çš„ä¹˜ç§¯
```

### 1.2 å±äºä¸åŒ…å«

| ç¬¦å· | è¯»æ³• | å«ä¹‰ | Python |
|:----:|------|------|--------|
| âˆˆ | å±äº | å…ƒç´ å±äºé›†åˆ | `in` |
| âˆ‰ | ä¸å±äº | å…ƒç´ ä¸å±äºé›†åˆ | `not in` |
| âŠ‚ | å­é›† | A æ˜¯ B çš„å­é›† | `A.issubset(B)` |
| âŠ† | å­é›†æˆ–ç­‰äº | A âŠ† B | `A <= B` |
| âŠƒ | è¶…é›† | A åŒ…å« B | `A.issuperset(B)` |

```python
# x âˆˆ A (x å±äº A)
A = {1, 2, 3, 4, 5}
x = 3
print(x in A)  # True

# A âŠ‚ B (A æ˜¯ B çš„å­é›†)
A = {1, 2}
B = {1, 2, 3, 4}
print(A.issubset(B))  # True
print(A < B)  # True (çœŸå­é›†)
```

### 1.3 å…¨ç§°ä¸å­˜åœ¨

| ç¬¦å· | è¯»æ³• | å«ä¹‰ | ä¾‹å­ |
|:----:|------|------|------|
| âˆ€ | ä»»æ„/å¯¹äºæ‰€æœ‰ | for all | âˆ€x âˆˆ R, xÂ² â‰¥ 0 |
| âˆƒ | å­˜åœ¨ | there exists | âˆƒx : xÂ² = 4 |
| âˆƒ! | å”¯ä¸€å­˜åœ¨ | exists unique | âˆƒ!x : x + 1 = 2 |

```python
# âˆ€x âˆˆ A, P(x) â€” å¯¹äº A ä¸­æ‰€æœ‰ xï¼ŒP(x) æˆç«‹
A = [1, 2, 3, 4, 5]
all_positive = all(x > 0 for x in A)  # True

# âˆƒx âˆˆ A, P(x) â€” å­˜åœ¨ A ä¸­çš„ x ä½¿ P(x) æˆç«‹
has_even = any(x % 2 == 0 for x in A)  # True
```

### 1.4 çº¦ç­‰ä¸æ’ç­‰

| ç¬¦å· | è¯»æ³• | å«ä¹‰ | Python |
|:----:|------|------|--------|
| = | ç­‰äº | ç›¸ç­‰ | `==` |
| â‰  | ä¸ç­‰äº | ä¸ç›¸ç­‰ | `!=` |
| â‰ˆ | çº¦ç­‰äº | è¿‘ä¼¼ç›¸ç­‰ | `np.isclose()` |
| â‰¡ | æ’ç­‰äº | å®šä¹‰ä¸º/æ€»æ˜¯ç­‰äº | - |
| := | å®šä¹‰ä¸º | å®šä¹‰ç¬¦å· | `=` |
| âˆ | æ­£æ¯”äº | æˆæ­£æ¯” | - |

```python
import numpy as np

# â‰ˆ çº¦ç­‰äºï¼ˆæµ®ç‚¹æ•°æ¯”è¾ƒï¼‰
a = 0.1 + 0.2
b = 0.3
print(a == b)           # Falseï¼ˆæµ®ç‚¹æ•°ç²¾åº¦é—®é¢˜ï¼‰
print(np.isclose(a, b)) # True

# åˆ¤æ–­ä¸¤ä¸ªæ•°ç»„è¿‘ä¼¼ç›¸ç­‰
arr1 = np.array([1.0, 2.0, 3.0])
arr2 = np.array([1.0000001, 2.0, 3.0])
print(np.allclose(arr1, arr2))  # True
```

---

## 2. å¾®ç§¯åˆ†ç¬¦å·

### 2.1 å¯¼æ•°ä¸åå¯¼

| ç¬¦å· | è¯»æ³• | å«ä¹‰ | è¯´æ˜ |
|:----:|------|------|------|
| d/dx | d dx | å¯¹ x æ±‚å¯¼ | å•å˜é‡å‡½æ•° |
| f'(x) | f prime x | f çš„å¯¼æ•° | å•å˜é‡å‡½æ•° |
| âˆ‚/âˆ‚x | partial | å¯¹ x åå¯¼ | å¤šå˜é‡å‡½æ•° |
| âˆ‚f/âˆ‚x | partial f partial x | f å¯¹ x çš„åå¯¼æ•° | å›ºå®šå…¶ä»–å˜é‡ |

```python
import numpy as np

# æ•°å€¼æ±‚å¯¼ï¼ˆè¿‘ä¼¼ï¼‰
def derivative(f, x, h=1e-7):
    """f'(x) â‰ˆ (f(x+h) - f(x-h)) / 2h"""
    return (f(x + h) - f(x - h)) / (2 * h)

# ç¤ºä¾‹: f(x) = xÂ², f'(x) = 2x
f = lambda x: x ** 2
print(derivative(f, 3))  # â‰ˆ 6.0

# åå¯¼æ•°ç¤ºä¾‹: f(x, y) = xÂ² + xy
# âˆ‚f/âˆ‚x = 2x + y
# âˆ‚f/âˆ‚y = x
def partial_x(f, x, y, h=1e-7):
    return (f(x + h, y) - f(x - h, y)) / (2 * h)

def partial_y(f, x, y, h=1e-7):
    return (f(x, y + h) - f(x, y - h)) / (2 * h)

f = lambda x, y: x**2 + x*y
print(partial_x(f, 1, 2))  # â‰ˆ 4 (2*1 + 2)
print(partial_y(f, 1, 2))  # â‰ˆ 1 (1)
```

### 2.2 æ¢¯åº¦

| ç¬¦å· | è¯»æ³• | å«ä¹‰ | Python |
|:----:|------|------|--------|
| âˆ‡ | nabla / del | æ¢¯åº¦ç®—å­ | åå¯¼å‘é‡ |
| âˆ‡f | grad f | f çš„æ¢¯åº¦ | `[âˆ‚f/âˆ‚xâ‚, âˆ‚f/âˆ‚xâ‚‚, ...]` |
| âˆ‡Â²f | nabla squared | æ‹‰æ™®æ‹‰æ–¯ç®—å­ | äºŒé˜¶å¯¼æ•°ä¹‹å’Œ |

```python
import numpy as np

# æ¢¯åº¦ = æ‰€æœ‰åå¯¼æ•°ç»„æˆçš„å‘é‡
# âˆ‡f(x, y) = [âˆ‚f/âˆ‚x, âˆ‚f/âˆ‚y]

def gradient(f, point, h=1e-7):
    """è®¡ç®—å¤šå˜é‡å‡½æ•°çš„æ¢¯åº¦"""
    n = len(point)
    grad = np.zeros(n)
    for i in range(n):
        point_plus = point.copy()
        point_minus = point.copy()
        point_plus[i] += h
        point_minus[i] -= h
        grad[i] = (f(point_plus) - f(point_minus)) / (2 * h)
    return grad

# f(x, y) = xÂ² + yÂ²
# âˆ‡f = [2x, 2y]
f = lambda p: p[0]**2 + p[1]**2
point = np.array([3.0, 4.0])
print(gradient(f, point))  # [6., 8.]
```

**AI ä¸­çš„å…¸å‹ç”¨æ³•**ï¼š

```
æ¢¯åº¦ä¸‹é™: Î¸ = Î¸ - Î±âˆ‡L(Î¸)
         å‚æ•° = å‚æ•° - å­¦ä¹ ç‡ Ã— æŸå¤±å‡½æ•°çš„æ¢¯åº¦
```

### 2.3 ç§¯åˆ†

| ç¬¦å· | è¯»æ³• | å«ä¹‰ |
|:----:|------|------|
| âˆ« | integral | ç§¯åˆ† |
| âˆ«â‚áµ‡ f(x)dx | integral from a to b | å®šç§¯åˆ† |
| âˆ¬ | double integral | äºŒé‡ç§¯åˆ† |
| âˆ® | contour integral | æ›²çº¿ç§¯åˆ† |

```python
from scipy import integrate
import numpy as np

# âˆ«â‚€Â¹ xÂ² dx = 1/3
result, error = integrate.quad(lambda x: x**2, 0, 1)
print(result)  # 0.333...

# æ•°å€¼ç§¯åˆ†ï¼ˆæ¢¯å½¢æ³•åˆ™ï¼‰
x = np.linspace(0, 1, 100)
y = x ** 2
result = np.trapz(y, x)
print(result)  # â‰ˆ 0.333
```

### 2.4 æé™

| ç¬¦å· | è¯»æ³• | å«ä¹‰ |
|:----:|------|------|
| lim | limit | æé™ |
| lim(xâ†’a) f(x) | limit as x approaches a | x è¶‹è¿‘ a æ—¶çš„æé™ |
| lim(xâ†’âˆ) | limit as x goes to infinity | x è¶‹è¿‘æ— ç©· |

```python
from sympy import Symbol, limit, oo

x = Symbol('x')

# lim(xâ†’0) sin(x)/x = 1
from sympy import sin
result = limit(sin(x)/x, x, 0)
print(result)  # 1

# lim(xâ†’âˆ) (1 + 1/x)^x = e
result = limit((1 + 1/x)**x, x, oo)
print(result)  # E (è‡ªç„¶å¸¸æ•° e)
```

---

## 3. çº¿æ€§ä»£æ•°ç¬¦å·

### 3.1 å‘é‡ä¸çŸ©é˜µè¡¨ç¤º

| ç¬¦å· | è¯»æ³• | å«ä¹‰ | è¯´æ˜ |
|:----:|------|------|------|
| **x** æˆ– xâƒ— | vector x | å‘é‡ | é€šå¸¸ç²—ä½“æˆ–å¸¦ç®­å¤´ |
| **A** | matrix A | çŸ©é˜µ | é€šå¸¸å¤§å†™ç²—ä½“ |
| xáµ¢ | x sub i | å‘é‡ç¬¬ i ä¸ªå…ƒç´  | ä¸‹æ ‡ |
| Aáµ¢â±¼ | A sub i j | çŸ©é˜µç¬¬ i è¡Œ j åˆ—å…ƒç´  | åŒä¸‹æ ‡ |
| **I** | identity matrix | å•ä½çŸ©é˜µ | `np.eye(n)` |
| **0** | zero matrix | é›¶çŸ©é˜µ | `np.zeros()` |

```python
import numpy as np

# å‘é‡
x = np.array([1, 2, 3])
print(x[0])  # xâ‚ = 1

# çŸ©é˜µ
A = np.array([[1, 2], [3, 4]])
print(A[0, 1])  # Aâ‚â‚‚ = 2

# å•ä½çŸ©é˜µ I
I = np.eye(3)
# [[1, 0, 0],
#  [0, 1, 0],
#  [0, 0, 1]]

# é›¶çŸ©é˜µ
O = np.zeros((3, 3))
```

### 3.2 çŸ©é˜µè¿ç®—

| ç¬¦å· | è¯»æ³• | å«ä¹‰ | Python |
|:----:|------|------|--------|
| AâŠ¤ æˆ– Aáµ€ | A transpose | è½¬ç½® | `A.T` |
| Aâ»Â¹ | A inverse | é€†çŸ©é˜µ | `np.linalg.inv(A)` |
| AB | A times B | çŸ©é˜µä¹˜æ³• | `A @ B` |
| AâŠ™B | A Hadamard B | é€å…ƒç´ ä¹˜ | `A * B` |
| AâŠ—B | A Kronecker B | Kronecker ç§¯ | `np.kron(A, B)` |
| det(A) | determinant | è¡Œåˆ—å¼ | `np.linalg.det(A)` |
| tr(A) | trace | è¿¹ï¼ˆå¯¹è§’çº¿å’Œï¼‰ | `np.trace(A)` |
| rank(A) | rank | ç§© | `np.linalg.matrix_rank(A)` |

```python
import numpy as np

A = np.array([[1, 2], [3, 4]])
B = np.array([[5, 6], [7, 8]])

# è½¬ç½® AâŠ¤
print(A.T)
# [[1, 3],
#  [2, 4]]

# é€†çŸ©é˜µ Aâ»Â¹
print(np.linalg.inv(A))

# çŸ©é˜µä¹˜æ³• AB
print(A @ B)  # æˆ– np.dot(A, B)

# Hadamard ä¹˜ç§¯ AâŠ™Bï¼ˆé€å…ƒç´ ä¹˜ï¼‰
print(A * B)
# [[ 5, 12],
#  [21, 32]]

# è¡Œåˆ—å¼ det(A)
print(np.linalg.det(A))  # -2.0

# è¿¹ tr(A) = Aâ‚â‚ + Aâ‚‚â‚‚ + ...
print(np.trace(A))  # 1 + 4 = 5

# ç§© rank(A)
print(np.linalg.matrix_rank(A))  # 2
```

### 3.3 èŒƒæ•°

| ç¬¦å· | è¯»æ³• | å«ä¹‰ | Python |
|:----:|------|------|--------|
| \|\|x\|\| | norm of x | å‘é‡èŒƒæ•° | `np.linalg.norm(x)` |
| \|\|x\|\|â‚ | L1 norm | L1 èŒƒæ•°ï¼ˆå…ƒç´ ç»å¯¹å€¼ä¹‹å’Œï¼‰ | `np.linalg.norm(x, 1)` |
| \|\|x\|\|â‚‚ | L2 norm | L2 èŒƒæ•°ï¼ˆæ¬§å‡ é‡Œå¾—è·ç¦»ï¼‰ | `np.linalg.norm(x, 2)` |
| \|\|x\|\|âˆ | infinity norm | æ— ç©·èŒƒæ•°ï¼ˆæœ€å¤§ç»å¯¹å€¼ï¼‰ | `np.linalg.norm(x, np.inf)` |
| \|\|A\|\|_F | Frobenius norm | Frobenius èŒƒæ•° | `np.linalg.norm(A, 'fro')` |

```python
import numpy as np

x = np.array([3, -4])

# L1 èŒƒæ•°: ||x||â‚ = |3| + |-4| = 7
print(np.linalg.norm(x, 1))  # 7.0

# L2 èŒƒæ•°: ||x||â‚‚ = âˆš(3Â² + 4Â²) = 5
print(np.linalg.norm(x, 2))  # 5.0
print(np.linalg.norm(x))     # é»˜è®¤æ˜¯ L2

# æ— ç©·èŒƒæ•°: ||x||âˆ = max(|3|, |-4|) = 4
print(np.linalg.norm(x, np.inf))  # 4.0
```

**AI ä¸­çš„å…¸å‹ç”¨æ³•**ï¼š

```
L1 æ­£åˆ™åŒ–: Î»||w||â‚  â†’ ç¨€ç–æƒé‡
L2 æ­£åˆ™åŒ–: Î»||w||â‚‚Â² â†’ é˜²æ­¢è¿‡æ‹Ÿåˆï¼ˆæƒé‡è¡°å‡ï¼‰
```

### 3.4 ç‰¹å¾å€¼ä¸ç‰¹å¾å‘é‡

| ç¬¦å· | è¯»æ³• | å«ä¹‰ |
|:----:|------|------|
| Î» | lambda | ç‰¹å¾å€¼ |
| **v** | eigenvector | ç‰¹å¾å‘é‡ |
| Av = Î»v | eigenvalue equation | ç‰¹å¾æ–¹ç¨‹ |

```python
import numpy as np

A = np.array([[4, 2], [1, 3]])

# è®¡ç®—ç‰¹å¾å€¼å’Œç‰¹å¾å‘é‡
eigenvalues, eigenvectors = np.linalg.eig(A)
print("ç‰¹å¾å€¼:", eigenvalues)      # [5., 2.]
print("ç‰¹å¾å‘é‡:\n", eigenvectors)

# éªŒè¯: Av = Î»v
v = eigenvectors[:, 0]  # ç¬¬ä¸€ä¸ªç‰¹å¾å‘é‡
Î» = eigenvalues[0]       # å¯¹åº”ç‰¹å¾å€¼
print("Av:", A @ v)
print("Î»v:", Î» * v)
# ä¸¤è€…åº”è¯¥ç›¸ç­‰
```

---

## 4. æ¦‚ç‡ç»Ÿè®¡ç¬¦å·

### 4.1 æ¦‚ç‡ç¬¦å·

| ç¬¦å· | è¯»æ³• | å«ä¹‰ | è¯´æ˜ |
|:----:|------|------|------|
| P(A) | probability of A | A çš„æ¦‚ç‡ | 0 â‰¤ P(A) â‰¤ 1 |
| P(A\|B) | probability of A given B | æ¡ä»¶æ¦‚ç‡ | åœ¨ B å‘ç”Ÿä¸‹ A çš„æ¦‚ç‡ |
| P(A, B) | joint probability | è”åˆæ¦‚ç‡ | A å’Œ B åŒæ—¶å‘ç”Ÿ |
| P(A âˆ© B) | probability of A and B | A ä¸ B | = P(A, B) |
| P(A âˆª B) | probability of A or B | A æˆ– B | P(A) + P(B) - P(Aâˆ©B) |

```python
import numpy as np

# æ¨¡æ‹Ÿæ¡ä»¶æ¦‚ç‡
# P(B|A) = P(Aâˆ©B) / P(A)

# ä¾‹: æŠ›ç¡¬å¸ï¼ŒA=ç¬¬ä¸€æ¬¡æ­£é¢ï¼ŒB=ä¸¤æ¬¡éƒ½æ­£é¢
# P(A) = 0.5
# P(Aâˆ©B) = P(ä¸¤æ¬¡éƒ½æ­£é¢) = 0.25
# P(B|A) = 0.25 / 0.5 = 0.5

# è´å¶æ–¯å…¬å¼: P(A|B) = P(B|A) * P(A) / P(B)
def bayes(p_b_given_a, p_a, p_b):
    return (p_b_given_a * p_a) / p_b

# ä¾‹: ç–¾ç—…æ£€æµ‹
# P(æœ‰ç—…) = 0.01
# P(é˜³æ€§|æœ‰ç—…) = 0.99ï¼ˆçµæ•åº¦ï¼‰
# P(é˜³æ€§|æ²¡ç—…) = 0.05ï¼ˆå‡é˜³æ€§ï¼‰
# P(é˜³æ€§) = P(é˜³æ€§|æœ‰ç—…)*P(æœ‰ç—…) + P(é˜³æ€§|æ²¡ç—…)*P(æ²¡ç—…)

p_disease = 0.01
p_positive_given_disease = 0.99
p_positive_given_no_disease = 0.05
p_positive = p_positive_given_disease * p_disease + p_positive_given_no_disease * (1 - p_disease)

p_disease_given_positive = bayes(p_positive_given_disease, p_disease, p_positive)
print(f"é˜³æ€§æ—¶æœ‰ç—…æ¦‚ç‡: {p_disease_given_positive:.2%}")  # çº¦ 16.7%
```

### 4.2 æœŸæœ›ä¸æ–¹å·®

| ç¬¦å· | è¯»æ³• | å«ä¹‰ | Python |
|:----:|------|------|--------|
| E[X] | expected value | æœŸæœ› | `np.mean(x)` |
| Î¼ | mu | å‡å€¼ | `np.mean(x)` |
| Var(X) | variance | æ–¹å·® | `np.var(x)` |
| ÏƒÂ² | sigma squared | æ–¹å·® | `np.var(x)` |
| Ïƒ | sigma | æ ‡å‡†å·® | `np.std(x)` |
| Cov(X, Y) | covariance | åæ–¹å·® | `np.cov(x, y)` |
| Corr(X, Y) | correlation | ç›¸å…³ç³»æ•° | `np.corrcoef(x, y)` |

```python
import numpy as np

x = np.array([1, 2, 3, 4, 5])

# æœŸæœ› E[X] = (1+2+3+4+5)/5 = 3
print("E[X]:", np.mean(x))  # 3.0

# æ–¹å·® Var(X) = E[(X - Î¼)Â²]
print("Var(X):", np.var(x))  # 2.0

# æ ‡å‡†å·® Ïƒ = âˆšVar(X)
print("Ïƒ:", np.std(x))  # 1.414...

# åæ–¹å·®å’Œç›¸å…³ç³»æ•°
y = np.array([2, 4, 5, 4, 5])
print("Cov:\n", np.cov(x, y))
print("Corr:\n", np.corrcoef(x, y))
```

### 4.3 åˆ†å¸ƒç¬¦å·

| ç¬¦å· | è¯»æ³• | å«ä¹‰ |
|:----:|------|------|
| X ~ N(Î¼, ÏƒÂ²) | X follows normal | X æœä»æ­£æ€åˆ†å¸ƒ |
| X ~ Bernoulli(p) | Bernoulli | ä¼¯åŠªåˆ©åˆ†å¸ƒ |
| X ~ Binomial(n, p) | Binomial | äºŒé¡¹åˆ†å¸ƒ |
| X ~ Uniform(a, b) | Uniform | å‡åŒ€åˆ†å¸ƒ |
| X ~ Poisson(Î») | Poisson | æ³Šæ¾åˆ†å¸ƒ |

```python
import numpy as np

# æ­£æ€åˆ†å¸ƒ N(Î¼, ÏƒÂ²)
samples = np.random.normal(loc=0, scale=1, size=1000)  # Î¼=0, Ïƒ=1
print(f"å‡å€¼: {samples.mean():.2f}, æ ‡å‡†å·®: {samples.std():.2f}")

# å‡åŒ€åˆ†å¸ƒ Uniform(0, 1)
samples = np.random.uniform(0, 1, 1000)

# äºŒé¡¹åˆ†å¸ƒ Binomial(n, p)
samples = np.random.binomial(n=10, p=0.5, size=1000)

# æ³Šæ¾åˆ†å¸ƒ Poisson(Î»)
samples = np.random.poisson(lam=5, size=1000)
```

---

## 5. é›†åˆä¸é€»è¾‘ç¬¦å·

### 5.1 é›†åˆè¿ç®—

| ç¬¦å· | è¯»æ³• | å«ä¹‰ | Python |
|:----:|------|------|--------|
| âˆª | union | å¹¶é›† | `A \| B` æˆ– `A.union(B)` |
| âˆ© | intersection | äº¤é›† | `A & B` |
| \ æˆ– - | set difference | å·®é›† | `A - B` |
| â–³ | symmetric difference | å¯¹ç§°å·®é›† | `A ^ B` |
| âˆ… | empty set | ç©ºé›† | `set()` |
| \|A\| | cardinality | é›†åˆå¤§å° | `len(A)` |

```python
A = {1, 2, 3, 4}
B = {3, 4, 5, 6}

print("A âˆª B:", A | B)      # {1, 2, 3, 4, 5, 6}
print("A âˆ© B:", A & B)      # {3, 4}
print("A - B:", A - B)      # {1, 2}
print("A â–³ B:", A ^ B)      # {1, 2, 5, 6}
print("|A|:", len(A))       # 4
```

### 5.2 é€»è¾‘ç¬¦å·

| ç¬¦å· | è¯»æ³• | å«ä¹‰ | Python |
|:----:|------|------|--------|
| âˆ§ | and | é€»è¾‘ä¸ | `and` |
| âˆ¨ | or | é€»è¾‘æˆ– | `or` |
| Â¬ | not | é€»è¾‘é | `not` |
| â†’ | implies | è•´å« | - |
| âŸº | iff | å½“ä¸”ä»…å½“ | - |
| âˆ´ | therefore | æ‰€ä»¥ | - |
| âˆµ | because | å› ä¸º | - |

```python
# é€»è¾‘è¿ç®—
a, b = True, False

print(a and b)  # False (âˆ§)
print(a or b)   # True (âˆ¨)
print(not a)    # False (Â¬)

# è•´å« A â†’ B ç­‰ä»·äº Â¬A âˆ¨ B
def implies(a, b):
    return (not a) or b

print(implies(True, False))   # False
print(implies(False, True))   # True
print(implies(False, False))  # True
```

---

## 6. æœºå™¨å­¦ä¹ å¸¸è§è¡¨ç¤º

### 6.1 å¸¸ç”¨å˜é‡

| ç¬¦å· | å«ä¹‰ | è¯´æ˜ |
|:----:|------|------|
| **x** | è¾“å…¥/ç‰¹å¾ | å•ä¸ªæ ·æœ¬ |
| **X** | è¾“å…¥çŸ©é˜µ | æ‰€æœ‰æ ·æœ¬ (nÃ—d) |
| **y** | æ ‡ç­¾/ç›®æ ‡ | çœŸå®å€¼ |
| **Å·** | é¢„æµ‹å€¼ | y-hat |
| **Î¸** | å‚æ•° | thetaï¼Œæ¨¡å‹å‚æ•° |
| **w** | æƒé‡ | weight |
| **b** | åç½® | bias |
| n | æ ·æœ¬æ•° | number of samples |
| d | ç‰¹å¾ç»´åº¦ | dimension |
| m | æ‰¹é‡å¤§å° | batch size |
| k | ç±»åˆ«æ•° | number of classes |

### 6.2 å¸¸ç”¨å‡½æ•°

| ç¬¦å· | å«ä¹‰ | å…¬å¼ |
|:----:|------|------|
| Ïƒ(x) | Sigmoid | 1/(1+eâ»Ë£) |
| tanh(x) | åŒæ›²æ­£åˆ‡ | (eË£-eâ»Ë£)/(eË£+eâ»Ë£) |
| ReLU(x) | çº¿æ€§æ•´æµ | max(0, x) |
| softmax(x) | å½’ä¸€åŒ–æŒ‡æ•° | eË£â±/âˆ‘eË£Ê² |

```python
import numpy as np

# Sigmoid: Ïƒ(x) = 1 / (1 + e^(-x))
def sigmoid(x):
    return 1 / (1 + np.exp(-x))

# Softmax
def softmax(x):
    exp_x = np.exp(x - np.max(x))  # æ•°å€¼ç¨³å®š
    return exp_x / np.sum(exp_x)

# ReLU
def relu(x):
    return np.maximum(0, x)

# ç¤ºä¾‹
x = np.array([1.0, 2.0, 3.0])
print("sigmoid:", sigmoid(x))
print("softmax:", softmax(x))
print("relu:", relu(np.array([-1, 0, 1, 2])))
```

### 6.3 æŸå¤±å‡½æ•°

| ç¬¦å· | å«ä¹‰ | å…¬å¼ |
|:----:|------|------|
| MSE | å‡æ–¹è¯¯å·® | (1/n)âˆ‘(y-Å·)Â² |
| MAE | å¹³å‡ç»å¯¹è¯¯å·® | (1/n)âˆ‘\|y-Å·\| |
| CE | äº¤å‰ç†µ | -âˆ‘yÂ·log(Å·) |
| BCE | äºŒå…ƒäº¤å‰ç†µ | -yÂ·log(Å·)-(1-y)Â·log(1-Å·) |

```python
import numpy as np

def mse(y_true, y_pred):
    """å‡æ–¹è¯¯å·®"""
    return np.mean((y_true - y_pred) ** 2)

def mae(y_true, y_pred):
    """å¹³å‡ç»å¯¹è¯¯å·®"""
    return np.mean(np.abs(y_true - y_pred))

def cross_entropy(y_true, y_pred):
    """äº¤å‰ç†µï¼ˆå¤šåˆ†ç±»ï¼‰"""
    return -np.sum(y_true * np.log(y_pred + 1e-15))

def binary_cross_entropy(y_true, y_pred):
    """äºŒå…ƒäº¤å‰ç†µ"""
    return -np.mean(
        y_true * np.log(y_pred + 1e-15) +
        (1 - y_true) * np.log(1 - y_pred + 1e-15)
    )
```

### 6.4 ä¼˜åŒ–ç›¸å…³

| ç¬¦å· | å«ä¹‰ | è¯´æ˜ |
|:----:|------|------|
| Î± æˆ– Î· | å­¦ä¹ ç‡ | learning rate |
| Î» | æ­£åˆ™åŒ–ç³»æ•° | regularization |
| Îµ | å°å¸¸æ•° | é˜²æ­¢é™¤é›¶ |
| Î² | åŠ¨é‡ç³»æ•° | momentum |
| argmin | å–æœ€å°å€¼çš„å‚æ•° | - |
| argmax | å–æœ€å¤§å€¼çš„å‚æ•° | - |

```python
import numpy as np

# argmin å’Œ argmax
x = np.array([3, 1, 4, 1, 5, 9, 2, 6])
print("argmin:", np.argmin(x))  # 1ï¼ˆæœ€å°å€¼çš„ç´¢å¼•ï¼‰
print("argmax:", np.argmax(x))  # 5ï¼ˆæœ€å¤§å€¼çš„ç´¢å¼•ï¼‰

# æ¢¯åº¦ä¸‹é™
# Î¸ := Î¸ - Î±âˆ‡L(Î¸)
def gradient_descent(gradient_fn, initial_theta, learning_rate=0.01, iterations=100):
    theta = initial_theta
    for _ in range(iterations):
        grad = gradient_fn(theta)
        theta = theta - learning_rate * grad
    return theta
```

---

## 7. å¸Œè…Šå­—æ¯è¡¨

### å¸¸ç”¨å¸Œè…Šå­—æ¯

| å¤§å†™ | å°å†™ | åç§° | å¸¸è§ç”¨é€” |
|:----:|:----:|------|---------|
| A | Î± | alpha | å­¦ä¹ ç‡ã€æ˜¾è‘—æ€§æ°´å¹³ |
| B | Î² | beta | åŠ¨é‡ç³»æ•°ã€å›å½’ç³»æ•° |
| Î“ | Î³ | gamma | æŠ˜æ‰£å› å­ï¼ˆå¼ºåŒ–å­¦ä¹ ï¼‰ |
| Î” | Î´ | delta | å˜åŒ–é‡ã€è¯¯å·® |
| E | Îµ | epsilon | å°å¸¸æ•°ã€æ¢ç´¢ç‡ |
| Z | Î¶ | zeta | - |
| H | Î· | eta | å­¦ä¹ ç‡ |
| Î˜ | Î¸ | theta | æ¨¡å‹å‚æ•° |
| I | Î¹ | iota | - |
| K | Îº | kappa | - |
| Î› | Î» | lambda | æ­£åˆ™åŒ–ç³»æ•°ã€ç‰¹å¾å€¼ |
| M | Î¼ | mu | å‡å€¼ |
| N | Î½ | nu | - |
| Î | Î¾ | xi | - |
| O | Î¿ | omicron | - |
| Î  | Ï€ | pi | åœ†å‘¨ç‡ã€ç­–ç•¥ï¼ˆå¼ºåŒ–å­¦ä¹ ï¼‰ |
| P | Ï | rho | ç›¸å…³ç³»æ•° |
| Î£ | Ïƒ | sigma | æ ‡å‡†å·®ã€æ±‚å’Œã€Sigmoid |
| T | Ï„ | tau | æ¸©åº¦å‚æ•°ã€æ—¶é—´å¸¸æ•° |
| Î¥ | Ï… | upsilon | - |
| Î¦ | Ï† | phi | ç‰¹å¾æ˜ å°„ã€æ­£æ€åˆ†å¸ƒ CDF |
| X | Ï‡ | chi | å¡æ–¹åˆ†å¸ƒ |
| Î¨ | Ïˆ | psi | - |
| Î© | Ï‰ | omega | é¢‘ç‡ã€æƒé‡ |

---

## 8. å¸¸è§å…¬å¼é€ŸæŸ¥

### 8.1 çº¿æ€§å›å½’

```
æ¨¡å‹: Å· = Xw + b = XÎ¸

æŸå¤±: L(Î¸) = (1/2n)||y - XÎ¸||Â²â‚‚

æ¢¯åº¦: âˆ‡L = (1/n)XâŠ¤(XÎ¸ - y)

é—­å¼è§£: Î¸* = (XâŠ¤X)â»Â¹XâŠ¤y
```

### 8.2 é€»è¾‘å›å½’

```
æ¨¡å‹: P(y=1|x) = Ïƒ(wâŠ¤x + b)

æŸå¤±: L = -âˆ‘[yÂ·log(Å·) + (1-y)Â·log(1-Å·)]
```

### 8.3 Softmax åˆ†ç±»

```
Softmax: P(y=k|x) = exp(zâ‚–) / âˆ‘exp(zâ±¼)

äº¤å‰ç†µ: L = -âˆ‘yâ‚–Â·log(P(y=k|x))
```

### 8.4 ç¥ç»ç½‘ç»œ

```
å‰å‘ä¼ æ’­:
  zâ½Ë¡â¾ = Wâ½Ë¡â¾aâ½Ë¡â»Â¹â¾ + bâ½Ë¡â¾
  aâ½Ë¡â¾ = Ïƒ(zâ½Ë¡â¾)

åå‘ä¼ æ’­:
  Î´â½Ë¡â¾ = (Wâ½Ë¡âºÂ¹â¾)âŠ¤Î´â½Ë¡âºÂ¹â¾ âŠ™ Ïƒ'(zâ½Ë¡â¾)
  âˆ‚L/âˆ‚Wâ½Ë¡â¾ = Î´â½Ë¡â¾(aâ½Ë¡â»Â¹â¾)âŠ¤
```

### 8.5 æ³¨æ„åŠ›æœºåˆ¶

```
Attention(Q, K, V) = softmax(QKâŠ¤/âˆšdâ‚–)V

Q = XWQ, K = XWK, V = XWV
```

---

## ğŸ“š æ¨èèµ„æº

- [3Blue1Brown çº¿æ€§ä»£æ•°](https://www.bilibili.com/video/BV1ys411472E) - å¯è§†åŒ–ç†è§£
- [Khan Academy æ¦‚ç‡ç»Ÿè®¡](https://www.khanacademy.org/) - åŸºç¡€æ¦‚å¿µ
- [Seeing Theory](https://seeing-theory.brown.edu/) - æ¦‚ç‡å¯è§†åŒ–

---

## â¡ï¸ ä¸‹ä¸€æ­¥

å­¦å®Œæœ¬èŠ‚åï¼Œç»§ç»­å­¦ä¹  [14-çº¿æ€§ä»£æ•°è¿›é˜¶.md](./14-çº¿æ€§ä»£æ•°è¿›é˜¶.md)

