# ğŸ” è®¤è¯ä¸é™æµ

> API Keyã€JWT è®¤è¯ä¸è¯·æ±‚é™æµ

---

## API Key è®¤è¯

### ç®€å•å®ç°

```python
from fastapi import FastAPI, HTTPException, Header, Depends
from typing import Optional

app = FastAPI()

# API Keysï¼ˆç”Ÿäº§ç¯å¢ƒåº”å­˜åœ¨æ•°æ®åº“æˆ–é…ç½®æœåŠ¡ï¼‰
VALID_API_KEYS = {
    "sk-test-123456": {"user": "test_user", "tier": "free"},
    "sk-prod-abcdef": {"user": "prod_user", "tier": "pro"},
}

async def verify_api_key(
    authorization: Optional[str] = Header(None),
    x_api_key: Optional[str] = Header(None)
):
    """éªŒè¯ API Key"""
    # æ”¯æŒä¸¤ç§æ–¹å¼ä¼ é€’
    # 1. Authorization: Bearer sk-xxx
    # 2. X-API-Key: sk-xxx

    api_key = None

    if authorization and authorization.startswith("Bearer "):
        api_key = authorization[7:]
    elif x_api_key:
        api_key = x_api_key

    if not api_key:
        raise HTTPException(
            status_code=401,
            detail="Missing API key"
        )

    if api_key not in VALID_API_KEYS:
        raise HTTPException(
            status_code=401,
            detail="Invalid API key"
        )

    return VALID_API_KEYS[api_key]

@app.post("/v1/chat/completions")
async def chat_completions(
    request: dict,
    user_info: dict = Depends(verify_api_key)
):
    """éœ€è¦è®¤è¯çš„ç«¯ç‚¹"""
    # user_info åŒ…å«ç”¨æˆ·ä¿¡æ¯
    print(f"Request from: {user_info['user']}")
    return {"message": "success"}
```

### åŸºäºæ•°æ®åº“çš„ API Key

```python
from fastapi import FastAPI, HTTPException, Depends
from sqlalchemy import create_engine, Column, String, Boolean, DateTime
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker, Session
import secrets
from datetime import datetime

Base = declarative_base()

class APIKey(Base):
    __tablename__ = "api_keys"

    key = Column(String, primary_key=True)
    user_id = Column(String, nullable=False)
    name = Column(String)
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    last_used_at = Column(DateTime)

# æ•°æ®åº“è¿æ¥
engine = create_engine("sqlite:///./api_keys.db")
SessionLocal = sessionmaker(bind=engine)
Base.metadata.create_all(bind=engine)

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

async def verify_api_key_db(
    authorization: str = Header(...),
    db: Session = Depends(get_db)
):
    """ä»æ•°æ®åº“éªŒè¯ API Key"""
    if not authorization.startswith("Bearer "):
        raise HTTPException(status_code=401, detail="Invalid authorization format")

    api_key = authorization[7:]

    key_record = db.query(APIKey).filter(
        APIKey.key == api_key,
        APIKey.is_active == True
    ).first()

    if not key_record:
        raise HTTPException(status_code=401, detail="Invalid API key")

    # æ›´æ–°æœ€åä½¿ç”¨æ—¶é—´
    key_record.last_used_at = datetime.utcnow()
    db.commit()

    return key_record

# ç”Ÿæˆ API Key
def generate_api_key() -> str:
    return f"sk-{secrets.token_urlsafe(32)}"
```

---

## JWT è®¤è¯

### JWT å®ç°

```python
from fastapi import FastAPI, HTTPException, Depends
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from jose import JWTError, jwt
from passlib.context import CryptContext
from datetime import datetime, timedelta
from pydantic import BaseModel

app = FastAPI()

# é…ç½®
SECRET_KEY = "your-secret-key-keep-it-safe"
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30

# å¯†ç å“ˆå¸Œ
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

# Bearer token
security = HTTPBearer()

class Token(BaseModel):
    access_token: str
    token_type: str

class TokenData(BaseModel):
    username: str
    exp: datetime

class User(BaseModel):
    username: str
    email: str
    disabled: bool = False

# æ¨¡æ‹Ÿç”¨æˆ·æ•°æ®åº“
fake_users_db = {
    "admin": {
        "username": "admin",
        "email": "admin@example.com",
        "hashed_password": pwd_context.hash("admin123"),
        "disabled": False,
    }
}

def verify_password(plain_password: str, hashed_password: str) -> bool:
    return pwd_context.verify(plain_password, hashed_password)

def create_access_token(data: dict, expires_delta: timedelta = None) -> str:
    to_encode = data.copy()
    expire = datetime.utcnow() + (expires_delta or timedelta(minutes=15))
    to_encode.update({"exp": expire})
    return jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)

async def get_current_user(
    credentials: HTTPAuthorizationCredentials = Depends(security)
) -> User:
    """ä» JWT è·å–å½“å‰ç”¨æˆ·"""
    token = credentials.credentials

    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        username: str = payload.get("sub")
        if username is None:
            raise HTTPException(status_code=401, detail="Invalid token")
    except JWTError:
        raise HTTPException(status_code=401, detail="Invalid token")

    user_data = fake_users_db.get(username)
    if user_data is None:
        raise HTTPException(status_code=401, detail="User not found")

    return User(**user_data)

# ç™»å½•ç«¯ç‚¹
@app.post("/token", response_model=Token)
async def login(username: str, password: str):
    user = fake_users_db.get(username)
    if not user or not verify_password(password, user["hashed_password"]):
        raise HTTPException(status_code=401, detail="Incorrect username or password")

    access_token = create_access_token(
        data={"sub": username},
        expires_delta=timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    )
    return {"access_token": access_token, "token_type": "bearer"}

# å—ä¿æŠ¤çš„ç«¯ç‚¹
@app.get("/users/me")
async def read_users_me(current_user: User = Depends(get_current_user)):
    return current_user
```

---

## è¯·æ±‚é™æµ

### ç®€å•é™æµï¼ˆå†…å­˜ï¼‰

```python
from fastapi import FastAPI, HTTPException, Request
from collections import defaultdict
import time

app = FastAPI()

# é™æµé…ç½®
RATE_LIMIT = 10  # æ¯åˆ†é’Ÿè¯·æ±‚æ•°
RATE_WINDOW = 60  # æ—¶é—´çª—å£ï¼ˆç§’ï¼‰

# å­˜å‚¨è¯·æ±‚è®°å½•
request_counts = defaultdict(list)

def rate_limit(request: Request):
    """ç®€å•é™æµä¸­é—´ä»¶"""
    client_ip = request.client.host
    current_time = time.time()

    # æ¸…ç†è¿‡æœŸè®°å½•
    request_counts[client_ip] = [
        t for t in request_counts[client_ip]
        if current_time - t < RATE_WINDOW
    ]

    # æ£€æŸ¥é™æµ
    if len(request_counts[client_ip]) >= RATE_LIMIT:
        raise HTTPException(
            status_code=429,
            detail="Rate limit exceeded. Please try again later."
        )

    # è®°å½•è¯·æ±‚
    request_counts[client_ip].append(current_time)

@app.middleware("http")
async def rate_limit_middleware(request: Request, call_next):
    # åªå¯¹ç‰¹å®šç«¯ç‚¹é™æµ
    if request.url.path.startswith("/v1/"):
        rate_limit(request)
    return await call_next(request)
```

### ä»¤ç‰Œæ¡¶ç®—æ³•

```python
import asyncio
from dataclasses import dataclass
from typing import Dict
import time

@dataclass
class TokenBucket:
    capacity: int  # æ¡¶å®¹é‡
    rate: float    # å¡«å……é€Ÿç‡ï¼ˆtoken/ç§’ï¼‰
    tokens: float  # å½“å‰ token æ•°
    last_update: float  # ä¸Šæ¬¡æ›´æ–°æ—¶é—´

class RateLimiter:
    def __init__(self, capacity: int = 10, rate: float = 1.0):
        self.capacity = capacity
        self.rate = rate
        self.buckets: Dict[str, TokenBucket] = {}
        self._lock = asyncio.Lock()

    async def acquire(self, key: str) -> bool:
        """å°è¯•è·å–ä¸€ä¸ª token"""
        async with self._lock:
            now = time.time()

            if key not in self.buckets:
                self.buckets[key] = TokenBucket(
                    capacity=self.capacity,
                    rate=self.rate,
                    tokens=self.capacity,
                    last_update=now
                )

            bucket = self.buckets[key]

            # å¡«å…… token
            elapsed = now - bucket.last_update
            bucket.tokens = min(
                bucket.capacity,
                bucket.tokens + elapsed * bucket.rate
            )
            bucket.last_update = now

            # å°è¯•æ¶ˆè€—
            if bucket.tokens >= 1:
                bucket.tokens -= 1
                return True

            return False

# ä½¿ç”¨
limiter = RateLimiter(capacity=10, rate=0.5)  # 10 ä¸ªå®¹é‡ï¼Œæ¯ 2 ç§’æ¢å¤ 1 ä¸ª

@app.post("/v1/chat/completions")
async def chat_completions(request: Request):
    client_ip = request.client.host

    if not await limiter.acquire(client_ip):
        raise HTTPException(status_code=429, detail="Rate limit exceeded")

    # å¤„ç†è¯·æ±‚...
```

### ä½¿ç”¨ SlowAPI

```python
from fastapi import FastAPI, Request
from slowapi import Limiter, _rate_limit_exceeded_handler
from slowapi.util import get_remote_address
from slowapi.errors import RateLimitExceeded

limiter = Limiter(key_func=get_remote_address)
app = FastAPI()
app.state.limiter = limiter
app.add_exception_handler(RateLimitExceeded, _rate_limit_exceeded_handler)

@app.post("/v1/chat/completions")
@limiter.limit("10/minute")  # æ¯åˆ†é’Ÿ 10 æ¬¡
async def chat_completions(request: Request):
    return {"message": "success"}

@app.post("/v1/embeddings")
@limiter.limit("100/minute")  # æ¯åˆ†é’Ÿ 100 æ¬¡
async def embeddings(request: Request):
    return {"message": "success"}
```

### åŸºäºç”¨æˆ·ç­‰çº§çš„é™æµ

```python
from fastapi import Depends

# ä¸åŒç­‰çº§çš„é™æµé…ç½®
TIER_LIMITS = {
    "free": {"rpm": 10, "tpm": 1000},      # æ¯åˆ†é’Ÿ 10 è¯·æ±‚ï¼Œ1000 token
    "pro": {"rpm": 100, "tpm": 100000},    # æ¯åˆ†é’Ÿ 100 è¯·æ±‚ï¼Œ10 ä¸‡ token
    "enterprise": {"rpm": 1000, "tpm": 1000000}
}

class TierRateLimiter:
    def __init__(self):
        self.request_counts = defaultdict(list)
        self.token_counts = defaultdict(int)

    async def check(self, user_id: str, tier: str, tokens: int = 0) -> bool:
        limits = TIER_LIMITS.get(tier, TIER_LIMITS["free"])
        current_time = time.time()

        # æ¸…ç†è¿‡æœŸè®°å½•
        minute_ago = current_time - 60
        self.request_counts[user_id] = [
            t for t in self.request_counts[user_id] if t > minute_ago
        ]

        # æ£€æŸ¥ RPM
        if len(self.request_counts[user_id]) >= limits["rpm"]:
            return False

        # è®°å½•
        self.request_counts[user_id].append(current_time)
        return True

tier_limiter = TierRateLimiter()

@app.post("/v1/chat/completions")
async def chat_completions(
    request: ChatRequest,
    user_info: dict = Depends(verify_api_key)
):
    if not await tier_limiter.check(user_info["user"], user_info["tier"]):
        raise HTTPException(status_code=429, detail="Rate limit exceeded")

    # å¤„ç†è¯·æ±‚...
```

---

## å¹¶å‘æ§åˆ¶

```python
import asyncio

# å…¨å±€å¹¶å‘é™åˆ¶
MAX_CONCURRENT_REQUESTS = 50
semaphore = asyncio.Semaphore(MAX_CONCURRENT_REQUESTS)

@app.post("/v1/chat/completions")
async def chat_completions(request: ChatRequest):
    async with semaphore:
        # åŒæ—¶æœ€å¤š 50 ä¸ªè¯·æ±‚
        return await process_request(request)

# å¸¦è¶…æ—¶çš„å¹¶å‘æ§åˆ¶
async def chat_with_timeout(request: ChatRequest):
    try:
        async with asyncio.timeout(30):  # 30 ç§’è¶…æ—¶
            async with semaphore:
                return await process_request(request)
    except asyncio.TimeoutError:
        raise HTTPException(status_code=504, detail="Request timeout")
```

---

## å®Œæ•´ç¤ºä¾‹

```python
"""å¸¦è®¤è¯å’Œé™æµçš„å®Œæ•´ API"""
from fastapi import FastAPI, HTTPException, Depends, Request, Header
from slowapi import Limiter
from slowapi.util import get_remote_address
import asyncio

app = FastAPI()

# é™æµå™¨
limiter = Limiter(key_func=get_remote_address)
app.state.limiter = limiter

# å¹¶å‘æ§åˆ¶
semaphore = asyncio.Semaphore(50)

# API Key éªŒè¯
async def verify_api_key(authorization: str = Header(...)):
    if not authorization.startswith("Bearer "):
        raise HTTPException(status_code=401, detail="Invalid format")
    # éªŒè¯é€»è¾‘...
    return {"user": "test", "tier": "pro"}

@app.post("/v1/chat/completions")
@limiter.limit("60/minute")
async def chat_completions(
    request: Request,
    user_info: dict = Depends(verify_api_key)
):
    async with semaphore:
        # å¤„ç†è¯·æ±‚
        return {"message": "success"}
```

---

## â¡ï¸ ä¸‹ä¸€æ­¥

ç»§ç»­ [08-Dockeréƒ¨ç½².md](./08-Dockeréƒ¨ç½².md)

