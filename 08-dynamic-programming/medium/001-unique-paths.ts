/**
 * 📝 题目：不同路径
 * 🔗 链接：https://leetcode.cn/problems/unique-paths/
 * 🏷️ 难度：Medium
 * 🏷️ 标签：数学、动态规划、组合数学
 *
 * 📋 题目描述：
 * 一个机器人位于一个 m x n 网格的左上角。
 * 机器人每次只能向下或者向右移动一步。
 * 机器人试图达到网格的右下角。
 *
 * 问总共有多少条不同的路径？
 *
 * 示例：
 * 输入：m = 3, n = 7
 * 输出：28
 *
 * 输入：m = 3, n = 2
 * 输出：3
 */

// ============================================================
// 💡 思路分析：这道题的解法是怎么想出来的？
// ============================================================
//
// dp[i][j] = 到达 (i, j) 的路径数
//
// 到达 (i, j) 只能从：
// - 上方 (i-1, j) 向下走
// - 左方 (i, j-1) 向右走
//
// 状态转移：dp[i][j] = dp[i-1][j] + dp[i][j-1]
//
// 初始条件：
// - 第一行只能从左边来：dp[0][j] = 1
// - 第一列只能从上边来：dp[i][0] = 1

// ============================================================
// 解法一：二维 DP
// ============================================================
// ⏱️ 时间复杂度：O(m×n) | 空间复杂度：O(m×n)

/**
 * 📊 执行过程图解：
 *
 * m = 3, n = 3
 *
 * ┌───┬───┬───┐
 * │ 1 │ 1 │ 1 │  第一行只能从左边来
 * ├───┼───┼───┤
 * │ 1 │ 2 │ 3 │  dp[1][1] = 1+1 = 2
 * ├───┼───┼───┤
 * │ 1 │ 3 │ 6 │  dp[2][2] = 3+3 = 6
 * └───┴───┴───┘
 *
 * 答案：6
 */
function uniquePaths(m: number, n: number): number {
  // dp[i][j] = 到达 (i, j) 的路径数
  const dp: number[][] = Array.from({ length: m }, () => Array(n).fill(0));

  // 初始化第一行和第一列
  for (let i = 0; i < m; i++) dp[i][0] = 1;
  for (let j = 0; j < n; j++) dp[0][j] = 1;

  // 填表
  for (let i = 1; i < m; i++) {
    for (let j = 1; j < n; j++) {
      dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
    }
  }

  return dp[m - 1][n - 1];
}

// ============================================================
// 解法二：一维 DP（空间优化）
// ============================================================
// ⏱️ 时间复杂度：O(m×n) | 空间复杂度：O(n)
function uniquePaths_optimized(m: number, n: number): number {
  const dp: number[] = Array(n).fill(1);

  for (let i = 1; i < m; i++) {
    for (let j = 1; j < n; j++) {
      // dp[j] 左边是上一行的 dp[j]，dp[j-1] 是当前行的左边
      dp[j] = dp[j] + dp[j - 1];
    }
  }

  return dp[n - 1];
}

// ============================================================
// 解法三：数学（组合数）
// ============================================================
// ⏱️ 时间复杂度：O(m) | 空间复杂度：O(1)

/**
 * 数学思路：
 * 总共需要走 m-1 步向下 + n-1 步向右 = m+n-2 步
 * 从中选择 m-1 步向下（或 n-1 步向右）
 * 答案 = C(m+n-2, m-1)
 */
function uniquePaths_math(m: number, n: number): number {
  // C(m+n-2, m-1) = (m+n-2)! / ((m-1)! * (n-1)!)
  let result = 1;
  for (let i = 0; i < Math.min(m - 1, n - 1); i++) {
    result = (result * (m + n - 2 - i)) / (i + 1);
  }
  return Math.round(result);
}

// ============================================================
// 🔄 解法对比
// ============================================================
/**
 * | 解法   | 时间    | 空间    | 特点              |
 * |--------|---------|---------|-------------------|
 * | 二维DP | O(m×n)  | O(m×n)  | 好理解            |
 * | 一维DP | O(m×n)  | O(n)    | 空间优化          |
 * | 数学   | O(min)  | O(1)    | 最优，但需数学背景 |
 */

// ============================================================
// ⚠️ 易错点
// ============================================================
/**
 * 1. 边界初始化：第一行和第一列都是 1
 *
 * 2. 空间优化时：
 *    - dp[j] 原值是上一行的
 *    - dp[j-1] 是当前行的
 *    - 这是因为从左到右遍历
 *
 * 3. 数学方法的精度：用浮点数可能有误差，最后要 round
 */

// ============================================================
// 🔗 举一反三：相似题目
// ============================================================
/**
 * - 不同路径 II → 有障碍物
 * - 最小路径和 → 求最小代价
 * - 三角形最小路径和 → 三角形结构
 */

// ============================================================
// 🏢 前端业务场景
// ============================================================
/**
 * 1. 布局计算：网格布局的路径数
 * 2. 游戏开发：棋盘游戏的走法
 */

export { uniquePaths, uniquePaths_optimized, uniquePaths_math };
export default uniquePaths;

