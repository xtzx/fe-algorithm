/**
 * 📝 题目：打家劫舍 II
 * 🔗 链接：https://leetcode.cn/problems/house-robber-ii/
 * 🏷️ 难度：Medium
 * 🏷️ 标签：数组、动态规划
 *
 * 📋 题目描述：
 * 你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。
 * 这个地方所有的房屋都 围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。
 * 同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，
 * 系统会自动报警。
 *
 * 给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，
 * 今晚能够偷窃到的最高金额。
 *
 * 示例：
 * 输入：nums = [2,3,2]
 * 输出：3
 * 解释：不能先偷 nums[0] 再偷 nums[2]，因为它们是相邻的。
 *
 * 输入：nums = [1,2,3,1]
 * 输出：4
 * 解释：偷 nums[0] 和 nums[2]，总金额 1 + 3 = 4
 */

// ============================================================
// 💡 思路分析：这道题的解法是怎么想出来的？
// ============================================================
//
// 与打家劫舍 I 的区别：房屋成环
// 第一个和最后一个不能同时偷
//
// 解决方案：分两种情况
// 1. 不偷第一个：考虑 nums[1..n-1]
// 2. 不偷最后一个：考虑 nums[0..n-2]
// 取两种情况的最大值

// ============================================================
// 解法：分情况 + 打家劫舍 I
// ============================================================
// ⏱️ 时间复杂度：O(n) | 空间复杂度：O(1)

/**
 * 📊 执行过程图解：
 *
 * nums = [1, 2, 3, 1]
 *
 * 情况1：不偷第一个，考虑 [2, 3, 1]
 *   结果：max(2+1, 3) = 3
 *
 * 情况2：不偷最后一个，考虑 [1, 2, 3]
 *   结果：max(1+3, 2) = 4
 *
 * 答案：max(3, 4) = 4
 */
function rob(nums: number[]): number {
  const n = nums.length;
  if (n === 0) return 0;
  if (n === 1) return nums[0];
  if (n === 2) return Math.max(nums[0], nums[1]);

  // 情况1：不偷第一个 [1, n-1]
  const result1 = robRange(nums, 1, n - 1);
  // 情况2：不偷最后一个 [0, n-2]
  const result2 = robRange(nums, 0, n - 2);

  return Math.max(result1, result2);
}

// 打家劫舍 I：在 [start, end] 范围内偷
function robRange(nums: number[], start: number, end: number): number {
  let prev2 = 0;
  let prev1 = 0;

  for (let i = start; i <= end; i++) {
    const curr = Math.max(prev2 + nums[i], prev1);
    prev2 = prev1;
    prev1 = curr;
  }

  return prev1;
}

// ============================================================
// 解法二：更清晰的写法
// ============================================================
function rob_v2(nums: number[]): number {
  const n = nums.length;
  if (n === 1) return nums[0];

  return Math.max(
    robLinear(nums.slice(0, n - 1)), // 不偷最后一个
    robLinear(nums.slice(1)) // 不偷第一个
  );
}

function robLinear(nums: number[]): number {
  let prev2 = 0;
  let prev1 = 0;

  for (const num of nums) {
    const curr = Math.max(prev2 + num, prev1);
    prev2 = prev1;
    prev1 = curr;
  }

  return prev1;
}

// ============================================================
// ⚠️ 易错点
// ============================================================
/**
 * 1. 边界处理：
 *    - n = 1 时直接返回 nums[0]
 *    - n = 2 时返回 max(nums[0], nums[1])
 *
 * 2. 分情况时：
 *    - 不是"偷第一个"和"偷最后一个"
 *    - 而是"不偷第一个"和"不偷最后一个"
 *
 * 3. 范围注意：
 *    - [1, n-1] 和 [0, n-2] 都不包含两端
 */

// ============================================================
// 🔗 举一反三：相似题目
// ============================================================
/**
 * - 打家劫舍 → 不成环
 * - 打家劫舍 III → 树形结构
 */

export { rob, rob_v2 };
export default rob;

