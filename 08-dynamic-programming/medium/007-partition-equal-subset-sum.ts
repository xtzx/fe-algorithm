/**
 * 📝 题目：分割等和子集
 * 🔗 链接：https://leetcode.cn/problems/partition-equal-subset-sum/
 * 🏷️ 难度：Medium
 * 🏷️ 标签：数组、动态规划
 *
 * 📋 题目描述：
 * 给你一个 只包含正整数 的 非空 数组 nums。
 * 请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。
 *
 * 示例：
 * 输入：nums = [1,5,11,5]
 * 输出：true
 * 解释：数组可以分割成 [1, 5, 5] 和 [11]
 *
 * 输入：nums = [1,2,3,5]
 * 输出：false
 */

// ============================================================
// 💡 思路分析：这道题的解法是怎么想出来的？
// ============================================================
//
// 问题转化：
// - 能否分成两个和相等的子集
// - ⟺ 能否从数组中选出一些数，使得和 = total / 2
// - ⟺ 0-1 背包问题！
//
// dp[i][j] = 前 i 个数能否凑出和为 j
// 或优化为一维：dp[j] = 能否凑出和为 j

// ============================================================
// 解法一：0-1 背包
// ============================================================
// ⏱️ 时间复杂度：O(n × target) | 空间复杂度：O(target)

/**
 * 📊 执行过程图解：
 *
 * nums = [1, 5, 11, 5]
 * total = 22, target = 11
 *
 * 初始: dp = [T, F, F, F, F, F, F, F, F, F, F, F]
 *             0  1  2  3  4  5  6  7  8  9  10 11
 *
 * 处理 1:  dp = [T, T, F, F, F, F, F, F, F, F, F, F]
 * 处理 5:  dp = [T, T, F, F, F, T, T, F, F, F, F, F]
 * 处理 11: dp = [T, T, F, F, F, T, T, F, F, F, F, T]
 * 处理 5:  dp = [T, T, F, F, F, T, T, F, F, F, T, T]
 *
 * 答案：dp[11] = true
 */
function canPartition(nums: number[]): boolean {
  const total = nums.reduce((a, b) => a + b, 0);

  // 奇数不可能分成两个相等的整数和
  if (total % 2 !== 0) return false;

  const target = total / 2;

  // dp[j] = 能否凑出和为 j
  const dp: boolean[] = Array(target + 1).fill(false);
  dp[0] = true;

  for (const num of nums) {
    // 0-1 背包：从后往前遍历
    for (let j = target; j >= num; j--) {
      dp[j] = dp[j] || dp[j - num];
    }
  }

  return dp[target];
}

// ============================================================
// 解法二：二维 DP（更清晰）
// ============================================================
function canPartition_2d(nums: number[]): boolean {
  const total = nums.reduce((a, b) => a + b, 0);
  if (total % 2 !== 0) return false;

  const n = nums.length;
  const target = total / 2;

  // dp[i][j] = 前 i 个数能否凑出和为 j
  const dp: boolean[][] = Array.from({ length: n + 1 }, () =>
    Array(target + 1).fill(false)
  );

  // 凑出和为 0 总是可以（什么都不选）
  for (let i = 0; i <= n; i++) {
    dp[i][0] = true;
  }

  for (let i = 1; i <= n; i++) {
    for (let j = 1; j <= target; j++) {
      if (nums[i - 1] > j) {
        // 当前数太大，不能选
        dp[i][j] = dp[i - 1][j];
      } else {
        // 选或不选
        dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i - 1]];
      }
    }
  }

  return dp[n][target];
}

// ============================================================
// 🔄 解法对比
// ============================================================
/**
 * | 解法   | 时间         | 空间       | 特点          |
 * |--------|--------------|------------|---------------|
 * | 一维DP | O(n × target)| O(target)  | 推荐          |
 * | 二维DP | O(n × target)| O(n × target)| 更好理解   |
 */

// ============================================================
// ⚠️ 易错点
// ============================================================
/**
 * 1. 奇数判断：
 *    - total 是奇数时直接返回 false
 *
 * 2. 0-1 背包遍历顺序：
 *    - 必须从后往前（避免同一物品被选多次）
 *
 * 3. 初始值：
 *    - dp[0] = true（凑出 0 不需要选任何数）
 */

// ============================================================
// 🔗 举一反三：相似题目
// ============================================================
/**
 * - 目标和 → 转化为背包问题
 * - 最后一块石头的重量 II → 类似思路
 * - 一和零 → 二维 0-1 背包
 */

// ============================================================
// 🏢 前端业务场景
// ============================================================
/**
 * 1. 任务分配：将任务平均分给两个团队
 * 2. 资源均衡：负载均衡
 */

export { canPartition, canPartition_2d };
export default canPartition;

