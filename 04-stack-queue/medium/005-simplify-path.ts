/**
 * 📝 题目：简化路径
 * 🔗 链接：https://leetcode.cn/problems/simplify-path/
 * 🏷️ 难度：Medium
 * 🏷️ 标签：栈、字符串
 *
 * 📋 题目描述：
 * 给你一个字符串 path，表示指向某一文件或目录的 Unix 风格 绝对路径，
 * 请你将其转化为更加简洁的规范路径。
 *
 * 规则：
 * - 一个点 '.' 表示当前目录本身
 * - 两个点 '..' 表示将目录切换到上一级（指向父目录）
 * - 多个连续的斜杠（如 '//'）都被视为单个斜杠 '/'
 * - 任何其他格式的点（如 '...'）均被视为文件/目录名称
 *
 * 返回的简化路径：
 * - 始终以斜杠 '/' 开头
 * - 两个目录名之间只有一个斜杠 '/'
 * - 最后一个目录名（如果存在）不能以 '/' 结尾
 * - 路径仅包含从根目录到目标文件或目录的路径上的目录
 *
 * 示例：
 * 输入：path = "/home/"
 * 输出："/home"
 *
 * 输入：path = "/../"
 * 输出："/"
 *
 * 输入：path = "/home//foo/"
 * 输出："/home/foo"
 */

// ============================================================
// 💡 思路分析：这道题的解法是怎么想出来的？
// ============================================================
//
// 核心操作：
// - '.' → 不操作
// - '..' → 返回上一级（出栈）
// - 其他 → 进入目录（入栈）
//
// 步骤：
// 1. 用 '/' 分割路径
// 2. 遍历每个部分，用栈处理
// 3. 最后用 '/' 连接栈中元素

// ============================================================
// 解法：栈
// ============================================================
// ⏱️ 时间复杂度：O(n) | 空间复杂度：O(n)

/**
 * 📊 执行过程图解：
 *
 * path = "/a/./b/../../c/"
 *
 * 分割: ["", "a", ".", "b", "..", "..", "c", ""]
 *
 * "":   空字符串，跳过
 * "a":  入栈               栈: ["a"]
 * ".":  当前目录，跳过     栈: ["a"]
 * "b":  入栈               栈: ["a", "b"]
 * "..": 返回上级，出栈     栈: ["a"]
 * "..": 返回上级，出栈     栈: []
 * "c":  入栈               栈: ["c"]
 * "":   空字符串，跳过
 *
 * 结果: "/" + ["c"].join("/") = "/c"
 */
function simplifyPath(path: string): string {
  const parts = path.split('/');
  const stack: string[] = [];

  for (const part of parts) {
    if (part === '' || part === '.') {
      // 空字符串（多个/）或当前目录，跳过
      continue;
    } else if (part === '..') {
      // 返回上级目录
      if (stack.length > 0) {
        stack.pop();
      }
      // 已经在根目录则不操作
    } else {
      // 有效目录名，入栈
      stack.push(part);
    }
  }

  return '/' + stack.join('/');
}

// ============================================================
// 解法二：使用 reduce
// ============================================================
function simplifyPath_v2(path: string): string {
  const stack = path.split('/').reduce((acc: string[], part) => {
    if (part === '..') {
      acc.pop();
    } else if (part && part !== '.') {
      acc.push(part);
    }
    return acc;
  }, []);

  return '/' + stack.join('/');
}

// ============================================================
// ⚠️ 易错点
// ============================================================
/**
 * 1. 分割后的空字符串：
 *    - "/home/" 分割后是 ["", "home", ""]
 *    - 需要跳过空字符串
 *
 * 2. 根目录的 '..'：
 *    - 根目录没有上级，'..' 不操作
 *    - 不要报错或返回错误结果
 *
 * 3. '...' 等特殊名称：
 *    - 三个点是有效的目录名
 *    - 只有 '.' 和 '..' 有特殊含义
 *
 * 4. 结果格式：
 *    - 必须以 '/' 开头
 *    - 不能以 '/' 结尾（根目录除外）
 */

// ============================================================
// 🔗 举一反三：相似题目
// ============================================================
/**
 * - 删除字符串中的所有相邻重复项 → 栈处理字符串
 * - 比较含退格的字符串 → 类似的 #/backspace 处理
 */

// ============================================================
// 🏢 前端业务场景
// ============================================================
/**
 * 1. 路由处理：简化和规范化 URL 路径
 * 2. 文件系统：处理相对路径转绝对路径
 * 3. 面包屑导航：解析当前路径层级
 */

export { simplifyPath, simplifyPath_v2 };
export default simplifyPath;

