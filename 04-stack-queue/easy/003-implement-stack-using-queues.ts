/**
 * 📝 题目：用队列实现栈
 * 🔗 链接：https://leetcode.cn/problems/implement-stack-using-queues/
 * 🏷️ 难度：Easy
 * 🏷️ 标签：栈、设计、队列
 *
 * 📋 题目描述：
 * 请你仅使用两个队列实现一个后入先出（LIFO）的栈。
 *
 * 实现 MyStack 类：
 * - void push(int x) 将元素 x 压入栈顶
 * - int pop() 移除并返回栈顶元素
 * - int top() 返回栈顶元素
 * - boolean empty() 如果栈是空的，返回 true；否则，返回 false
 *
 * 进阶：你能否仅用一个队列来实现栈？
 *
 * 示例：
 * 输入：
 * ["MyStack", "push", "push", "top", "pop", "empty"]
 * [[], [1], [2], [], [], []]
 * 输出：
 * [null, null, null, 2, 2, false]
 */

// ============================================================
// 💡 思路分析：这道题的解法是怎么想出来的？
// ============================================================
//
// 队列是 FIFO（先进先出），栈是 LIFO（后进先出）
//
// 方法一：两个队列
// - push 时倒腾：新元素先入 q2，然后把 q1 全部转到 q2，交换 q1 和 q2
// - 这样 q1 的队首总是最新入栈的元素
//
// 方法二：一个队列（推荐）
// - push 时：先入队，然后把前面的 n-1 个元素出队再入队
// - 这样队首就是最新入栈的元素

// ============================================================
// 解法一：一个队列（推荐）
// ============================================================
// ⏱️ push: O(n), pop/top: O(1) | 空间复杂度：O(n)

/**
 * 📊 执行过程图解（一个队列）：
 *
 * push(1):
 *   入队: [1]
 *   不需要调整（只有一个元素）
 *
 * push(2):
 *   入队: [1, 2]
 *   调整: 把前 n-1=1 个元素移到队尾
 *         出队 1，入队 1: [2, 1]
 *
 * push(3):
 *   入队: [2, 1, 3]
 *   调整: 把前 n-1=2 个元素移到队尾
 *         出队 2，入队 2: [1, 3, 2]
 *         出队 1，入队 1: [3, 2, 1]
 *
 * 现在队列状态: [3, 2, 1]
 * 队首 3 就是栈顶！
 *
 * pop(): 直接出队，返回 3
 * 队列状态: [2, 1]
 */
class MyStack {
  private queue: number[] = [];

  /**
   * 入栈：入队后调整顺序
   * 时间复杂度：O(n)
   */
  push(x: number): void {
    this.queue.push(x);

    // 把前面 n-1 个元素移到队尾
    const size = this.queue.length;
    for (let i = 0; i < size - 1; i++) {
      this.queue.push(this.queue.shift()!);
    }
  }

  /**
   * 出栈：直接出队
   * 时间复杂度：O(1)*
   * * JavaScript 的 shift() 是 O(n)，但逻辑上是 O(1)
   */
  pop(): number {
    return this.queue.shift()!;
  }

  /**
   * 查看栈顶：查看队首
   * 时间复杂度：O(1)
   */
  top(): number {
    return this.queue[0];
  }

  /**
   * 是否为空
   * 时间复杂度：O(1)
   */
  empty(): boolean {
    return this.queue.length === 0;
  }
}

// ============================================================
// 解法二：两个队列
// ============================================================
// ⏱️ push: O(n), pop/top: O(1) | 空间复杂度：O(n)

/**
 * 📊 执行过程图解（两个队列）：
 *
 * push(1):
 *   q2 入队 1: q2 = [1]
 *   q1 倒入 q2: q2 = [1]（q1 本来就空）
 *   交换 q1 q2: q1 = [1], q2 = []
 *
 * push(2):
 *   q2 入队 2: q2 = [2]
 *   q1 倒入 q2: q2 = [2, 1]
 *   交换 q1 q2: q1 = [2, 1], q2 = []
 *
 * push(3):
 *   q2 入队 3: q2 = [3]
 *   q1 倒入 q2: q2 = [3, 2, 1]
 *   交换 q1 q2: q1 = [3, 2, 1], q2 = []
 *
 * pop():
 *   q1 出队: 返回 3
 *   q1 = [2, 1]
 */
class MyStack2 {
  private q1: number[] = [];
  private q2: number[] = [];

  push(x: number): void {
    // 新元素先入 q2
    this.q2.push(x);

    // q1 全部转移到 q2
    while (this.q1.length > 0) {
      this.q2.push(this.q1.shift()!);
    }

    // 交换 q1 和 q2
    [this.q1, this.q2] = [this.q2, this.q1];
  }

  pop(): number {
    return this.q1.shift()!;
  }

  top(): number {
    return this.q1[0];
  }

  empty(): boolean {
    return this.q1.length === 0;
  }
}

// ============================================================
// 🔄 解法对比
// ============================================================
/**
 * | 解法       | push  | pop   | 空间  | 特点                |
 * |-----------|-------|-------|-------|---------------------|
 * | 一个队列   | O(n)  | O(1)* | O(n)  | 推荐，代码简洁       |
 * | 两个队列   | O(n)  | O(1)* | O(n)  | 经典思路            |
 *
 * * JavaScript 的 shift() 实际是 O(n)
 */

// ============================================================
// ⚠️ 易错点
// ============================================================
/**
 * 1. 调整次数：
 *    - 一个队列：移动 n-1 个元素，不是 n 个
 *    - 新入队的元素不需要移动
 *
 * 2. 空栈判断：
 *    - 一个队列：queue.length === 0
 *    - 两个队列：q1.length === 0（q2 总是空的）
 *
 * 3. JavaScript shift() 性能：
 *    - shift() 是 O(n)
 *    - 如果性能敏感，可以用对象模拟队列
 */

// ============================================================
// 🔗 举一反三：相似题目
// ============================================================
/**
 * - 用栈实现队列 → 两次后进先出变成先进先出
 * - 最小栈 → 设计类问题
 */

// ============================================================
// 🏢 前端业务场景
// ============================================================
/**
 * 1. 理解数据结构：面试基础题
 * 2. 实际上很少需要用队列实现栈
 * 3. 主要考察对栈和队列特性的理解
 */

export { MyStack, MyStack2 };
export default MyStack;

