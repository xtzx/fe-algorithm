/**
 * 📝 题目：用栈实现队列
 * 🔗 链接：https://leetcode.cn/problems/implement-queue-using-stacks/
 * 🏷️ 难度：Easy
 * 🏷️ 标签：栈、设计、队列
 *
 * 📋 题目描述：
 * 请你仅使用两个栈实现先入先出队列。
 *
 * 实现 MyQueue 类：
 * - void push(int x) 将元素 x 推到队列的末尾
 * - int pop() 从队列的开头移除并返回元素
 * - int peek() 返回队列开头的元素
 * - boolean empty() 如果队列为空，返回 true；否则，返回 false
 *
 * 说明：
 * - 你只能使用标准的栈操作（push to top, peek/pop from top, size, isEmpty）
 *
 * 示例：
 * 输入：
 * ["MyQueue", "push", "push", "peek", "pop", "empty"]
 * [[], [1], [2], [], [], []]
 * 输出：
 * [null, null, null, 1, 1, false]
 */

// ============================================================
// 💡 思路分析：这道题的解法是怎么想出来的？
// ============================================================
//
// 栈是 LIFO（后进先出），队列是 FIFO（先进先出）
//
// 关键洞察：两次后进先出 = 先进先出
//
// 用两个栈：
// - 入队栈（inStack）：专门负责入队
// - 出队栈（outStack）：专门负责出队
//
// 当需要出队时：
// - 如果 outStack 为空，把 inStack 全部倒入 outStack
// - 然后从 outStack 出栈

// ============================================================
// 解法：两个栈
// ============================================================
// ⏱️ 时间复杂度：均摊 O(1) | 空间复杂度：O(n)

/**
 * 📊 执行过程图解：
 *
 * push(1), push(2), push(3):
 *
 *   inStack     outStack
 *   ┌───┐       ┌───┐
 *   │ 3 │       │   │
 *   ├───┤       │   │
 *   │ 2 │       │   │
 *   ├───┤       │   │
 *   │ 1 │       │   │
 *   └───┘       └───┘
 *
 * pop():
 *   Step 1: outStack 为空，把 inStack 倒入 outStack
 *
 *   inStack     outStack
 *   ┌───┐       ┌───┐
 *   │   │       │ 1 │  ← 原来的栈底变成栈顶
 *   │   │       ├───┤
 *   │   │       │ 2 │
 *   │   │       ├───┤
 *   │   │       │ 3 │
 *   └───┘       └───┘
 *
 *   Step 2: 从 outStack pop，返回 1
 *
 *   inStack     outStack
 *   ┌───┐       ┌───┐
 *   │   │       │ 2 │
 *   │   │       ├───┤
 *   │   │       │ 3 │
 *   └───┘       └───┘
 *
 * push(4):
 *   直接 push 到 inStack
 *
 *   inStack     outStack
 *   ┌───┐       ┌───┐
 *   │ 4 │       │ 2 │
 *   │   │       ├───┤
 *   │   │       │ 3 │
 *   └───┘       └───┘
 *
 * pop():
 *   outStack 非空，直接 pop，返回 2
 */
class MyQueue {
  private inStack: number[] = [];
  private outStack: number[] = [];

  /**
   * 入队：直接 push 到入队栈
   * 时间复杂度：O(1)
   */
  push(x: number): void {
    this.inStack.push(x);
  }

  /**
   * 出队：从出队栈 pop
   * 时间复杂度：均摊 O(1)
   */
  pop(): number {
    this.transfer();
    return this.outStack.pop()!;
  }

  /**
   * 查看队首：查看出队栈栈顶
   * 时间复杂度：均摊 O(1)
   */
  peek(): number {
    this.transfer();
    return this.outStack[this.outStack.length - 1];
  }

  /**
   * 是否为空：两个栈都为空
   * 时间复杂度：O(1)
   */
  empty(): boolean {
    return this.inStack.length === 0 && this.outStack.length === 0;
  }

  /**
   * 私有方法：把入队栈的元素转移到出队栈
   * 只在出队栈为空时才转移
   */
  private transfer(): void {
    if (this.outStack.length === 0) {
      while (this.inStack.length > 0) {
        this.outStack.push(this.inStack.pop()!);
      }
    }
  }
}

// ============================================================
// 均摊复杂度分析
// ============================================================
/**
 * 为什么 pop 和 peek 是均摊 O(1)？
 *
 * - 每个元素最多被 push 到 inStack 一次
 * - 每个元素最多被转移到 outStack 一次
 * - 每个元素最多从 outStack pop 一次
 *
 * n 个元素的总操作次数 ≤ 3n
 * 平均每个操作的复杂度 = 3n / n = O(1)
 *
 * 即使单次 pop 可能是 O(n)（需要转移），均摊下来是 O(1)
 */

// ============================================================
// ⚠️ 易错点
// ============================================================
/**
 * 1. 转移时机：
 *    - 只在 outStack 为空时才转移
 *    - 不是每次 pop/peek 都转移
 *
 * 2. 全部转移：
 *    - 一次性把 inStack 全部倒入 outStack
 *    - 不是只转移一个
 *
 * 3. empty 判断：
 *    - 两个栈都为空才是空
 *    - 不是只判断 inStack
 */

// ============================================================
// 🔗 举一反三：相似题目
// ============================================================
/**
 * - 用队列实现栈 → 类似思路
 * - 设计循环队列 → 数组实现队列
 * - 设计双端队列 → 更复杂的数据结构
 */

// ============================================================
// 🏢 前端业务场景
// ============================================================
/**
 * 1. 消息队列：在只能用栈的环境下实现队列
 * 2. 事件处理：保证事件按顺序处理
 * 3. 理解数据结构：面试常考的基础题
 */

export { MyQueue };
export default MyQueue;

