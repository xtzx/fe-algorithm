# 03. Turbopack 架构解析

> Vercel 出品：面向 Next.js 的下一代打包器

---

## 📑 目录

1. [Turbopack 是什么](#turbopack-是什么)
2. [核心架构](#核心架构)
3. [与 Webpack 对比](#与-webpack-对比)
4. [在 Next.js 中使用](#在-nextjs-中使用)
5. [Turborepo 与 Turbopack 的关系](#turborepo-与-turbopack-的关系)
6. [面试问题与答案](#面试问题与答案)

---

## Turbopack 是什么

**Turbopack** 是 Vercel 推出的新一代打包器，定位为 **Webpack 的继任者**。

### 核心特点

| 特点 | 说明 |
|------|------|
| **Rust 实现** | 充分利用多核 CPU |
| **增量计算** | 函数级别的缓存，只重新计算变化的部分 |
| **延迟编译** | 只编译当前请求的模块 |
| **原生 ESM** | 开发模式使用原生 ES Modules |

### 性能数据（官方宣称）

```
Cold Start (3000 模块):
├── Webpack:    18.2s
├── Vite:        4.8s
└── Turbopack:   1.8s  (10x faster than Webpack)

HMR:
├── Webpack:    ~500ms
├── Vite:       ~100ms
└── Turbopack:   ~10ms (almost instant)
```

---

## 核心架构

### 1. 任务图模型（Turbo Engine）

Turbopack 的核心是 **Turbo Engine**：一个基于任务图的增量计算引擎。

```
┌─────────────────────────────────────────────────────────────────┐
│                      Turbo Engine 架构                          │
│                                                                 │
│   ┌─────────┐    ┌─────────┐    ┌─────────┐                    │
│   │ Task A  │───►│ Task B  │───►│ Task C  │                    │
│   │ (解析)   │    │ (转换)   │    │ (生成)   │                    │
│   └─────────┘    └─────────┘    └─────────┘                    │
│        │              │              │                          │
│        ▼              ▼              ▼                          │
│   ┌─────────┐    ┌─────────┐    ┌─────────┐                    │
│   │ Cache A │    │ Cache B │    │ Cache C │                    │
│   └─────────┘    └─────────┘    └─────────┘                    │
│                                                                 │
│   当 Task A 的输入没变时，直接使用 Cache A                        │
│   Task B 和 Task C 也不需要重新执行                              │
└─────────────────────────────────────────────────────────────────┘
```

### 2. 函数级别缓存

```rust
// 伪代码：Turbo Engine 的核心概念
#[turbo_tasks::function]
async fn parse(path: &str) -> Result<Module> {
    // 这个函数的结果会被缓存
    // 只有当 path 对应的文件内容变化时才会重新执行
    let content = read_file(path).await?;
    let module = parse_content(content)?;
    Ok(module)
}

#[turbo_tasks::function]
async fn transform(module: Module) -> Result<TransformedModule> {
    // 输入是 parse 的输出
    // 只有当 module 变化时才会重新执行
    let transformed = apply_transforms(module)?;
    Ok(transformed)
}
```

**关键理念**：
- 每个构建步骤都是一个 **可缓存的函数**
- 函数的输出只依赖于输入
- 输入不变 = 输出不变 = 直接用缓存

### 3. 延迟编译 (Lazy Compilation)

```
传统打包器 (Webpack):
启动 → 编译全部模块 → 等待... → 可访问

Turbopack:
启动 → 立即可访问 → 请求到达时编译该模块

示例：
浏览器请求 /page/about
     ↓
Turbopack 只编译:
├── pages/about.tsx
├── components/Header.tsx (about 引用的)
└── styles/about.css (about 引用的)
     ↓
其他 1000 个模块不编译
```

### 4. 模块图 vs Chunk 图

```
┌─────────────────────────────────────────────────────────────────┐
│                         模块图                                  │
│                                                                 │
│      A.tsx ────► B.tsx ────► C.tsx                             │
│        │                       │                                │
│        └─────► D.tsx ◄────────┘                                │
│                                                                 │
│   Turbopack 维护完整的模块依赖关系                               │
└─────────────────────────────────────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────────┐
│                         Chunk 图                                │
│                                                                 │
│      ┌─────────────────┐      ┌─────────────────┐              │
│      │    Chunk 1      │      │    Chunk 2      │              │
│      │  A.tsx + B.tsx  │ ───► │  C.tsx + D.tsx  │              │
│      └─────────────────┘      └─────────────────┘              │
│                                                                 │
│   根据分包策略，模块被分配到不同的 Chunk                          │
└─────────────────────────────────────────────────────────────────┘
```

---

## 与 Webpack 对比

### 架构对比

| 维度 | Webpack | Turbopack |
|------|---------|-----------|
| **实现语言** | JavaScript | Rust |
| **执行模型** | 单线程 | 多线程 |
| **构建策略** | 全量构建 | 增量构建 |
| **缓存粒度** | 文件级别 | 函数级别 |
| **开发模式** | 打包后提供 | 延迟编译 |
| **插件系统** | Tapable 钩子 | Turbo Tasks (Rust) |

### 性能对比

```
场景：修改一个组件后的 HMR 时间

Webpack:
1. 检测文件变化 (10ms)
2. 重新解析模块 (50ms)
3. 重新构建依赖链 (200ms)
4. 生成新的 chunk (100ms)
5. 发送到浏览器 (50ms)
总计: ~400ms

Turbopack:
1. 检测文件变化 (10ms)
2. 只重新计算受影响的任务 (20ms)
3. 发送到浏览器 (10ms)
总计: ~40ms (10x faster)
```

### 为什么 Turbopack 更快？

```
┌─────────────────────────────────────────────────────────────────┐
│                     Webpack 构建                                │
│                                                                 │
│   修改 A.tsx                                                    │
│        ↓                                                        │
│   重新构建: A → B → C → D → E → ... → Z                         │
│   (整个依赖链)                                                   │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                    Turbopack 构建                               │
│                                                                 │
│   修改 A.tsx                                                    │
│        ↓                                                        │
│   检查: 哪些任务的缓存失效了？                                    │
│        ↓                                                        │
│   只重新执行:                                                    │
│   ├── parse(A.tsx)     ← 缓存失效                               │
│   ├── transform(A)     ← 输入变了，重新执行                       │
│   └── B, C, D... 的缓存仍然有效，跳过                            │
└─────────────────────────────────────────────────────────────────┘
```

---

## 在 Next.js 中使用

### 启用 Turbopack

```bash
# 开发模式启用 Turbopack
next dev --turbo

# 或在 package.json 中
{
  "scripts": {
    "dev": "next dev --turbo"
  }
}
```

### 配置选项

```javascript
// next.config.js
module.exports = {
  experimental: {
    // Turbopack 相关配置
    turbo: {
      // Loader 配置（类似 Webpack loader）
      loaders: {
        '.svg': ['@svgr/webpack'],
      },

      // 解析别名
      resolveAlias: {
        '@': './src',
      },

      // 解析扩展名
      resolveExtensions: ['.ts', '.tsx', '.js', '.jsx'],
    },
  },
};
```

### 当前限制（截至 2024）

| 功能 | 支持状态 |
|------|----------|
| 开发模式 | ✅ 稳定 |
| 生产构建 | ⚠️ Beta |
| Webpack Loader | ⚠️ 部分兼容 |
| Webpack Plugin | ❌ 不兼容 |
| 自定义配置 | ⚠️ 有限支持 |

---

## Turborepo 与 Turbopack 的关系

```
┌─────────────────────────────────────────────────────────────────┐
│                     Turbo 生态系统                              │
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                    Turborepo                            │   │
│  │          (Monorepo 构建系统 / 任务编排)                   │   │
│  │                                                         │   │
│  │  - 跨包的任务缓存                                        │   │
│  │  - 并行执行任务                                          │   │
│  │  - 增量构建                                              │   │
│  └─────────────────────────────────────────────────────────┘   │
│                            │                                    │
│                            │ 共享核心                           │
│                            ▼                                    │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                   Turbo Engine                          │   │
│  │          (增量计算引擎，函数级缓存)                        │   │
│  └─────────────────────────────────────────────────────────┘   │
│                            │                                    │
│                            │ 驱动                              │
│                            ▼                                    │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                    Turbopack                            │   │
│  │              (下一代 JavaScript 打包器)                   │   │
│  │                                                         │   │
│  │  - 模块打包                                              │   │
│  │  - 开发服务器                                            │   │
│  │  - HMR                                                  │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 面试问题与答案

### Q1: Turbopack 为什么比 Webpack 快？

**答案**：

> 三个核心原因：
>
> 1. **Rust 实现**：编译为机器码，多线程并行，无 GC 暂停
> 2. **增量计算**：基于函数级别的缓存，只重新计算变化的部分，而不是整个模块链
> 3. **延迟编译**：开发模式下只编译当前请求的模块，不预先打包全部
>
> 举个例子：修改一个组件，Webpack 可能需要重新构建整个依赖链（几百毫秒），而 Turbopack 只需要重新执行几个受影响的任务（几十毫秒）。

### Q2: Turbopack 和 Vite 有什么区别？

**答案**：

> | 维度 | Vite | Turbopack |
> |------|------|-----------|
> | 开发模式 | 原生 ESM + Esbuild 转译 | 增量编译 |
> | 生产构建 | Rollup | Turbopack 自身 |
> | 缓存策略 | 文件级别 | 函数级别 |
> | 生态 | 独立生态，插件丰富 | Next.js 绑定 |
>
> 本质区别：Vite 利用浏览器原生 ESM 实现"不打包"；Turbopack 仍然打包，但通过增量计算极大加速。

### Q3: Turbopack 能完全替代 Webpack 吗？

**答案**：

> 目前不能，主要原因：
>
> 1. **生产构建尚未稳定**：目前主要用于开发模式
> 2. **插件生态不兼容**：Webpack 插件无法直接迁移
> 3. **配置能力有限**：高级定制场景支持不足
>
> 但对于 Next.js 项目，开发模式下使用 Turbopack 已经非常成熟，可以显著提升开发体验。

