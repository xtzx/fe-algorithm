# 01. Docker 基础概念

> 容器化技术入门：理解镜像、容器、仓库

---

## 📑 目录

1. [什么是 Docker](#什么是-docker)
2. [核心概念](#核心概念)
3. [Docker vs 虚拟机](#docker-vs-虚拟机)
4. [常用命令](#常用命令)
5. [常见错误 & 排查](#常见错误--排查)
6. [面试问答](#面试问答)

---

## 什么是 Docker

Docker 是一个开源的容器化平台，让你可以将应用及其依赖打包成一个标准化的单元（容器），在任何环境中一致地运行。

### 为什么需要 Docker？

```
传统部署问题:
├── "在我机器上能跑啊" → 环境不一致
├── 依赖冲突 → Node 14 vs Node 18
├── 部署复杂 → 手动安装各种依赖
└── 资源浪费 → 每个应用一台虚拟机

Docker 解决方案:
├── 环境一致 → 开发、测试、生产完全相同
├── 依赖隔离 → 每个容器独立的文件系统
├── 快速部署 → 秒级启动
└── 资源高效 → 共享主机内核
```

---

## 核心概念

### 1. 镜像 (Image)

**镜像** 是一个只读的模板，包含运行应用所需的一切：代码、运行时、库、环境变量、配置文件。

```
镜像结构（分层）:
┌─────────────────────────────────┐
│         应用代码层              │  ← 你的代码
├─────────────────────────────────┤
│        npm 依赖层               │  ← node_modules
├─────────────────────────────────┤
│        Node.js 运行时           │  ← 基础镜像
├─────────────────────────────────┤
│        Alpine Linux            │  ← 操作系统
└─────────────────────────────────┘

每一层只读，层层叠加
修改只在最上层，共享相同的底层
```

### 2. 容器 (Container)

**容器** 是镜像的运行实例。可以理解为一个轻量级的、隔离的进程。

```
镜像 vs 容器:
├── 镜像：类 (Class)
└── 容器：实例 (Instance)

一个镜像可以创建多个容器
每个容器相互隔离
```

### 3. 仓库 (Registry)

**仓库** 是存储和分发镜像的地方。

| 仓库 | 说明 |
|------|------|
| **Docker Hub** | 官方公共仓库 |
| **阿里云 ACR** | 国内常用 |
| **AWS ECR** | 亚马逊云 |
| **Harbor** | 自建私有仓库 |

---

## Docker vs 虚拟机

```
┌─────────────────────────────────────────────────────────────────┐
│                         虚拟机架构                              │
│                                                                 │
│  ┌─────────┐  ┌─────────┐  ┌─────────┐                        │
│  │  App A  │  │  App B  │  │  App C  │                        │
│  ├─────────┤  ├─────────┤  ├─────────┤                        │
│  │ Guest OS│  │ Guest OS│  │ Guest OS│  ← 每个 VM 一个完整 OS  │
│  └────┬────┘  └────┬────┘  └────┬────┘                        │
│       └───────────┬┴───────────┘                               │
│              ┌────┴────┐                                       │
│              │Hypervisor│  ← 虚拟化层                          │
│              └────┬────┘                                       │
│              ┌────┴────┐                                       │
│              │ Host OS │                                       │
│              └─────────┘                                       │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                         Docker 架构                             │
│                                                                 │
│  ┌─────────┐  ┌─────────┐  ┌─────────┐                        │
│  │  App A  │  │  App B  │  │  App C  │                        │
│  ├─────────┤  ├─────────┤  ├─────────┤                        │
│  │ Bins/   │  │ Bins/   │  │ Bins/   │  ← 只有依赖，无完整 OS  │
│  │ Libs    │  │ Libs    │  │ Libs    │                        │
│  └────┬────┘  └────┬────┘  └────┬────┘                        │
│       └───────────┬┴───────────┘                               │
│              ┌────┴────┐                                       │
│              │ Docker  │  ← Docker Engine                      │
│              └────┬────┘                                       │
│              ┌────┴────┐                                       │
│              │ Host OS │  ← 共享主机内核                        │
│              └─────────┘                                       │
└─────────────────────────────────────────────────────────────────┘
```

### 对比表

| 特性 | 虚拟机 | Docker |
|------|--------|--------|
| **启动时间** | 分钟级 | 秒级 |
| **磁盘占用** | GB 级 | MB 级 |
| **性能** | 有损耗（Hypervisor） | 接近原生 |
| **隔离性** | 完全隔离（独立内核） | 进程级隔离（共享内核） |
| **适用场景** | 需要不同 OS | 应用部署 |

---

## 常用命令

### 镜像操作

```bash
# 拉取镜像
docker pull node:18-alpine

# 列出本地镜像
docker images

# 删除镜像
docker rmi <image_id>

# 构建镜像
docker build -t my-app:1.0 .

# 推送镜像到仓库
docker push my-registry/my-app:1.0
```

### 容器操作

```bash
# 运行容器
docker run -d -p 3000:3000 --name my-app my-app:1.0

# 参数说明:
# -d: 后台运行
# -p: 端口映射 (主机端口:容器端口)
# --name: 容器名称

# 列出运行中的容器
docker ps

# 列出所有容器（包括停止的）
docker ps -a

# 停止容器
docker stop my-app

# 启动已停止的容器
docker start my-app

# 删除容器
docker rm my-app

# 进入容器
docker exec -it my-app sh

# 查看容器日志
docker logs -f my-app
```

### 清理命令

```bash
# 清理未使用的镜像、容器、网络
docker system prune

# 清理所有未使用的镜像
docker image prune -a

# 查看 Docker 磁盘占用
docker system df
```

---

## 常见错误 & 排查

### 1. 端口被占用

```bash
# 错误信息
Error: bind: address already in use

# 排查
lsof -i :3000
# 或
netstat -tlnp | grep 3000

# 解决：停止占用端口的进程或换一个端口
docker run -p 3001:3000 my-app
```

### 2. 镜像拉取失败

```bash
# 错误信息
Error: pull access denied / timeout

# 解决方案
# 1. 检查网络
# 2. 使用国内镜像源
# 编辑 /etc/docker/daemon.json
{
  "registry-mirrors": ["https://registry.docker-cn.com"]
}
# 重启 Docker
systemctl restart docker
```

### 3. 容器启动后立即退出

```bash
# 排查
docker logs my-app

# 常见原因
# 1. 主进程执行完毕就退出（需要保持前台运行）
# 2. 程序报错
# 3. 配置错误

# 调试：交互式运行
docker run -it my-app sh
```

### 4. 权限问题

```bash
# 错误信息
permission denied

# 解决
# 1. 在 Dockerfile 中切换用户
USER node

# 2. 或调整文件权限
RUN chown -R node:node /app
```

---

## 面试问答

### Q1: Docker 和虚拟机有什么区别？

**答案**：

> 核心区别在于 **虚拟化层级** 不同：
>
> | 维度 | 虚拟机 | Docker |
> |------|--------|--------|
> | 虚拟化对象 | 完整操作系统 | 应用进程 |
> | 资源开销 | 重（GB 级） | 轻（MB 级） |
> | 启动速度 | 慢（分钟级） | 快（秒级） |
> | 隔离性 | 强（独立内核） | 较弱（共享内核） |
>
> Docker 更适合应用部署场景，虚拟机适合需要完全隔离或不同内核的场景。

### Q2: Docker 镜像的分层机制有什么好处？

**答案**：

> 分层机制带来三个主要好处：
>
> 1. **复用**：多个镜像可以共享相同的底层，节省存储空间
> 2. **缓存**：构建时只重建变化的层，加速构建
> 3. **传输优化**：拉取镜像时只下载缺失的层
>
> 例如，10 个 Node.js 应用可以共享同一个 `node:18-alpine` 基础层。

### Q3: 如何优化 Docker 镜像大小？

**答案**：

> 几个关键策略：
>
> 1. **使用精简基础镜像**：`alpine` 代替 `ubuntu`
> 2. **多阶段构建**：构建阶段用完整镜像，运行阶段只保留必要文件
> 3. **合并 RUN 指令**：减少层数
> 4. **使用 .dockerignore**：排除不需要的文件
> 5. **清理缓存**：`npm cache clean --force`
>
> 典型效果：Node.js 应用从 1GB 优化到 100MB 以内。

