# 🎯 前端算法面试通关指南

> 面向有一定基础的前端开发者，系统性准备算法面试

## 📊 学习路线图

```
Step 01 ──► Step 02 ──► Step 03 ──► Step 04
数组双指针   哈希与字符串   链表       栈与队列
    │           │           │           │
    └───────────┴───────────┴───────────┘
                    基础篇
                      │
                      ▼
Step 05 ──► Step 06 ──► Step 07 ──► Step 08
 二叉树      二分查找     回溯算法    动态规划
    │           │           │           │
    └───────────┴───────────┴───────────┘
                    进阶篇
```

---

## 🎯 学习目标：能力层级

### 我们要达到的境界

```
Level 1: 我做过这道题 ────────────────► 靠记忆，换个数字就不会了
Level 2: 我会这类题的模板 ────────────► 能套路，但遇到变形题会卡壳
Level 3: 我能识别问题类型并归约 ──────► 看到新题能变形为熟悉的模型 ✅ 目标
Level 4: 算法思维融入日常开发 ────────► 用算法思维优化业务代码 🚀 进阶
```

### 核心能力：问题归约

看到一个新题，能在有限时间内：

1. **抽象识别** - 这是哪一类问题？（图？区间？DP？）
2. **快速归约** - 变形为熟悉的通用模型/套路
3. **代码实现** - 写出可读性强、可 debug 的代码
4. **复杂度分析** - 清楚说明时间/空间复杂度和 trade-off
5. **业务关联** - 能举出前端业务场景的应用

### 问题归约思维训练

遇到陌生题时，下意识去问：

| 归约方向 | 判断信号 | 典型例子 |
|---------|---------|---------|
| **图问题** | 依赖关系、路径、可达性 | 课程表 → 拓扑排序 |
| **区间问题** | 排序后双指针/扫描线 | 合并区间、会议室 |
| **DP 状态转移** | 最优解、方案数、可行性 | 背包、子序列 |
| **滑动窗口** | 连续子数组/子串、最长/最短 | 无重复最长子串 |
| **单调栈/队列** | 下一个更大/更小元素 | 每日温度、滑动窗口最大值 |

```
💡 不是「我看过这道题」
   而是「我能把这道题变形为我见过的那类问题」
```

---

## 📚 学习大纲

### 基础篇（Step 01 - 04）

| 步骤 | 主题 | 核心内容 | 面试频率 | 预计时间 |
|:---:|------|----------|:-------:|:-------:|
| 01 | [数组与双指针](./01-array/) | 复杂度分析、双指针、滑动窗口、前缀和 | ⭐⭐⭐⭐⭐ | 3天 |
| 02 | [哈希表与字符串](./02-hash-string/) | Map/Set、两数之和、异位词、回文 | ⭐⭐⭐⭐⭐ | 3天 |
| 03 | [链表](./03-linked-list/) | 反转、环检测、合并、快慢指针 | ⭐⭐⭐⭐⭐ | 2天 |
| 04 | [栈与队列](./04-stack-queue/) | 有效括号、单调栈、滑动窗口最大值 | ⭐⭐⭐⭐ | 2天 |

### 进阶篇（Step 05 - 08）

| 步骤 | 主题 | 核心内容 | 面试频率 | 预计时间 |
|:---:|------|----------|:-------:|:-------:|
| 05 | [二叉树](./05-binary-tree/) | 遍历、递归、BFS/DFS、构造树 | ⭐⭐⭐⭐⭐ | 4天 |
| 06 | [二分查找](./06-binary-search/) | 标准二分、搜索边界、旋转数组 | ⭐⭐⭐⭐⭐ | 2天 |
| 07 | [回溯算法](./07-backtracking/) | 排列、组合、子集、剪枝优化 | ⭐⭐⭐⭐ | 3天 |
| 08 | [动态规划](./08-dynamic-programming/) | 背包问题、子序列、路径问题 | ⭐⭐⭐⭐⭐ | 5天 |

**总计约 24 天**，每天 1-2 小时

---

## 🎯 章节内容设计

### 内容优先级（面试导向）

| 优先级 | 内容 | 重要性 | 说明 |
|:-----:|------|:-----:|------|
| P0 | **适用场景 / 信号词** | ⭐⭐⭐⭐⭐ | 看到题目能立刻判断用什么算法 |
| P0 | **代码模板** | ⭐⭐⭐⭐⭐ | 面试时能快速写出骨架代码 |
| P0 | **问题归类** | ⭐⭐⭐⭐⭐ | 理解一个问题 → 解决一类问题 |
| P1 | **多解法对比** | ⭐⭐⭐⭐ | 暴力→优化的思考路径，解法间的差异 |
| P1 | **复杂度分析** | ⭐⭐⭐⭐ | 面试官必问 |
| P1 | **易错点 / 边界条件** | ⭐⭐⭐⭐ | 避免现场翻车 |
| P2 | **前端业务场景** | ⭐⭐⭐ | 算法在实际开发中的应用 |
| P2 | **概念原理** | ⭐⭐⭐ | 简洁即可，不需要太学术 |

### 标准章节结构

```typescript
// ========== 1. 概念速览 ==========
// - 是什么？一句话定义
// - 核心思想
// - 如果某些难以通过文字理解的可以通过 Mermaid 流程图或者图片形式表达

// ========== 2. 🎯 适用场景 ==========
// - 什么时候用？
// - 题目中的「信号词」
// - 典型问题特征

// ========== 3. 问题归类 ==========
// - 这类问题的通用模型
// - 变体题目如何识别
// - 与其他算法的关联

// ========== 4. 代码模板 ==========
// - 标准模板
// - 常见变体

// ========== 5. 复杂度分析 ==========
// - 时间复杂度
// - 空间复杂度
// - 不同解法的 trade-off

// ========== 6. ⚠️ 易错点 ==========
// - 边界条件
// - 常见 bug
// - 面试踩坑点

// ========== 7. 🏢 前端业务场景 ==========
// - 这类算法在前端开发中的实际应用
// - 举例说明
```

---

## 📁 文件结构

```
📁 XX-topic/
├── index.ts              # 核心内容（概念+场景+模板+归类）
│
├── easy/                 # 简单题（3-4道）
│   ├── 001-two-sum.ts
│   ├── 002-xxx.ts
│   └── ...
│
├── medium/               # 中等题（5-8道）
│   ├── 001-xxx.ts
│   ├── 002-xxx.ts
│   └── ...
│
├── hard/                 # 困难题（2-4道）
│   ├── 001-xxx.ts
│   └── ...
│
└── summary.ts            # 归纳总结：这类问题的通用解法
```

**每道题一个文件的好处**：
- 📂 结构清晰，便于查找和复习
- 🔍 Git 历史更清晰，方便追踪学习进度
- 📝 每道题可以写得更详细，不用担心文件过长

---

## 📊 习题设计

### 每个专题：10-16 道精选题

```
总计 10-16 道题

├── Easy:   3-4 道  ──► 理解基础，建立信心
├── Medium: 5-8 道  ──► 核心题型，必须掌握
└── Hard:   2-4 道  ──► 挑战进阶，提升上限
```

### 选题标准

1. **高频优先** - LeetCode 热题 HOT 100、面试高频题
2. **典型代表** - 能代表该类型的经典题目
3. **有变体价值** - 一道题能延伸出多道相似题
4. **覆盖全面** - 涵盖该专题的主要技巧点

### 每道题目格式（多解法 + 思路来源）

```typescript
/**
 * 📝 题目：两数之和
 * 🔗 链接：https://leetcode.cn/problems/two-sum/
 * 🏷️ 难度：Easy
 * 🏷️ 标签：哈希表、数组
 */

// ============================================================
// 💡 思路分析：这道题的解法是怎么想出来的？
// ============================================================
//
// 1. 最直观的想法：暴力枚举所有两数组合 → O(n²)
// 2. 优化思考：如何避免重复遍历？
//    - 已知 target 和当前数 nums[i]
//    - 需要找的数 = target - nums[i]
//    - 「查找」操作 → 哈希表 O(1)
// 3. 得出优化解法：一边遍历，一边用哈希表记录

// ============================================================
// 解法一：暴力枚举
// ============================================================
// ⏱️ 时间复杂度：O(n²) | 空间复杂度：O(1)
function twoSum_v1(nums: number[], target: number): number[] {
  for (let i = 0; i < nums.length; i++) {
    for (let j = i + 1; j < nums.length; j++) {
      if (nums[i] + nums[j] === target) {
        return [i, j];
      }
    }
  }
  return [];
}

// ============================================================
// 解法二：哈希表（推荐）
// ============================================================
// ⏱️ 时间复杂度：O(n) | 空间复杂度：O(n)
// 💡 优化点：用空间换时间，哈希表实现 O(1) 查找
function twoSum_v2(nums: number[], target: number): number[] {
  const map = new Map<number, number>();
  for (let i = 0; i < nums.length; i++) {
    const complement = target - nums[i];
    if (map.has(complement)) {
      return [map.get(complement)!, i];
    }
    map.set(nums[i], i);
  }
  return [];
}

// ============================================================
// 🔄 解法对比
// ============================================================
// | 解法 | 时间 | 空间 | 适用场景 |
// |------|------|------|---------|
// | 暴力 | O(n²) | O(1) | 数据量小、空间受限 |
// | 哈希 | O(n) | O(n) | 大多数场景（推荐）|

// ============================================================
// ⚠️ 易错点
// ============================================================
// 1. 同一元素不能使用两次 → 先查再存
// 2. 返回的是下标，不是值
// 3. 可能有多组解，题目要求返回任意一组

// ============================================================
// 🔗 举一反三：相似题目
// ============================================================
// - 三数之和（排序 + 双指针）
// - 四数之和（排序 + 双指针）
// - 两数之和 II（有序数组，双指针）

// ============================================================
// 🏢 前端业务场景
// ============================================================
// 1. 购物车凑单：找出哪些商品组合刚好满足满减金额
// 2. 表单联动：根据已选值快速查找关联选项
// 3. 数据匹配：在两个数据源中找出匹配的记录
```

---

## 🔄 融会贯通：理解一个问题 → 解决一类问题

### 每个专题的归纳总结（summary.ts）

```typescript
/**
 * 📚 双指针问题归类
 *
 * 当你看到以下特征，考虑用双指针：
 */

// ============================================================
// 类型一：对撞指针（两端向中间）
// ============================================================
// 信号词：有序数组、找两个数、回文判断
// 典型题：两数之和II、三数之和、接雨水、盛水最多的容器

// ============================================================
// 类型二：快慢指针（同向不同速）
// ============================================================
// 信号词：链表环、中点、倒数第N个
// 典型题：环形链表、链表中点、删除倒数第N个节点

// ============================================================
// 类型三：滑动窗口（同向，窗口伸缩）
// ============================================================
// 信号词：连续子数组/子串、最长/最短、包含/不包含
// 典型题：无重复最长子串、最小覆盖子串、长度最小的子数组

// ============================================================
// 🧠 问题变形识别
// ============================================================
//
// 看到「最长连续xxx」→ 滑动窗口
// 看到「有序 + 找两数」→ 对撞指针
// 看到「原地去重/移动」→ 快慢指针
//
// 一些"怪题"的本质：
// - 接雨水 = 对撞指针 + 预处理（或单调栈）
// - 最小覆盖子串 = 滑动窗口 + 哈希表计数
// - 盛水最多的容器 = 对撞指针 + 贪心（移动较小的边）
```

---

## 📈 学习进度

- [x] Step 01: 数组与双指针 ✅
- [x] Step 02: 哈希表与字符串 ✅
- [x] Step 03: 链表 ✅
- [x] Step 04: 栈与队列 ✅
- [x] Step 05: 二叉树 ✅
- [x] Step 06: 二分查找 ✅
- [ ] Step 07: 回溯算法
- [ ] Step 08: 动态规划

---

## 💡 学习建议

### 面试算法三步法

```
1️⃣ 理解题意 ──► 2️⃣ 找到规律 ──► 3️⃣ 代码实现
     │               │               │
  复述题目        暴力解法         边界处理
  确认边界        优化思路         测试用例
```

### 刷题策略

1. **先理解，再刷题** - 每个专题先掌握核心模板
2. **分类刷题** - 按专题集中练习，形成肌肉记忆
3. **限时练习** - Easy 10分钟，Medium 20分钟，Hard 40分钟
4. **总结复盘** - 做完一道总结一道，不贪多
5. **变形思考** - 每道题想想能否变形为其他问题

### 面试技巧

- 🗣️ **边写边说** - 让面试官了解你的思路
- 🤔 **先暴力后优化** - 先写出来，再考虑优化
- ✅ **主动测试** - 用例子验证代码正确性
- ❓ **大胆提问** - 不确定时主动询问面试官
- 🔄 **主动对比** - 说出不同解法的 trade-off

---

## 🔗 推荐资源

- [LeetCode 中国](https://leetcode.cn/)
- [代码随想录](https://programmercarl.com/)
- [labuladong 的算法小抄](https://labuladong.github.io/algo/)

---

