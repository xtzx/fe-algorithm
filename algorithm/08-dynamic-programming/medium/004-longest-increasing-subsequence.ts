/**
 * 📝 题目：最长递增子序列
 * 🔗 链接：https://leetcode.cn/problems/longest-increasing-subsequence/
 * 🏷️ 难度：Medium
 * 🏷️ 标签：数组、二分查找、动态规划
 *
 * 📋 题目描述：
 * 给你一个整数数组 nums，找到其中最长严格递增子序列的长度。
 *
 * 子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。
 * 例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。
 *
 * 示例：
 * 输入：nums = [10,9,2,5,3,7,101,18]
 * 输出：4
 * 解释：最长递增子序列是 [2,3,7,101]，长度为 4
 */

// ============================================================
// 💡 思路分析：这道题的解法是怎么想出来的？
// ============================================================
//
// 方法一：DP
// dp[i] = 以 nums[i] 结尾的 LIS 长度
//
// 状态转移：
// dp[i] = max(dp[j] + 1) for all j < i where nums[j] < nums[i]
//
// 方法二：贪心 + 二分
// 维护一个数组 tails，tails[i] 表示长度为 i+1 的 LIS 的最小结尾元素
// 遍历时用二分查找更新 tails

// ============================================================
// 解法一：DP
// ============================================================
// ⏱️ 时间复杂度：O(n²) | 空间复杂度：O(n)

/**
 * 📊 执行过程图解：
 *
 * nums = [10, 9, 2, 5, 3, 7, 101, 18]
 *
 * ┌──────┬────┬───┬───┬───┬───┬───┬─────┬────┐
 * │ nums │ 10 │ 9 │ 2 │ 5 │ 3 │ 7 │ 101 │ 18 │
 * ├──────┼────┼───┼───┼───┼───┼───┼─────┼────┤
 * │  dp  │  1 │ 1 │ 1 │ 2 │ 2 │ 3 │  4  │ 4  │
 * └──────┴────┴───┴───┴───┴───┴───┴─────┴────┘
 *
 * dp[5]=3: 找到 nums[2]=2 < nums[5]=7, dp[5] = dp[2]+1 = 2
 *          找到 nums[3]=5 < nums[5]=7, dp[5] = max(2, dp[3]+1) = 3
 *
 * 答案：max(dp) = 4
 */
function lengthOfLIS(nums: number[]): number {
  const n = nums.length;
  if (n === 0) return 0;

  // dp[i] = 以 nums[i] 结尾的 LIS 长度
  const dp: number[] = new Array(n).fill(1);

  for (let i = 1; i < n; i++) {
    for (let j = 0; j < i; j++) {
      if (nums[j] < nums[i]) {
        dp[i] = Math.max(dp[i], dp[j] + 1);
      }
    }
  }

  return Math.max(...dp);
}

// ============================================================
// 解法二：贪心 + 二分（推荐）
// ============================================================
// ⏱️ 时间复杂度：O(n log n) | 空间复杂度：O(n)

/**
 * 📊 贪心思路图解：
 *
 * 维护一个 tails 数组：
 * - tails[i] = 长度为 i+1 的 LIS 的最小结尾元素
 * - 保持 tails 数组单调递增
 *
 * nums = [10, 9, 2, 5, 3, 7, 101, 18]
 *
 * 处理 10: tails = [10]
 * 处理 9:  tails = [9]     // 9 < 10，替换
 * 处理 2:  tails = [2]     // 2 < 9，替换
 * 处理 5:  tails = [2, 5]  // 5 > 2，追加
 * 处理 3:  tails = [2, 3]  // 3 替换 5
 * 处理 7:  tails = [2, 3, 7]  // 追加
 * 处理 101: tails = [2, 3, 7, 101]
 * 处理 18: tails = [2, 3, 7, 18]  // 18 替换 101
 *
 * 答案：tails.length = 4
 */
function lengthOfLIS_binary(nums: number[]): number {
  const tails: number[] = [];

  for (const num of nums) {
    // 二分查找 num 应该放的位置
    let left = 0;
    let right = tails.length;

    while (left < right) {
      const mid = Math.floor((left + right) / 2);
      if (tails[mid] < num) {
        left = mid + 1;
      } else {
        right = mid;
      }
    }

    // 如果 left === tails.length，追加
    // 否则替换 tails[left]
    if (left === tails.length) {
      tails.push(num);
    } else {
      tails[left] = num;
    }
  }

  return tails.length;
}

// ============================================================
// 🔄 解法对比
// ============================================================
/**
 * | 解法         | 时间       | 空间  | 特点                |
 * |--------------|------------|-------|---------------------|
 * | DP           | O(n²)      | O(n)  | 好理解              |
 * | 贪心+二分    | O(n log n) | O(n)  | 推荐，效率更高      |
 */

// ============================================================
// ⚠️ 易错点
// ============================================================
/**
 * 1. DP 状态定义：
 *    - 是"以 nums[i] 结尾"，不是"前 i 个"
 *    - 所以返回值是 max(dp)，不是 dp[n-1]
 *
 * 2. 二分查找：
 *    - 找的是第一个 >= num 的位置
 *    - 用于替换或追加
 *
 * 3. 初始值：dp 全部初始化为 1（至少包含自己）
 */

// ============================================================
// 🔗 举一反三：相似题目
// ============================================================
/**
 * - 最长递增子序列的个数 → 需要额外记录方案数
 * - 俄罗斯套娃信封 → 二维 LIS
 * - 最长公共子序列 → 两个序列
 */

// ============================================================
// 🏢 前端业务场景
// ============================================================
/**
 * 1. 时间序列分析：找最长上升趋势
 * 2. 版本管理：找最长递增版本序列
 */

export { lengthOfLIS, lengthOfLIS_binary };
export default lengthOfLIS;

