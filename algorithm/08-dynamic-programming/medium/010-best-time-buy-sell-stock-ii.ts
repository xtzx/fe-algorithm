/**
 * 📝 题目：买卖股票的最佳时机 II
 * 🔗 链接：https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/
 * 🏷️ 难度：Medium
 * 🏷️ 标签：贪心、数组、动态规划
 *
 * 📋 题目描述：
 * 给你一个整数数组 prices，其中 prices[i] 表示某支股票第 i 天的价格。
 *
 * 在每一天，你可以决定是否购买和/或出售股票。你在任何时候最多只能持有一股股票。
 * 你也可以先购买，然后在同一天出售。
 *
 * 返回你能获得的最大利润。
 *
 * 示例：
 * 输入：prices = [7,1,5,3,6,4]
 * 输出：7
 * 解释：在第 2 天买入，第 3 天卖出，利润 4
 *       在第 4 天买入，第 5 天卖出，利润 3
 *       总利润 4 + 3 = 7
 */

// ============================================================
// 💡 思路分析：这道题的解法是怎么想出来的？
// ============================================================
//
// 与"买卖股票 I"的区别：可以多次交易
//
// 方法一：贪心
// - 只要今天比昨天价格高，就在昨天买今天卖
// - 累加所有上涨的差价
//
// 方法二：DP（状态机）
// - dp[i][0] = 第 i 天不持有股票的最大利润
// - dp[i][1] = 第 i 天持有股票的最大利润

// ============================================================
// 解法一：贪心（推荐）
// ============================================================
// ⏱️ 时间复杂度：O(n) | 空间复杂度：O(1)

/**
 * 📊 贪心图解：
 *
 * prices = [7, 1, 5, 3, 6, 4]
 *
 *       7
 *           6
 *       5
 *   4       4
 *       3
 *   1
 *
 * 上涨区间：1→5（利润4），3→6（利润3）
 * 总利润 = 4 + 3 = 7
 */
function maxProfit_greedy(prices: number[]): number {
  let profit = 0;

  for (let i = 1; i < prices.length; i++) {
    // 只要有上涨就收割
    if (prices[i] > prices[i - 1]) {
      profit += prices[i] - prices[i - 1];
    }
  }

  return profit;
}

// ============================================================
// 解法二：DP（状态机）
// ============================================================
// ⏱️ 时间复杂度：O(n) | 空间复杂度：O(1)

/**
 * 📊 状态机图解：
 *
 *        买入 (-price)
 *      ┌───────────────┐
 *      ▼               │
 *  ┌───────┐       ┌───────┐
 *  │ 持有  │◄─────►│ 不持有 │
 *  └───────┘       └───────┘
 *      │               ▲
 *      └───────────────┘
 *         卖出 (+price)
 *
 * dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])
 * dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])
 */
function maxProfit_dp(prices: number[]): number {
  let hold = -prices[0]; // 第一天买入
  let notHold = 0;

  for (let i = 1; i < prices.length; i++) {
    const newNotHold = Math.max(notHold, hold + prices[i]); // 卖出
    const newHold = Math.max(hold, notHold - prices[i]); // 买入（可以用之前的利润买）
    notHold = newNotHold;
    hold = newHold;
  }

  return notHold;
}

// ============================================================
// 🔄 解法对比
// ============================================================
/**
 * | 解法   | 时间  | 空间  | 特点              |
 * |--------|-------|-------|-------------------|
 * | 贪心   | O(n)  | O(1)  | 推荐，最简洁      |
 * | DP     | O(n)  | O(1)  | 通用框架          |
 */

// ============================================================
// ⚠️ 易错点
// ============================================================
/**
 * 1. 与"买卖股票 I"的区别：
 *    - I：只能交易一次，dp[i][1] = max(dp[i-1][1], -prices[i])
 *    - II：可以多次，dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])
 *
 * 2. 贪心的正确性：
 *    - 累加所有上涨差价等价于最优策略
 *    - 因为 (a3-a1) = (a2-a1) + (a3-a2) 当 a1<a2<a3
 */

// ============================================================
// 🔗 举一反三：相似题目
// ============================================================
/**
 * - 买卖股票 I → 只能交易一次
 * - 买卖股票 III → 最多两次
 * - 买卖股票 IV → 最多 k 次
 * - 买卖股票含冷冻期 → 卖后等一天
 * - 买卖股票含手续费 → 有交易成本
 */

export { maxProfit_greedy, maxProfit_dp };
export default maxProfit_greedy;

