/**
 * ============================================================
 * 📚 动态规划 - 面试高频问答
 * ============================================================
 *
 * 本文件包含动态规划相关的面试高频问题，每个问题包含：
 * 1. 问题本身
 * 2. 标准答案
 * 3. 加分回答（展示深度理解）
 * 4. 追问方向
 */

// ============================================================
// Q1: 什么是动态规划？和递归/贪心有什么区别？
// ============================================================

/**
 * 📝 问题：什么是动态规划？和递归、贪心有什么区别？
 *
 * ✅ 标准答案：
 * 动态规划是一种通过将问题分解为子问题，并保存子问题的解来避免重复计算的算法。
 *
 * 核心思想：空间换时间，记住已经计算过的结果。
 *
 * 与递归的区别：
 * - 递归：自顶向下，可能重复计算
 * - DP：自底向上（或记忆化），避免重复
 *
 * 与贪心的区别：
 * - 贪心：每步选局部最优，不回溯
 * - DP：考虑所有可能，保证全局最优
 *
 * ⭐ 加分回答：
 * 「DP 有两个核心性质：
 *
 * 1. 最优子结构：大问题的最优解包含小问题的最优解
 *    例：最短路径的一部分也是最短的
 *
 * 2. 重叠子问题：同一子问题会被多次计算
 *    例：斐波那契 F(5) 需要 F(3)，F(4) 也需要 F(3)
 *
 * DP 的两种实现：
 * - 自顶向下 + 记忆化（Memoization）
 * - 自底向上 + 迭代（Tabulation）
 *
 * 贪心失效的例子：
 * 零钱兑换，硬币 [1, 3, 4]，凑 6
 * - 贪心：4+1+1 = 3 枚
 * - DP：3+3 = 2 枚 ✓
 *
 * DP 比贪心更"保险"，但时间复杂度通常更高。」
 *
 * 🔄 可能的追问：
 * - 什么时候用贪心？什么时候用 DP？
 * - DP 的时间复杂度怎么分析？
 */

// ============================================================
// Q2: DP 五步法是什么？
// ============================================================

/**
 * 📝 问题：你是怎么解 DP 题的？有什么通用方法？
 *
 * ✅ 标准答案：
 * 我用 DP 五步法：
 *
 * 1. 定义状态：dp[i] 表示什么
 * 2. 状态转移方程：dp[i] 怎么从之前的状态推导
 * 3. 初始条件：dp[0] 等于什么
 * 4. 遍历顺序：从前往后还是从后往前
 * 5. 返回值：返回 dp[n] 还是 max(dp)
 *
 * ⭐ 加分回答：
 * 「五步法的关键思考：
 *
 * Step 1 状态定义：
 * - 最难也最重要的一步
 * - 常见模式："前 i 个"、"以 i 结尾"、"区间 [i,j]"
 * - 例：LIS 用"以 i 结尾"，背包用"前 i 个物品"
 *
 * Step 2 状态转移：
 * - 问自己：dp[i] 依赖哪些之前的状态？
 * - 通常来自选择：选或不选、从哪里转移
 *
 * Step 3 初始化：
 * - 最小子问题的答案
 * - 注意：最大值问题初始化 -Infinity，最小值问题初始化 Infinity
 * - 计数问题：dp[0] 通常是 1
 *
 * Step 4 遍历顺序：
 * - 保证依赖的状态已经计算
 * - 0-1 背包：内层从后往前
 * - 完全背包：内层从前往后
 *
 * Step 5 返回值：
 * - "以 i 结尾"的问题：返回 max(dp)
 * - "前 n 个"的问题：返回 dp[n]
 *
 * 调试技巧：打印 dp 数组，检查填表过程。」
 *
 * 🔄 可能的追问：
 * - 状态定义错了会怎样？
 * - 怎么判断状态定义是否正确？
 */

// ============================================================
// Q3: 0-1 背包和完全背包的区别？
// ============================================================

/**
 * 📝 问题：0-1 背包和完全背包有什么区别？代码怎么写？
 *
 * ✅ 标准答案：
 * 0-1 背包：每个物品只能选一次
 * 完全背包：每个物品可以选无限次
 *
 * 代码区别在于内层循环的遍历顺序：
 * - 0-1 背包：从后往前
 * - 完全背包：从前往后
 *
 * ⭐ 加分回答：
 * 「核心区别的原因：
 *
 * 0-1 背包（从后往前）：
 * for (let i = 0; i < n; i++) {
 *   for (let j = capacity; j >= weights[i]; j--) {
 *     dp[j] = Math.max(dp[j], dp[j - weights[i]] + values[i]);
 *   }
 * }
 *
 * 为什么从后往前？
 * - dp[j] 依赖 dp[j - w[i]]
 * - 从后往前时，dp[j - w[i]] 还是"上一轮"的值
 * - 保证每个物品只被选一次
 *
 * 完全背包（从前往后）：
 * for (let i = 0; i < n; i++) {
 *   for (let j = weights[i]; j <= capacity; j++) {
 *     dp[j] = Math.max(dp[j], dp[j - weights[i]] + values[i]);
 *   }
 * }
 *
 * 为什么从前往后？
 * - dp[j] 依赖 dp[j - w[i]]
 * - 从前往后时，dp[j - w[i]] 是"本轮"的值
 * - 允许同一物品被多次选择
 *
 * 典型题目：
 * - 0-1 背包：分割等和子集
 * - 完全背包：零钱兑换」
 *
 * 🔄 可能的追问：
 * - 如果求方案数呢？
 * - 多重背包怎么处理？
 */

// ============================================================
// Q4: 什么时候用"以 i 结尾"的状态定义？
// ============================================================

/**
 * 📝 问题：DP 状态定义中，"前 i 个" 和 "以 i 结尾" 有什么区别？
 *
 * ✅ 标准答案：
 * "前 i 个"：考虑前 i 个元素的最优解
 * "以 i 结尾"：必须包含第 i 个元素的最优解
 *
 * 选择依据：
 * - 子序列问题通常用"以 i 结尾"
 * - 背包问题通常用"前 i 个"
 *
 * ⭐ 加分回答：
 * 「两种定义的对比：
 *
 * "前 i 个"（如背包、打家劫舍）：
 * - dp[i] = 考虑前 i 个元素的最优解
 * - 第 i 个元素可选可不选
 * - 返回值：dp[n]
 *
 * "以 i 结尾"（如 LIS、最大子数组和）：
 * - dp[i] = 必须以第 i 个元素结尾的最优解
 * - 第 i 个元素一定被选
 * - 返回值：max(dp)
 *
 * 为什么需要"以 i 结尾"？
 * - 子序列问题中，需要知道最后一个元素是什么
 * - 这样才能判断下一个元素能否接上
 *
 * 例：LIS
 * - dp[i] = 以 nums[i] 结尾的最长递增子序列长度
 * - 转移：if (nums[j] < nums[i]) dp[i] = max(dp[i], dp[j] + 1)
 * - 返回：max(dp)，不是 dp[n-1]
 *
 * 例：最大子数组和（Kadane）
 * - dp[i] = 以 nums[i] 结尾的最大子数组和
 * - 转移：dp[i] = max(nums[i], dp[i-1] + nums[i])
 * - 返回：max(dp)」
 *
 * 🔄 可能的追问：
 * - 打家劫舍用哪种定义？
 * - 如何判断用哪种？
 */

// ============================================================
// Q5: 怎么优化 DP 的空间复杂度？
// ============================================================

/**
 * 📝 问题：DP 怎么进行空间优化？
 *
 * ✅ 标准答案：
 * 观察状态转移方程，看 dp[i] 只依赖哪些状态：
 * - 只依赖 dp[i-1]：用两个变量滚动
 * - 依赖 dp[i-1] 和 dp[i-2]：用三个变量
 * - 二维依赖上一行：用一维数组滚动
 *
 * ⭐ 加分回答：
 * 「常见的空间优化模式：
 *
 * 1. 一维 DP 优化（斐波那契）
 * // 优化前：O(n)
 * dp[i] = dp[i-1] + dp[i-2]
 *
 * // 优化后：O(1)
 * prev2, prev1, curr
 *
 * 2. 二维 DP 优化为一维（背包）
 * // 优化前：O(n×W)
 * dp[i][j] = max(dp[i-1][j], dp[i-1][j-w] + v)
 *
 * // 优化后：O(W)
 * dp[j] = max(dp[j], dp[j-w] + v)
 *
 * 3. 二维 DP 优化（LCS、编辑距离）
 * // 需要保存 dp[i-1][j-1]
 * // 用一个临时变量保存左上角的值
 *
 * let prev = dp[0];
 * for (let j = 1; j <= m; j++) {
 *   const temp = dp[j];
 *   dp[j] = ... // 使用 prev
 *   prev = temp;
 * }
 *
 * 注意事项：
 * - 优化后遍历顺序可能需要调整
 * - 调试更困难，建议先写出完整版本
 * - 面试中可以先说出完整版本，再提优化」
 *
 * 🔄 可能的追问：
 * - 优化后怎么回溯路径？
 * - 什么情况不能优化？
 */

// ============================================================
// Q6: 最长公共子序列（LCS）怎么解？
// ============================================================

/**
 * 📝 问题：最长公共子序列怎么用 DP 解决？
 *
 * ✅ 标准答案：
 * 定义 dp[i][j] = text1 前 i 个字符和 text2 前 j 个字符的 LCS 长度
 *
 * 状态转移：
 * - 如果 text1[i-1] === text2[j-1]：dp[i][j] = dp[i-1][j-1] + 1
 * - 否则：dp[i][j] = max(dp[i-1][j], dp[i][j-1])
 *
 * 时间 O(nm)，空间 O(nm) 可优化到 O(min(n,m))
 *
 * ⭐ 加分回答：
 * 「LCS 的思维过程：
 *
 *   ""  a  b  c  d  e
 * ""  0  0  0  0  0  0
 *  a  0  1  1  1  1  1
 *  c  0  1  1  2  2  2
 *  e  0  1  1  2  2  3
 *
 * 两种情况的理解：
 * 1. text1[i-1] === text2[j-1]：
 *    - 最后一个字符相同，LCS 长度 +1
 *    - 从左上角 dp[i-1][j-1] 转移
 *
 * 2. text1[i-1] !== text2[j-1]：
 *    - 最后一个字符不同，LCS 不包含其中至少一个
 *    - 取两种情况的最大值
 *
 * 相关问题：
 * - 最短公共超序列 = m + n - LCS
 * - 编辑距离的"不操作"情况类似
 * - Diff 算法基于 LCS
 *
 * 如何回溯路径？
 * - 从 dp[m][n] 开始回溯
 * - 如果字符相同，加入结果
 * - 否则往较大的方向走」
 *
 * 🔄 可能的追问：
 * - 怎么输出具体的子序列？
 * - LCS 和 LIS 有什么关系？
 */

// ============================================================
// Q7: 编辑距离怎么解？
// ============================================================

/**
 * 📝 问题：编辑距离（最小编辑操作数）怎么用 DP 解决？
 *
 * ✅ 标准答案：
 * 定义 dp[i][j] = word1 前 i 个字符转换成 word2 前 j 个字符的最少操作数
 *
 * 状态转移：
 * - 如果 word1[i-1] === word2[j-1]：dp[i][j] = dp[i-1][j-1]（不操作）
 * - 否则：dp[i][j] = min(
 *     dp[i-1][j] + 1,    // 删除
 *     dp[i][j-1] + 1,    // 插入
 *     dp[i-1][j-1] + 1   // 替换
 *   )
 *
 * ⭐ 加分回答：
 * 「编辑距离的理解：
 *
 * 三种操作对应的状态转移：
 *
 *         j-1    j
 *   i-1  替换  → 删除
 *          ↓    ↘
 *   i    插入  → [i][j]
 *
 * - 删除 word1[i-1]：dp[i-1][j] + 1
 * - 在 word1 插入 word2[j-1]：dp[i][j-1] + 1
 * - 替换 word1[i-1] 为 word2[j-1]：dp[i-1][j-1] + 1
 *
 * 初始化：
 * - dp[0][j] = j（空串变成长度 j，需要 j 次插入）
 * - dp[i][0] = i（长度 i 变成空串，需要 i 次删除）
 *
 * 实际应用：
 * - 拼写检查：找最相似的正确单词
 * - 搜索建议：模糊匹配
 * - DNA 序列比对
 * - 前端 Diff 算法的基础」
 *
 * 🔄 可能的追问：
 * - 如何输出具体的操作序列？
 * - 和 LCS 有什么关系？
 */

// ============================================================
// Q8: 买卖股票系列怎么解？
// ============================================================

/**
 * 📝 问题：买卖股票系列问题怎么用 DP 解决？
 *
 * ✅ 标准答案：
 * 用状态机的思路，定义"持有"和"不持有"两个状态：
 * - hold[i] = 第 i 天持有股票的最大利润
 * - cash[i] = 第 i 天不持有股票的最大利润
 *
 * 状态转移：
 * - hold[i] = max(hold[i-1], cash[i-1] - prices[i])（保持或买入）
 * - cash[i] = max(cash[i-1], hold[i-1] + prices[i])（保持或卖出）
 *
 * ⭐ 加分回答：
 * 「买卖股票系列的统一框架：
 *
 *        买入              卖出
 *        ─────►          ─────►
 *  [不持有] ◄───── [持有]
 *        ◄─────
 *         保持
 *
 * 不同变体的处理：
 *
 * 1. 只能买卖一次（Easy）
 *    - 记录历史最低价，计算当前卖出收益
 *
 * 2. 可以买卖无限次（Easy）
 *    - 标准状态机，或者贪心（累加所有上涨）
 *
 * 3. 最多 k 次交易（Hard）
 *    - 增加一维 k：dp[i][k][0/1]
 *
 * 4. 有冷冻期（Medium）
 *    - 增加冷冻状态，卖出后一天不能买入
 *
 * 5. 有手续费（Medium）
 *    - 卖出时减去手续费
 *
 * 空间优化：
 * - 只需要前一天的状态
 * - hold 和 cash 各一个变量即可」
 *
 * 🔄 可能的追问：
 * - 有冷冻期怎么处理？
 * - 最多 k 次交易怎么处理？
 */

// ============================================================
// Q9: 区间 DP 是什么？
// ============================================================

/**
 * 📝 问题：什么是区间 DP？戳气球怎么解？
 *
 * ✅ 标准答案：
 * 区间 DP 是状态定义在区间上的 DP：
 * - dp[i][j] 表示区间 [i, j] 的最优解
 * - 通过枚举分割点，将区间分成更小的子区间
 *
 * 戳气球的关键是逆向思维：
 * - 不考虑"先戳哪个"，考虑"最后戳哪个"
 *
 * ⭐ 加分回答：
 * 「戳气球的思路：
 *
 * 为什么要逆向思维？
 * - 正向：戳掉一个气球后，左右相邻关系变化
 * - 逆向：最后戳掉一个，左右不变（因为已经没了）
 *
 * 定义：
 * dp[i][j] = 戳破 (i, j) 开区间内所有气球的最大收益
 *
 * 转移（枚举最后戳的气球 k）：
 * dp[i][j] = max(dp[i][k] + dp[k][j] + nums[i]*nums[k]*nums[j])
 *
 * 遍历顺序：
 * - 区间长度从小到大
 * - 或者使用记忆化搜索
 *
 * for (let len = 2; len <= n; len++) {
 *   for (let i = 0; i + len <= n; i++) {
 *     const j = i + len;
 *     for (let k = i + 1; k < j; k++) {
 *       dp[i][j] = max(dp[i][j],
 *         dp[i][k] + dp[k][j] + nums[i]*nums[k]*nums[j]);
 *     }
 *   }
 * }
 *
 * 类似题目：
 * - 矩阵链乘法
 * - 合并石子
 * - 最长回文子序列」
 *
 * 🔄 可能的追问：
 * - 区间 DP 的遍历顺序为什么这样？
 * - 能用记忆化搜索吗？
 */

// ============================================================
// Q10: DP 题目怎么调试？
// ============================================================

/**
 * 📝 问题：DP 写完后答案不对，怎么调试？
 *
 * ✅ 标准答案：
 * 1. 打印 dp 数组，检查填表过程
 * 2. 用小例子手算，对比预期
 * 3. 检查初始化是否正确
 * 4. 检查遍历顺序是否正确
 * 5. 检查返回值是否正确
 *
 * ⭐ 加分回答：
 * 「DP 调试清单：
 *
 * 1. 状态定义检查
 *    - dp[i] 的含义是否清晰？
 *    - 是"前 i 个"还是"以 i 结尾"？
 *
 * 2. 初始化检查
 *    - dp[0] 是什么？
 *    - 最值问题：0 还是 Infinity/-Infinity？
 *    - 计数问题：通常 dp[0] = 1
 *
 * 3. 转移方程检查
 *    - 是否覆盖了所有情况？
 *    - 边界条件是否正确？
 *
 * 4. 遍历顺序检查
 *    - 依赖的状态是否已计算？
 *    - 背包问题：遍历方向对吗？
 *
 * 5. 返回值检查
 *    - 返回 dp[n] 还是 max(dp)？
 *    - 无解情况怎么处理？
 *
 * 调试技巧：
 * console.log(dp);
 * - 画表格手算
 * - 用最小的测试用例
 * - 检查边界情况（空数组、单元素）
 *
 * 常见错误：
 * - 数组大小 n vs n+1
 * - 下标 i-1 vs i
 * - 遍历范围 < vs <=」
 *
 * 🔄 可能的追问：
 * - 有没有遇到过难调的 DP 题？
 * - 怎么快速定位问题？
 */

// ============================================================
// 📋 面试问答速查表
// ============================================================

/**
 * ┌─────────────────────────────────────────────────────────────────────────┐
 * │                           面试问答速查表                                 │
 * ├────────────────────────────────────┬────────────────────────────────────┤
 * │           问题类型                 │              核心答案要点           │
 * ├────────────────────────────────────┼────────────────────────────────────┤
 * │ DP 是什么                          │ 记忆化递归，空间换时间               │
 * │ DP vs 贪心                         │ DP 保证全局最优，贪心只看局部        │
 * │ DP 五步法                          │ 状态→转移→初始化→遍历→返回          │
 * │ 0-1 vs 完全背包                    │ 0-1 从后往前，完全从前往后          │
 * │ "前 i 个" vs "以 i 结尾"           │ 背包用前者，子序列用后者            │
 * │ 空间优化                           │ 观察依赖关系，滚动数组/变量         │
 * │ LCS                                │ 相同+1，不同取 max                  │
 * │ 编辑距离                           │ 三操作取 min，相同不操作            │
 * │ 买卖股票                           │ 状态机：持有/不持有                  │
 * │ 区间 DP                            │ 枚举分割点，逆向思维                 │
 * └────────────────────────────────────┴────────────────────────────────────┘
 */

// ============================================================
// 🎯 回答问题的技巧
// ============================================================

/**
 * DP 题目的回答模板：
 *
 * 1. 识别问题类型：
 *    「这是一个[线性/二维/背包/区间/状态机]DP 问题」
 *
 * 2. 说明状态定义：
 *    「dp[i] 表示...」或「dp[i][j] 表示...」
 *
 * 3. 写出转移方程：
 *    「状态转移方程是 dp[i] = ...」
 *
 * 4. 说明初始化和遍历：
 *    「初始化 dp[0] = ...，从前往后遍历」
 *
 * 5. 给出复杂度：
 *    「时间 O(n²)，空间 O(n)，可优化到 O(1)」
 *
 * 示例回答（最长递增子序列）：
 * 「这是一个线性 DP 问题。
 * 状态定义：dp[i] 表示以 nums[i] 结尾的最长递增子序列长度。
 * 转移方程：对于所有 j < i 且 nums[j] < nums[i]，dp[i] = max(dp[j] + 1)。
 * 初始化：所有 dp[i] = 1，因为最短的递增子序列就是元素本身。
 * 返回值：max(dp)，因为最长的可能以任何位置结尾。
 * 时间 O(n²)，空间 O(n)。可以用二分优化到 O(n log n)。」
 */

export {};

