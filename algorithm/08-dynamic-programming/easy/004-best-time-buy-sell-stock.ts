/**
 * 📝 题目：买卖股票的最佳时机
 * 🔗 链接：https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/
 * 🏷️ 难度：Easy
 * 🏷️ 标签：数组、动态规划
 *
 * 📋 题目描述：
 * 给定一个数组 prices，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。
 *
 * 你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。
 * 设计一个算法来计算你所能获取的最大利润。
 *
 * 返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0。
 *
 * 示例：
 * 输入：[7,1,5,3,6,4]
 * 输出：5
 * 解释：在第 2 天（股票价格 = 1）买入，在第 5 天（股票价格 = 6）卖出，最大利润 = 6-1 = 5。
 *
 * 输入：[7,6,4,3,1]
 * 输出：0
 * 解释：股价一直下跌，没有交易。
 */

// ============================================================
// 💡 思路分析：这道题的解法是怎么想出来的？
// ============================================================
//
// 思路一：贪心
// - 遍历数组，记录到目前为止的最低价格
// - 每天计算"今天卖出的利润"，更新最大利润
//
// 思路二：DP
// - dp[i] = 前 i 天能获得的最大利润
// - 第 i 天卖出的利润 = prices[i] - minPrice
// - dp[i] = max(dp[i-1], prices[i] - minPrice)

// ============================================================
// 解法一：贪心（推荐）
// ============================================================
// ⏱️ 时间复杂度：O(n) | 空间复杂度：O(1)

/**
 * 📊 执行过程图解：
 *
 * prices = [7, 1, 5, 3, 6, 4]
 *
 * day 0: price=7, minPrice=7, profit=0
 * day 1: price=1, minPrice=1, profit=0
 * day 2: price=5, minPrice=1, profit=max(0, 5-1)=4
 * day 3: price=3, minPrice=1, profit=max(4, 3-1)=4
 * day 4: price=6, minPrice=1, profit=max(4, 6-1)=5
 * day 5: price=4, minPrice=1, profit=max(5, 4-1)=5
 *
 * 答案：5
 */
function maxProfit(prices: number[]): number {
  let minPrice = Infinity;
  let maxProfit = 0;

  for (const price of prices) {
    if (price < minPrice) {
      // 更新最低买入价格
      minPrice = price;
    } else {
      // 计算今天卖出的利润
      maxProfit = Math.max(maxProfit, price - minPrice);
    }
  }

  return maxProfit;
}

// ============================================================
// 解法二：DP
// ============================================================
// ⏱️ 时间复杂度：O(n) | 空间复杂度：O(1)
function maxProfit_dp(prices: number[]): number {
  let minPrice = prices[0];
  let dp = 0; // dp[i] = 前 i 天的最大利润

  for (let i = 1; i < prices.length; i++) {
    // 状态转移：max(保持前一天的利润, 今天卖出的利润)
    dp = Math.max(dp, prices[i] - minPrice);
    // 更新最低价格
    minPrice = Math.min(minPrice, prices[i]);
  }

  return dp;
}

// ============================================================
// 解法三：通用状态机 DP（为后续股票问题铺垫）
// ============================================================
// ⏱️ 时间复杂度：O(n) | 空间复杂度：O(1)

/**
 * 股票问题的通用框架：
 *
 * dp[i][0] = 第 i 天，手上没有股票的最大利润
 * dp[i][1] = 第 i 天，手上持有股票的最大利润
 *
 * 状态转移：
 * dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])  // 保持或卖出
 * dp[i][1] = max(dp[i-1][1], -prices[i])              // 保持或买入（只能买一次，所以是 -prices[i]）
 */
function maxProfit_state(prices: number[]): number {
  let hold = -Infinity; // 持有股票
  let notHold = 0; // 不持有股票

  for (const price of prices) {
    const newNotHold = Math.max(notHold, hold + price);
    const newHold = Math.max(hold, -price);
    notHold = newNotHold;
    hold = newHold;
  }

  return notHold;
}

// ============================================================
// 🔄 解法对比
// ============================================================
/**
 * | 解法   | 时间  | 空间  | 特点              |
 * |--------|-------|-------|-------------------|
 * | 贪心   | O(n)  | O(1)  | 推荐，最直观      |
 * | DP     | O(n)  | O(1)  | 好理解            |
 * | 状态机 | O(n)  | O(1)  | 通用框架          |
 */

// ============================================================
// ⚠️ 易错点
// ============================================================
/**
 * 1. 买入必须在卖出之前
 *
 * 2. 如果没有盈利机会，返回 0 而不是负数
 *
 * 3. minPrice 初始值设为 Infinity 或 prices[0]
 */

// ============================================================
// 🔗 举一反三：相似题目
// ============================================================
/**
 * - 买卖股票 II → 可以多次交易
 * - 买卖股票 III → 最多两次交易
 * - 买卖股票 IV → 最多 k 次交易
 * - 买卖股票含冷冻期 → 卖出后需等待一天
 * - 买卖股票含手续费 → 每次交易有成本
 */

// ============================================================
// 🏢 前端业务场景
// ============================================================
/**
 * 1. 数据分析：找最佳买卖时机
 * 2. 性能优化：找最大性能提升空间
 */

export { maxProfit, maxProfit_dp, maxProfit_state };
export default maxProfit;

