/**
 * 📝 题目：使用最小花费爬楼梯
 * 🔗 链接：https://leetcode.cn/problems/min-cost-climbing-stairs/
 * 🏷️ 难度：Easy
 * 🏷️ 标签：数组、动态规划
 *
 * 📋 题目描述：
 * 给你一个整数数组 cost，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。
 * 一旦你支付此费用，即可选择向上爬一个或者两个台阶。
 *
 * 你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。
 *
 * 请你计算并返回达到楼梯顶部的最低花费。
 *
 * 示例：
 * 输入：cost = [10,15,20]
 * 输出：15
 * 解释：你将从下标为 1 的台阶开始，支付 15，向上爬两个台阶，到达楼梯顶部。
 *
 * 输入：cost = [1,100,1,1,1,100,1,1,100,1]
 * 输出：6
 */

// ============================================================
// 💡 思路分析：这道题的解法是怎么想出来的？
// ============================================================
//
// 与普通爬楼梯的区别：每一步有花费
//
// dp[i] = 到达第 i 阶的最小花费
//
// 到达第 i 阶，可以从：
// - 第 i-1 阶爬 1 步，花费 dp[i-1] + cost[i-1]
// - 第 i-2 阶爬 2 步，花费 dp[i-2] + cost[i-2]
//
// dp[i] = min(dp[i-1] + cost[i-1], dp[i-2] + cost[i-2])
//
// 注意：顶部是第 n 阶（下标 n），不是第 n-1 阶

// ============================================================
// 解法一：基础 DP
// ============================================================
// ⏱️ 时间复杂度：O(n) | 空间复杂度：O(n)

/**
 * 📊 执行过程图解：
 *
 * cost = [10, 15, 20]
 *        索引: 0   1   2  (顶部是索引3)
 *
 * dp[0] = 0（可以从0开始，不需要花费就能站在0）
 * dp[1] = 0（可以从1开始）
 * dp[2] = min(dp[1]+cost[1], dp[0]+cost[0]) = min(0+15, 0+10) = 10
 * dp[3] = min(dp[2]+cost[2], dp[1]+cost[1]) = min(10+20, 0+15) = 15
 *
 * 答案：15
 */
function minCostClimbingStairs(cost: number[]): number {
  const n = cost.length;
  const dp: number[] = [0, 0];

  for (let i = 2; i <= n; i++) {
    dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);
  }

  return dp[n];
}

// ============================================================
// 解法二：空间优化
// ============================================================
// ⏱️ 时间复杂度：O(n) | 空间复杂度：O(1)
function minCostClimbingStairs_optimized(cost: number[]): number {
  const n = cost.length;
  let prev2 = 0; // dp[i-2]
  let prev1 = 0; // dp[i-1]

  for (let i = 2; i <= n; i++) {
    const curr = Math.min(prev1 + cost[i - 1], prev2 + cost[i - 2]);
    prev2 = prev1;
    prev1 = curr;
  }

  return prev1;
}

// ============================================================
// 解法三：另一种状态定义
// ============================================================
// dp[i] = 从第 i 阶出发到达顶部的最小花费

function minCostClimbingStairs_v2(cost: number[]): number {
  const n = cost.length;

  // 从后往前计算
  let next1 = 0; // 从 n-1 阶出发
  let next2 = 0; // 从 n 阶出发

  for (let i = n - 1; i >= 0; i--) {
    const curr = cost[i] + Math.min(next1, next2);
    next2 = next1;
    next1 = curr;
  }

  // 可以从第 0 阶或第 1 阶开始
  return Math.min(next1, next2);
}

// ============================================================
// 🔄 解法对比
// ============================================================
/**
 * | 解法         | 时间  | 空间  | 特点          |
 * |--------------|-------|-------|---------------|
 * | 基础 DP      | O(n)  | O(n)  | 好理解        |
 * | 空间优化     | O(n)  | O(1)  | 推荐          |
 * | 逆向 DP      | O(n)  | O(1)  | 另一种思路    |
 */

// ============================================================
// ⚠️ 易错点
// ============================================================
/**
 * 1. 顶部位置：
 *    - 顶部是第 n 阶（数组外的位置）
 *    - 不是第 n-1 阶
 *
 * 2. 初始值：
 *    - dp[0] = 0, dp[1] = 0
 *    - 因为可以免费站在第 0 或第 1 阶
 *
 * 3. 状态转移：
 *    - dp[i] = min(dp[i-1] + cost[i-1], dp[i-2] + cost[i-2])
 *    - 注意 cost 的下标
 */

// ============================================================
// 🔗 举一反三：相似题目
// ============================================================
/**
 * - 爬楼梯 → 不带花费
 * - 打家劫舍 → 不能相邻
 */

export {
  minCostClimbingStairs,
  minCostClimbingStairs_optimized,
  minCostClimbingStairs_v2,
};
export default minCostClimbingStairs;

