/**
 * 📝 题目：打家劫舍
 * 🔗 链接：https://leetcode.cn/problems/house-robber/
 * 🏷️ 难度：Easy
 * 🏷️ 标签：数组、动态规划
 *
 * 📋 题目描述：
 * 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，
 * 影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，
 * 如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。
 *
 * 给定一个代表每个房屋存放金额的非负整数数组，计算你不触动警报装置的情况下，
 * 一夜之内能够偷窃到的最高金额。
 *
 * 示例：
 * 输入：[1,2,3,1]
 * 输出：4
 * 解释：偷窃 1 号房屋 (金额 = 1)，然后偷窃 3 号房屋 (金额 = 3)。
 *
 * 输入：[2,7,9,3,1]
 * 输出：12
 * 解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
 */

// ============================================================
// 💡 思路分析：这道题的解法是怎么想出来的？
// ============================================================
//
// 每个房屋有两种选择：偷或不偷
// - 偷第 i 个：不能偷第 i-1 个，金额 = dp[i-2] + nums[i]
// - 不偷第 i 个：金额 = dp[i-1]
//
// dp[i] = 前 i 个房屋能偷的最大金额
// dp[i] = max(dp[i-2] + nums[i], dp[i-1])

// ============================================================
// 解法一：基础 DP
// ============================================================
// ⏱️ 时间复杂度：O(n) | 空间复杂度：O(n)

/**
 * 📊 执行过程图解：
 *
 * nums = [2, 7, 9, 3, 1]
 *
 * dp[0] = 2（只有一间，偷它）
 * dp[1] = max(2, 7) = 7（选金额大的）
 * dp[2] = max(dp[0]+9, dp[1]) = max(11, 7) = 11
 * dp[3] = max(dp[1]+3, dp[2]) = max(10, 11) = 11
 * dp[4] = max(dp[2]+1, dp[3]) = max(12, 11) = 12
 *
 * 答案：12（偷 2, 9, 1）
 */
function rob(nums: number[]): number {
  const n = nums.length;
  if (n === 0) return 0;
  if (n === 1) return nums[0];

  const dp: number[] = [];
  dp[0] = nums[0];
  dp[1] = Math.max(nums[0], nums[1]);

  for (let i = 2; i < n; i++) {
    dp[i] = Math.max(dp[i - 2] + nums[i], dp[i - 1]);
  }

  return dp[n - 1];
}

// ============================================================
// 解法二：空间优化
// ============================================================
// ⏱️ 时间复杂度：O(n) | 空间复杂度：O(1)
function rob_optimized(nums: number[]): number {
  const n = nums.length;
  if (n === 0) return 0;
  if (n === 1) return nums[0];

  let prev2 = nums[0]; // dp[i-2]
  let prev1 = Math.max(nums[0], nums[1]); // dp[i-1]

  for (let i = 2; i < n; i++) {
    const curr = Math.max(prev2 + nums[i], prev1);
    prev2 = prev1;
    prev1 = curr;
  }

  return prev1;
}

// ============================================================
// 🔄 解法对比
// ============================================================
/**
 * | 解法     | 时间  | 空间  | 特点          |
 * |----------|-------|-------|---------------|
 * | 基础 DP  | O(n)  | O(n)  | 好理解        |
 * | 空间优化 | O(n)  | O(1)  | 推荐          |
 */

// ============================================================
// ⚠️ 易错点
// ============================================================
/**
 * 1. 状态定义：dp[i] 是前 i 个房屋的最大金额，不是第 i 个
 *
 * 2. 初始值：
 *    - dp[0] = nums[0]
 *    - dp[1] = max(nums[0], nums[1])，不是 nums[1]
 *
 * 3. 边界处理：n = 0 或 n = 1 的情况
 */

// ============================================================
// 🔗 举一反三：相似题目
// ============================================================
/**
 * - 打家劫舍 II → 房屋成环
 * - 打家劫舍 III → 树形结构
 * - 删除并获得点数 → 类似思路
 */

// ============================================================
// 🏢 前端业务场景
// ============================================================
/**
 * 1. 资源调度：不能连续使用相同资源
 * 2. 广告投放：相邻位置不能放同类广告
 */

export { rob, rob_optimized };
export default rob;

