/**
 * 📝 题目：爬楼梯
 * 🔗 链接：https://leetcode.cn/problems/climbing-stairs/
 * 🏷️ 难度：Easy
 * 🏷️ 标签：记忆化搜索、数学、动态规划
 *
 * 📋 题目描述：
 * 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
 * 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
 *
 * 示例：
 * 输入：n = 2
 * 输出：2
 * 解释：有两种方法：1+1 和 2
 *
 * 输入：n = 3
 * 输出：3
 * 解释：有三种方法：1+1+1、1+2 和 2+1
 */

// ============================================================
// 💡 思路分析：这道题的解法是怎么想出来的？
// ============================================================
//
// DP 五步法：
//
// 1. 定义状态：dp[i] = 到达第 i 阶的方法数
//
// 2. 状态转移：
//    到达第 i 阶，可以从：
//    - 第 i-1 阶爬 1 步
//    - 第 i-2 阶爬 2 步
//    所以 dp[i] = dp[i-1] + dp[i-2]
//
// 3. 初始条件：dp[1] = 1, dp[2] = 2
//
// 4. 遍历顺序：从 3 到 n
//
// 5. 返回值：dp[n]

// ============================================================
// 解法一：基础 DP
// ============================================================
// ⏱️ 时间复杂度：O(n) | 空间复杂度：O(n)

/**
 * 📊 执行过程图解：
 *
 * n = 5
 *
 * dp[1] = 1
 * dp[2] = 2
 * dp[3] = dp[2] + dp[1] = 3
 * dp[4] = dp[3] + dp[2] = 5
 * dp[5] = dp[4] + dp[3] = 8
 *
 * 斐波那契数列！
 */
function climbStairs(n: number): number {
  if (n <= 2) return n;

  const dp: number[] = [0, 1, 2];

  for (let i = 3; i <= n; i++) {
    dp[i] = dp[i - 1] + dp[i - 2];
  }

  return dp[n];
}

// ============================================================
// 解法二：空间优化
// ============================================================
// ⏱️ 时间复杂度：O(n) | 空间复杂度：O(1)
function climbStairs_optimized(n: number): number {
  if (n <= 2) return n;

  let prev2 = 1; // dp[i-2]
  let prev1 = 2; // dp[i-1]

  for (let i = 3; i <= n; i++) {
    const curr = prev1 + prev2;
    prev2 = prev1;
    prev1 = curr;
  }

  return prev1;
}

// ============================================================
// 🔄 解法对比
// ============================================================
/**
 * | 解法     | 时间  | 空间  | 特点          |
 * |----------|-------|-------|---------------|
 * | 基础 DP  | O(n)  | O(n)  | 好理解        |
 * | 空间优化 | O(n)  | O(1)  | 推荐          |
 */

// ============================================================
// ⚠️ 易错点
// ============================================================
/**
 * 1. 初始值：dp[1] = 1, dp[2] = 2，不是 dp[0] = 0, dp[1] = 1
 *
 * 2. 边界：n = 1 或 n = 2 时直接返回
 *
 * 3. 本质：这就是斐波那契数列，只是定义不同
 */

// ============================================================
// 🔗 举一反三：相似题目
// ============================================================
/**
 * - 斐波那契数 → 完全相同
 * - 使用最小花费爬楼梯 → 加上花费
 * - 打家劫舍 → 不能相邻
 */

// ============================================================
// 🏢 前端业务场景
// ============================================================
/**
 * 1. 步骤计数：用户操作路径统计
 * 2. 分页方案：页面跳转方式计数
 */

export { climbStairs, climbStairs_optimized };
export default climbStairs;

