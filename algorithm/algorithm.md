# 🎯 前端算法面试通关指南

> 面向有一定基础的前端开发者，系统性准备算法面试

## 📊 学习路线图

```
                    ┌─────────────────────┐
                    │     Step 00         │
                    │  前置知识 & 方法论   │
                    │  复杂度、数学、建模   │
                    └─────────────────────┘
                              │
                              ▼
Step 01 ──► Step 02 ──► Step 03 ──► Step 04
数组双指针   哈希与字符串   链表       栈与队列
    │           │           │           │
    └───────────┴───────────┴───────────┘
                    基础篇
                      │
                      ▼
Step 05 ──► Step 06 ──► Step 07 ──► Step 08
 二叉树      二分查找     回溯算法    动态规划
    │           │           │           │
    └───────────┴───────────┴───────────┘
                    进阶篇
                      │
                      ▼
         Step 09 ──► Step 10 ──► Step 11
        堆/优先队列     图论       字典树
            │           │           │
            └───────────┴───────────┘
                    高阶篇（资深岗位区分度）
```

---

## 🎯 学习目标：能力层级

### 我们要达到的境界

```
Level 1: 我做过这道题 ────────────────► 靠记忆，换个数字就不会了
Level 2: 我会这类题的模板 ────────────► 能套路，但遇到变形题会卡壳
Level 3: 我能识别问题类型并归约 ──────► 看到新题能变形为熟悉的模型 ✅ 目标
Level 4: 算法思维融入日常开发 ────────► 用算法思维优化业务代码 🚀 进阶
```

### 核心能力：问题归约

看到一个新题，能在有限时间内：

1. **抽象识别** - 这是哪一类问题？（图？区间？DP？）
2. **快速归约** - 变形为熟悉的通用模型/套路
3. **代码实现** - 写出可读性强、可 debug 的代码
4. **复杂度分析** - 清楚说明时间/空间复杂度和 trade-off
5. **业务关联** - 能举出前端业务场景的应用

### 问题归约思维训练

遇到陌生题时，下意识去问：

| 归约方向 | 判断信号 | 典型例子 |
|---------|---------|---------|
| **图问题** | 依赖关系、路径、可达性 | 课程表 → 拓扑排序 |
| **区间问题** | 排序后双指针/扫描线 | 合并区间、会议室 |
| **DP 状态转移** | 最优解、方案数、可行性 | 背包、子序列 |
| **滑动窗口** | 连续子数组/子串、最长/最短 | 无重复最长子串 |
| **单调栈/队列** | 下一个更大/更小元素 | 每日温度、滑动窗口最大值 |
| **堆/Top K** | 第K大/小、动态维护极值 | 数据流中位数、合并K个链表 |
| **并查集** | 连通性、分组、合并集合 | 岛屿数量、朋友圈 |
| **字典树** | 前缀匹配、自动补全、词典 | 搜索提示、敏感词过滤 |

```
💡 不是「我看过这道题」
   而是「我能把这道题变形为我见过的那类问题」
```

---

## 📚 学习大纲

### 前置篇（Step 00）⭐ 建议先读

| 步骤 | 主题 | 核心内容 | 重要性 | 预计时间 |
|:---:|------|----------|:-------:|:-------:|
| 00 | [前置知识](./00-prerequisites/) | 复杂度分析、基础数学、问题建模、解题方法论、面试技巧 | ⭐⭐⭐⭐⭐ | 3-5天 |

> 💡 **强烈建议**：先通读前置知识，建立系统认知，后续学习事半功倍。

### 基础篇（Step 01 - 04）

| 步骤 | 主题 | 核心内容 | 面试频率 | 预计时间 |
|:---:|------|----------|:-------:|:-------:|
| 01 | [数组与双指针](./01-array/) | 双指针、滑动窗口、前缀和 | ⭐⭐⭐⭐⭐ | 3天 |
| 02 | [哈希表与字符串](./02-hash-string/) | Map/Set、两数之和、异位词、回文 | ⭐⭐⭐⭐⭐ | 3天 |
| 03 | [链表](./03-linked-list/) | 反转、环检测、合并、快慢指针 | ⭐⭐⭐⭐⭐ | 2天 |
| 04 | [栈与队列](./04-stack-queue/) | 有效括号、单调栈、滑动窗口最大值 | ⭐⭐⭐⭐ | 2天 |

### 进阶篇（Step 05 - 08）

| 步骤 | 主题 | 核心内容 | 面试频率 | 预计时间 |
|:---:|------|----------|:-------:|:-------:|
| 05 | [二叉树](./05-binary-tree/) | 遍历、递归、BFS/DFS、构造树 | ⭐⭐⭐⭐⭐ | 4天 |
| 06 | [二分查找](./06-binary-search/) | 标准二分、搜索边界、旋转数组 | ⭐⭐⭐⭐⭐ | 2天 |
| 07 | [回溯算法](./07-backtracking/) | 排列、组合、子集、剪枝优化 | ⭐⭐⭐⭐ | 3天 |
| 08 | [动态规划](./08-dynamic-programming/) | 背包问题、子序列、路径问题 | ⭐⭐⭐⭐⭐ | 5天 |

### 高阶篇（Step 09 - 11）🔥 资深岗位区分度

| 步骤 | 主题 | 核心内容 | 面试频率 | 预计时间 |
|:---:|------|----------|:-------:|:-------:|
| 09 | [堆与优先队列](./09-heap/) | 堆的实现、Top K、数据流问题、多路归并 | ⭐⭐⭐⭐ | 3天 |
| 10 | [图论](./10-graph/) | BFS/DFS、拓扑排序、最短路径、并查集 | ⭐⭐⭐⭐ | 4天 |
| 11 | [字典树](./11-trie/) | 前缀树实现、搜索提示、单词匹配、敏感词过滤 | ⭐⭐⭐ | 2天 |

**总计约 36-38 天**，每天 1-2 小时（含前置知识 3-5 天）

---

## 🎯 章节内容设计

### 内容优先级（面试导向）

| 优先级 | 内容 | 重要性 | 说明 |
|:-----:|------|:-----:|------|
| P0 | **适用场景 / 信号词** | ⭐⭐⭐⭐⭐ | 看到题目能立刻判断用什么算法 |
| P0 | **代码模板** | ⭐⭐⭐⭐⭐ | 面试时能快速写出骨架代码 |
| P0 | **问题归类** | ⭐⭐⭐⭐⭐ | 理解一个问题 → 解决一类问题 |
| P1 | **多解法对比** | ⭐⭐⭐⭐ | 暴力→优化的思考路径，解法间的差异 |
| P1 | **复杂度分析** | ⭐⭐⭐⭐ | 面试官必问 |
| P1 | **易错点 / 边界条件** | ⭐⭐⭐⭐ | 避免现场翻车 |
| P2 | **前端业务场景** | ⭐⭐⭐ | 算法在实际开发中的应用 |
| P2 | **概念原理** | ⭐⭐⭐ | 简洁即可，不需要太学术 |

### 标准章节结构

```typescript
// ========== 1. 概念速览 ==========
// - 是什么？一句话定义
// - 核心思想
// - 如果某些难以通过文字理解的可以通过 Mermaid 流程图或者图片形式表达

// ========== 2. 🎯 适用场景 ==========
// - 什么时候用？
// - 题目中的「信号词」
// - 典型问题特征

// ========== 3. 问题归类 ==========
// - 这类问题的通用模型
// - 变体题目如何识别
// - 与其他算法的关联

// ========== 4. 代码模板 ==========
// - 标准模板
// - 常见变体

// ========== 5. 复杂度分析 ==========
// - 时间复杂度
// - 空间复杂度
// - 不同解法的 trade-off

// ========== 6. ⚠️ 易错点 ==========
// - 边界条件
// - 常见 bug
// - 面试踩坑点

// ========== 7. 🏢 前端业务场景 ==========
// - 这类算法在前端开发中的实际应用
// - 举例说明
```

---

## 📁 文件结构

```
📁 XX-topic/
├── index.ts              # 核心内容（概念+场景+模板+归类）
│
├── easy/                 # 简单题（3-4道）
│   ├── 001-two-sum.ts
│   ├── 002-xxx.ts
│   └── ...
│
├── medium/               # 中等题（5-8道）
│   ├── 001-xxx.ts
│   ├── 002-xxx.ts
│   └── ...
│
├── hard/                 # 困难题（2-4道）
│   ├── 001-xxx.ts
│   └── ...
│
└── summary.ts            # 归纳总结：这类问题的通用解法
```

**每道题一个文件的好处**：
- 📂 结构清晰，便于查找和复习
- 🔍 Git 历史更清晰，方便追踪学习进度
- 📝 每道题可以写得更详细，不用担心文件过长

---

## 📊 习题设计

### 每个专题：10-16 道精选题

```
总计 10-16 道题

├── Easy:   3-4 道  ──► 理解基础，建立信心
├── Medium: 5-8 道  ──► 核心题型，必须掌握
└── Hard:   2-4 道  ──► 挑战进阶，提升上限
```

### 选题标准

1. **高频优先** - LeetCode 热题 HOT 100、面试高频题
2. **典型代表** - 能代表该类型的经典题目
3. **有变体价值** - 一道题能延伸出多道相似题
4. **覆盖全面** - 涵盖该专题的主要技巧点

### 每道题目格式（多解法 + 思路来源）

```typescript
/**
 * 📝 题目：两数之和
 * 🔗 链接：https://leetcode.cn/problems/two-sum/
 * 🏷️ 难度：Easy
 * 🏷️ 标签：哈希表、数组
 */

// ============================================================
// 💡 思路分析：这道题的解法是怎么想出来的？
// ============================================================
//
// 1. 最直观的想法：暴力枚举所有两数组合 → O(n²)
// 2. 优化思考：如何避免重复遍历？
//    - 已知 target 和当前数 nums[i]
//    - 需要找的数 = target - nums[i]
//    - 「查找」操作 → 哈希表 O(1)
// 3. 得出优化解法：一边遍历，一边用哈希表记录

// ============================================================
// 解法一：暴力枚举
// ============================================================
// ⏱️ 时间复杂度：O(n²) | 空间复杂度：O(1)
function twoSum_v1(nums: number[], target: number): number[] {
  for (let i = 0; i < nums.length; i++) {
    for (let j = i + 1; j < nums.length; j++) {
      if (nums[i] + nums[j] === target) {
        return [i, j];
      }
    }
  }
  return [];
}

// ============================================================
// 解法二：哈希表（推荐）
// ============================================================
// ⏱️ 时间复杂度：O(n) | 空间复杂度：O(n)
// 💡 优化点：用空间换时间，哈希表实现 O(1) 查找
function twoSum_v2(nums: number[], target: number): number[] {
  const map = new Map<number, number>();
  for (let i = 0; i < nums.length; i++) {
    const complement = target - nums[i];
    if (map.has(complement)) {
      return [map.get(complement)!, i];
    }
    map.set(nums[i], i);
  }
  return [];
}

// ============================================================
// 🔄 解法对比
// ============================================================
// | 解法 | 时间 | 空间 | 适用场景 |
// |------|------|------|---------|
// | 暴力 | O(n²) | O(1) | 数据量小、空间受限 |
// | 哈希 | O(n) | O(n) | 大多数场景（推荐）|

// ============================================================
// ⚠️ 易错点
// ============================================================
// 1. 同一元素不能使用两次 → 先查再存
// 2. 返回的是下标，不是值
// 3. 可能有多组解，题目要求返回任意一组

// ============================================================
// 🔗 举一反三：相似题目
// ============================================================
// - 三数之和（排序 + 双指针）
// - 四数之和（排序 + 双指针）
// - 两数之和 II（有序数组，双指针）

// ============================================================
// 🏢 前端业务场景
// ============================================================
// 1. 购物车凑单：找出哪些商品组合刚好满足满减金额
// 2. 表单联动：根据已选值快速查找关联选项
// 3. 数据匹配：在两个数据源中找出匹配的记录
```

---

## 🔄 融会贯通：理解一个问题 → 解决一类问题

### 每个专题的归纳总结（summary.ts）

```typescript
/**
 * 📚 双指针问题归类
 *
 * 当你看到以下特征，考虑用双指针：
 */

// ============================================================
// 类型一：对撞指针（两端向中间）
// ============================================================
// 信号词：有序数组、找两个数、回文判断
// 典型题：两数之和II、三数之和、接雨水、盛水最多的容器

// ============================================================
// 类型二：快慢指针（同向不同速）
// ============================================================
// 信号词：链表环、中点、倒数第N个
// 典型题：环形链表、链表中点、删除倒数第N个节点

// ============================================================
// 类型三：滑动窗口（同向，窗口伸缩）
// ============================================================
// 信号词：连续子数组/子串、最长/最短、包含/不包含
// 典型题：无重复最长子串、最小覆盖子串、长度最小的子数组

// ============================================================
// 🧠 问题变形识别
// ============================================================
//
// 看到「最长连续xxx」→ 滑动窗口
// 看到「有序 + 找两数」→ 对撞指针
// 看到「原地去重/移动」→ 快慢指针
//
// 一些"怪题"的本质：
// - 接雨水 = 对撞指针 + 预处理（或单调栈）
// - 最小覆盖子串 = 滑动窗口 + 哈希表计数
// - 盛水最多的容器 = 对撞指针 + 贪心（移动较小的边）
```

---

## 📈 学习进度

### 前置篇
- [x] Step 00: 前置知识 ✅
  - 复杂度分析、基础数学、问题建模思维、解题方法论、面试技巧

### 基础篇 & 进阶篇
- [x] Step 01: 数组与双指针 ✅
- [x] Step 02: 哈希表与字符串 ✅
- [x] Step 03: 链表 ✅
- [x] Step 04: 栈与队列 ✅
- [x] Step 05: 二叉树 ✅
- [x] Step 06: 二分查找 ✅
- [x] Step 07: 回溯算法 ✅
- [x] Step 08: 动态规划 ✅

### 高阶篇 🔥
- [ ] Step 09: 堆与优先队列
- [ ] Step 10: 图论
- [ ] Step 11: 字典树

---

## 💡 学习建议

### 面试算法三步法

```
1️⃣ 理解题意 ──► 2️⃣ 找到规律 ──► 3️⃣ 代码实现
     │               │               │
  复述题目        暴力解法         边界处理
  确认边界        优化思路         测试用例
```

### 刷题策略

1. **先理解，再刷题** - 每个专题先掌握核心模板
2. **分类刷题** - 按专题集中练习，形成肌肉记忆
3. **限时练习** - Easy 10分钟，Medium 20分钟，Hard 40分钟
4. **总结复盘** - 做完一道总结一道，不贪多
5. **变形思考** - 每道题想想能否变形为其他问题

### 面试技巧

- 🗣️ **边写边说** - 让面试官了解你的思路
- 🤔 **先暴力后优化** - 先写出来，再考虑优化
- ✅ **主动测试** - 用例子验证代码正确性
- ❓ **大胆提问** - 不确定时主动询问面试官
- 🔄 **主动对比** - 说出不同解法的 trade-off

---

## 🔗 推荐资源

- [LeetCode 中国](https://leetcode.cn/)
- [代码随想录](https://programmercarl.com/)
- [labuladong 的算法小抄](https://labuladong.github.io/algo/)

---

## 📋 题目总览

<details>
<summary>点击展开全部 140+ 道题目列表</summary>

### Step 01: 数组与双指针（13 道）
| 难度 | 题目 | 关键技巧 |
|:---:|------|---------|
| Easy | 两数之和 II | 对撞指针 |
| Easy | 移动零 | 快慢指针 |
| Easy | 删除有序数组中的重复项 | 快慢指针 |
| Easy | 合并两个有序数组 | 逆向双指针 |
| Medium | 三数之和 | 排序+双指针 |
| Medium | 盛最多水的容器 | 对撞指针 |
| Medium | 无重复字符的最长子串 | 滑动窗口 |
| Medium | 长度最小的子数组 | 滑动窗口 |
| Medium | 和为K的子数组 | 前缀和+哈希 |
| Medium | 除自身以外数组的乘积 | 前缀积 |
| Hard | 接雨水 | 双指针/单调栈 |
| Hard | 最小覆盖子串 | 滑动窗口 |
| Hard | 缺失的第一个正数 | 原地哈希 |

### Step 02: 哈希表与字符串（12 道）
| 难度 | 题目 | 关键技巧 |
|:---:|------|---------|
| Easy | 两数之和 | 哈希表 |
| Easy | 有效的字母异位词 | 计数 |
| Easy | 验证回文串 | 双指针 |
| Easy | 字符串中的第一个唯一字符 | 计数 |
| Medium | 字母异位词分组 | 排序+哈希 |
| Medium | 最长回文子串 | 中心扩展/DP |
| Medium | 找到字符串中所有字母异位词 | 滑动窗口 |
| Medium | 最长连续序列 | 哈希集合 |
| Medium | 前K个高频元素 | 哈希+堆 |
| Medium | 字符串相乘 | 模拟 |
| Hard | 串联所有单词的子串 | 滑动窗口+哈希 |
| Hard | 回文对 | 字典树/哈希 |

### Step 03: 链表（13 道）
| 难度 | 题目 | 关键技巧 |
|:---:|------|---------|
| Easy | 反转链表 | 迭代/递归 |
| Easy | 合并两个有序链表 | 虚拟头节点 |
| Easy | 环形链表 | 快慢指针 |
| Easy | 回文链表 | 快慢+反转 |
| Medium | 两数相加 | 模拟进位 |
| Medium | 删除链表的倒数第N个结点 | 快慢指针 |
| Medium | 环形链表 II | 快慢指针 |
| Medium | 排序链表 | 归并排序 |
| Medium | 重排链表 | 找中点+反转+合并 |
| Medium | 复制带随机指针的链表 | 哈希/原地复制 |
| Hard | 合并K个升序链表 | 分治/堆 |
| Hard | K个一组翻转链表 | 分组反转 |
| Hard | LRU缓存 | 哈希+双向链表 |

### Step 04: 栈与队列（13 道）
| 难度 | 题目 | 关键技巧 |
|:---:|------|---------|
| Easy | 有效的括号 | 栈 |
| Easy | 用栈实现队列 | 双栈 |
| Easy | 用队列实现栈 | 单/双队列 |
| Easy | 最小栈 | 辅助栈 |
| Medium | 每日温度 | 单调栈 |
| Medium | 逆波兰表达式求值 | 栈 |
| Medium | 字符串解码 | 栈 |
| Medium | 下一个更大元素 II | 单调栈+循环 |
| Medium | 简化路径 | 栈 |
| Medium | 移掉K位数字 | 单调栈 |
| Hard | 柱状图中最大的矩形 | 单调栈 |
| Hard | 滑动窗口最大值 | 单调队列 |
| Hard | 接雨水 | 单调栈 |

### Step 05: 二叉树（13 道）
| 难度 | 题目 | 关键技巧 |
|:---:|------|---------|
| Easy | 二叉树的最大深度 | 递归/BFS |
| Easy | 翻转二叉树 | 递归 |
| Easy | 对称二叉树 | 递归/迭代 |
| Easy | 路径总和 | 递归 |
| Easy | 二叉树的前序遍历 | 递归/迭代 |
| Medium | 二叉树的层序遍历 | BFS |
| Medium | 验证二叉搜索树 | 中序遍历 |
| Medium | 二叉树的最近公共祖先 | 递归 |
| Medium | 从前序与中序遍历序列构造二叉树 | 分治 |
| Medium | 二叉树展开为链表 | 前序遍历 |
| Medium | 二叉搜索树中第K小的元素 | 中序遍历 |
| Hard | 二叉树中的最大路径和 | 递归 |
| Hard | 二叉树的序列化与反序列化 | BFS/DFS |

### Step 06: 二分查找（12 道）
| 难度 | 题目 | 关键技巧 |
|:---:|------|---------|
| Easy | 二分查找 | 标准二分 |
| Easy | 搜索插入位置 | 左边界 |
| Easy | x的平方根 | 答案二分 |
| Easy | 第一个错误的版本 | 左边界 |
| Medium | 在排序数组中查找元素的第一个和最后一个位置 | 左右边界 |
| Medium | 搜索旋转排序数组 | 判断有序半边 |
| Medium | 寻找旋转排序数组中的最小值 | 找旋转点 |
| Medium | 寻找峰值 | 局部二分 |
| Medium | 爱吃香蕉的珂珂 | 答案二分 |
| Medium | 搜索二维矩阵 | 坐标转换 |
| Hard | 寻找两个正序数组的中位数 | 分割位置 |
| Hard | 分割数组的最大值 | 答案二分 |

### Step 07: 回溯算法（13 道）
| 难度 | 题目 | 关键技巧 |
|:---:|------|---------|
| Easy | 字母大小写全排列 | 子集变体 |
| Easy | 二进制手表 | 组合 |
| Medium | 子集 | start参数 |
| Medium | 子集 II | 排序去重 |
| Medium | 全排列 | used数组 |
| Medium | 全排列 II | 排序去重 |
| Medium | 组合总和 | 可重复选 |
| Medium | 组合总和 II | 不可重复+去重 |
| Medium | 电话号码的字母组合 | 多选择集 |
| Medium | 分割回文串 | 分割+验证 |
| Hard | N皇后 | 约束满足 |
| Hard | 解数独 | 约束满足 |
| Hard | 单词搜索 II | 字典树+回溯 |

### Step 08: 动态规划（18 道）
| 难度 | 题目 | 关键技巧 |
|:---:|------|---------|
| Easy | 爬楼梯 | 斐波那契 |
| Easy | 打家劫舍 | 不相邻选择 |
| Easy | 最大子数组和 | Kadane |
| Easy | 买卖股票的最佳时机 | 记录最小值 |
| Easy | 使用最小花费爬楼梯 | 带花费 |
| Medium | 不同路径 | 网格DP |
| Medium | 最小路径和 | 网格DP |
| Medium | 零钱兑换 | 完全背包 |
| Medium | 最长递增子序列 | 以i结尾 |
| Medium | 最长公共子序列 | 两序列DP |
| Medium | 单词拆分 | 存在性DP |
| Medium | 分割等和子集 | 0-1背包 |
| Medium | 打家劫舍 II | 环形处理 |
| Medium | 解码方法 | 类似爬楼梯 |
| Medium | 买卖股票 II | 多次交易 |
| Hard | 编辑距离 | 增删改 |
| Hard | 戳气球 | 区间DP |
| Hard | 正则表达式匹配 | 复杂转移 |

---

## 🔥 高阶篇

### Step 09: 堆与优先队列（12 道）
| 难度 | 题目 | 关键技巧 |
|:---:|------|---------|
| Easy | 最后一块石头的重量 | 最大堆 |
| Easy | 第K大的元素（快速选择版） | 快速选择 |
| Medium | 数组中的第K个最大元素 | 最小堆/快速选择 |
| Medium | 前K个高频元素 | 哈希+堆 |
| Medium | 根据字符出现频率排序 | 桶排序/堆 |
| Medium | 查找和最小的K对数字 | 多路归并 |
| Medium | 任务调度器 | 贪心+堆 |
| Medium | 最接近原点的K个点 | 最大堆 |
| Hard | 合并K个升序链表 | 最小堆/分治 |
| Hard | 数据流的中位数 | 对顶堆 |
| Hard | 滑动窗口最大值（堆解法） | 延迟删除 |
| Hard | IPO | 贪心+双堆 |

### Step 10: 图论（15 道）
| 难度 | 题目 | 关键技巧 |
|:---:|------|---------|
| Easy | 找到小镇的法官 | 入度出度 |
| Medium | 岛屿数量 | DFS/BFS/并查集 |
| Medium | 被围绕的区域 | 边界DFS |
| Medium | 克隆图 | DFS+哈希 |
| Medium | 课程表 | 拓扑排序(BFS) |
| Medium | 课程表 II | 拓扑排序(输出顺序) |
| Medium | 冗余连接 | 并查集 |
| Medium | 省份数量 | 并查集/DFS |
| Medium | 腐烂的橘子 | 多源BFS |
| Medium | 最小基因变化 | BFS |
| Medium | 单词接龙 | BFS |
| Medium | 网络延迟时间 | Dijkstra |
| Hard | 单词接龙 II | BFS+回溯 |
| Hard | 重新安排行程 | 欧拉路径 |
| Hard | 外星文字典 | 拓扑排序 |

### Step 11: 字典树（10 道）
| 难度 | 题目 | 关键技巧 |
|:---:|------|---------|
| Easy | 最长公共前缀（Trie解法） | 前缀树 |
| Medium | 实现 Trie (前缀树) | 基础实现 |
| Medium | 添加与搜索单词 | Trie+DFS |
| Medium | 键值映射 | Trie+值存储 |
| Medium | 单词替换 | 前缀匹配 |
| Medium | 数组中两个数的最大异或值 | 二进制Trie |
| Medium | 连接词 | Trie+DP |
| Hard | 单词搜索 II | Trie+回溯 |
| Hard | 回文对 | Trie/哈希 |
| Hard | 数据流中的前K个高频单词 | Trie+堆 |

</details>

---

