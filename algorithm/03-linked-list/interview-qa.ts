/**
 * ============================================================
 * 📚 链表 - 面试高频问答
 * ============================================================
 *
 * 本文件包含链表相关的面试高频问题，每个问题包含：
 * 1. 问题本身
 * 2. 标准答案
 * 3. 加分回答（展示深度理解）
 * 4. 追问方向
 */

// ============================================================
// Q1: 链表反转的迭代和递归有什么区别？
// ============================================================

/**
 * 📝 问题：链表反转用迭代和递归分别怎么实现？有什么区别？
 *
 * ✅ 标准答案：
 *
 * 迭代法：
 * - 维护 prev、curr、next 三个指针
 * - 遍历链表，逐个反转指针方向
 * - 时间 O(n)，空间 O(1)
 *
 * 递归法：
 * - 先递归到链表末尾
 * - 回溯时反转指针
 * - 时间 O(n)，空间 O(n)（递归栈）
 *
 * ⭐ 加分回答：
 * 「两种方法的本质思路不同：
 *
 * 迭代是"从前往后"处理：
 * - 每次把当前节点的 next 指向前一个节点
 * - 然后三个指针一起向后移动
 *
 * 递归是"从后往前"处理：
 * - 先递归到最后一个节点（作为新的头）
 * - 回溯时让 head.next.next = head（后一个节点指向自己）
 * - 然后断开原来的连接 head.next = null
 *
 * 实际面试中推荐迭代法，因为：
 * 1. 空间复杂度更优
 * 2. 不用担心栈溢出（链表很长时）
 * 3. 更容易扩展（如反转部分链表）
 *
 * 但递归法代码更简洁，展示对递归的理解。」
 *
 * 🔄 可能的追问：
 * - 如何反转链表的一部分？
 * - K 个一组翻转怎么做？
 */

// ============================================================
// Q2: 快慢指针为什么能检测环？
// ============================================================

/**
 * 📝 问题：为什么快慢指针能检测链表是否有环？怎么找到环的入口？
 *
 * ✅ 标准答案：
 *
 * 检测环：
 * - 快指针每次走 2 步，慢指针每次走 1 步
 * - 如果有环，快指针一定会追上慢指针（在环内相遇）
 * - 如果无环，快指针会先到达 null
 *
 * 找环入口：
 * - 相遇后，让一个指针从头开始
 * - 两个指针都每次走 1 步
 * - 再次相遇的地方就是环入口
 *
 * ⭐ 加分回答：
 * 「数学证明：
 *
 * 设：
 * - a = 头到环入口的距离
 * - b = 环入口到相遇点的距离
 * - c = 环的周长
 *
 * 相遇时：
 * - slow 走了 a + b 步
 * - fast 走了 a + b + n*c 步（在环里多转了 n 圈）
 * - fast = 2 * slow，所以 a + b + n*c = 2(a + b)
 * - 整理得：a = n*c - b = (n-1)*c + (c-b)
 *
 * 这意味着：从头走 a 步 = 从相遇点走 (n-1) 圈 + (c-b) 步
 * 而 c-b 正好是相遇点到环入口的距离！
 *
 * 所以两个指针同时走，会在环入口相遇。
 *
 * 这个技巧还用在"找重复数字"（Floyd 判圈法）中。」
 *
 * 🔄 可能的追问：
 * - 如何计算环的长度？（相遇后继续走直到再次相遇）
 * - 快乐数问题和这个有什么关系？
 */

// ============================================================
// Q3: 虚拟头节点有什么用？
// ============================================================

/**
 * 📝 问题：什么是虚拟头节点？什么时候用？
 *
 * ✅ 标准答案：
 * 虚拟头节点（dummy node）是在链表头部添加的一个额外节点，
 * 它的 next 指向真正的头节点。
 *
 * 使用场景：
 * 1. 可能删除头节点：删除时不用特殊处理
 * 2. 可能在头部插入：统一插入逻辑
 * 3. 合并链表：不确定哪个是头
 * 4. 两数相加：结果链表从头开始构建
 *
 * ⭐ 加分回答：
 * 「虚拟头节点的本质是统一边界情况的处理。
 *
 * 没有 dummy 时：
 * ```
 * if (head.val === target) {
 *   head = head.next;  // 特殊处理头节点
 * } else {
 *   // 处理其他节点
 * }
 * ```
 *
 * 有 dummy 时：
 * ```
 * dummy.next = head;
 * // 所有节点统一处理
 * return dummy.next;
 * ```
 *
 * 使用 dummy 的注意点：
 * 1. 最后返回 dummy.next，不是 dummy
 * 2. dummy 的值可以是任意的（通常是 0）
 * 3. 遍历时从 dummy.next 开始，或者用 dummy 作为 prev
 *
 * 很多链表题目都可以用 dummy 简化代码，
 * 如果不确定要不要用，用了一般不会错。」
 *
 * 🔄 可能的追问：
 * - dummy 节点会造成内存泄漏吗？（不会，函数结束就回收）
 * - 有没有不该用 dummy 的场景？
 */

// ============================================================
// Q4: 链表排序用什么算法？
// ============================================================

/**
 * 📝 问题：如何对链表进行排序？时间复杂度多少？
 *
 * ✅ 标准答案：
 * 链表排序推荐使用归并排序：
 * 1. 用快慢指针找到中点
 * 2. 断开链表分成两半
 * 3. 递归排序两半
 * 4. 合并两个有序链表
 *
 * 时间复杂度：O(n log n)
 * 空间复杂度：O(log n)（递归栈）或 O(1)（迭代）
 *
 * ⭐ 加分回答：
 * 「为什么链表不用快速排序？
 *
 * 1. 快速排序需要随机访问：链表是 O(n)，数组是 O(1)
 * 2. partition 操作在链表上很慢
 *
 * 为什么归并排序适合链表？
 *
 * 1. 找中点：快慢指针 O(n)
 * 2. 分割：修改指针 O(1)
 * 3. 合并：只需要改指针，不需要额外空间
 *
 * 而数组归并排序需要 O(n) 额外空间来合并。
 *
 * 如果要求 O(1) 空间，可以用迭代式归并：
 * 1. 先两两合并，再四四合并，再八八合并...
 * 2. 每轮用 O(n) 时间，共 log n 轮
 *
 * 还有一种方法是插入排序，时间 O(n²)，空间 O(1)，
 * 适合几乎有序的链表。」
 *
 * 🔄 可能的追问：
 * - 能用堆排序吗？（不适合，需要随机访问）
 * - 迭代归并排序怎么实现？
 */

// ============================================================
// Q5: 如何找链表的倒数第 K 个节点？
// ============================================================

/**
 * 📝 问题：如何找到链表的倒数第 K 个节点？一次遍历能完成吗？
 *
 * ✅ 标准答案：
 * 使用快慢指针，让快指针先走 K 步，然后快慢指针一起走。
 * 当快指针到达末尾时，慢指针就在倒数第 K 个位置。
 *
 * 时间复杂度：O(n)，一次遍历
 * 空间复杂度：O(1)
 *
 * ⭐ 加分回答：
 * 「这个技巧的关键是保持两个指针的间隔不变。
 *
 * 例如找倒数第 3 个：
 * ```
 * 1 -> 2 -> 3 -> 4 -> 5 -> null
 *           ↑              ↑
 *          slow          fast（初始间隔 3）
 *
 * 1 -> 2 -> 3 -> 4 -> 5 -> null
 *                ↑              ↑
 *               slow          fast
 *
 * 1 -> 2 -> 3 -> 4 -> 5 -> null
 *                     ↑         ↑
 *                    slow     fast(null)
 * ```
 *
 * 边界处理：
 * 1. K 大于链表长度：快指针先到 null
 * 2. 删除倒数第 K 个：用 dummy，让 slow 停在要删除节点的前一个
 *
 * 变体：
 * - 删除倒数第 K 个节点
 * - 链表中点（快指针走两步，慢指针走一步）」
 *
 * 🔄 可能的追问：
 * - 如何删除倒数第 K 个节点？
 * - 如果 K 可能大于链表长度怎么办？
 */

// ============================================================
// Q6: LRU 缓存怎么实现？
// ============================================================

/**
 * 📝 问题：LRU 缓存的原理是什么？怎么实现 O(1) 的 get 和 put？
 *
 * ✅ 标准答案：
 * LRU（Least Recently Used）淘汰最久未使用的数据。
 *
 * 实现需要两个数据结构：
 * 1. 哈希表：O(1) 查找
 * 2. 双向链表：O(1) 删除和移动
 *
 * 操作：
 * - get：从哈希表找到节点，移到链表头部
 * - put：更新/创建节点，移到头部，超容量则删除尾部
 *
 * ⭐ 加分回答：
 * 「实现细节：
 *
 * 1. 为什么用双向链表？
 *    - 需要 O(1) 删除任意节点
 *    - 单向链表删除需要找前驱，O(n)
 *
 * 2. 为什么用虚拟头尾节点？
 *    - 简化边界处理
 *    - 头部插入、尾部删除代码统一
 *
 * 3. 节点中为什么要存 key？
 *    - 删除尾部节点时，需要 key 来更新哈希表
 *
 * 4. JavaScript 的 Map 简化版：
 *    - Map 保持插入顺序
 *    - 删除再插入可以"移到末尾"
 *    - 但性能可能不如双向链表
 *
 * 前端应用：
 * - 图片缓存（最近访问的图片）
 * - API 响应缓存
 * - Vue/React 的 keep-alive
 * - Service Worker 缓存策略」
 *
 * 🔄 可能的追问：
 * - LFU 缓存怎么实现？（需要额外的频率信息）
 * - 如果容量是 0 怎么办？
 */

// ============================================================
// Q7: 如何判断链表是否回文？
// ============================================================

/**
 * 📝 问题：如何判断一个链表是否是回文链表？能做到 O(1) 空间吗？
 *
 * ✅ 标准答案：
 *
 * 方法一：转成数组判断 - 时间 O(n)，空间 O(n)
 *
 * 方法二：快慢指针 + 反转 - 时间 O(n)，空间 O(1)
 * 1. 快慢指针找到中点
 * 2. 反转后半部分
 * 3. 比较前半和后半
 * 4. （可选）恢复链表
 *
 * ⭐ 加分回答：
 * 「O(1) 空间的方法需要注意几点：
 *
 * 1. 奇偶长度处理：
 *    - 奇数长度：中间节点不需要比较
 *    - 使用 fast.next && fast.next.next 可以让 slow 停在中间靠左
 *
 * 2. 是否恢复链表：
 *    - 面试时问一下是否需要恢复
 *    - 恢复的话，比较完再把后半部分反转回去
 *
 * 3. 递归方法（不推荐）：
 *    - 利用递归栈从后往前比较
 *    - 空间 O(n)，不如数组直观
 *
 * 代码关键点：
 * ```
 * slow = fast = head;
 * while (fast.next && fast.next.next) {
 *   slow = slow.next;
 *   fast = fast.next.next;
 * }
 * // slow 在中点左侧，slow.next 是后半部分的开始
 * ```
 * 」
 *
 * 🔄 可能的追问：
 * - 如果要求不能修改原链表呢？（用栈或递归）
 * - 如何恢复链表？
 */

// ============================================================
// Q8: 链表相交问题怎么解决？
// ============================================================

/**
 * 📝 问题：如何判断两个链表是否相交？如何找到交点？
 *
 * ✅ 标准答案：
 *
 * 方法一：哈希表 - 时间 O(m+n)，空间 O(m)
 * - 遍历链表 A，把节点存入 Set
 * - 遍历链表 B，第一个在 Set 中的就是交点
 *
 * 方法二：双指针 - 时间 O(m+n)，空间 O(1)
 * - 指针 A 走完链表 A 后走链表 B
 * - 指针 B 走完链表 B 后走链表 A
 * - 如果相交，会在交点相遇
 *
 * ⭐ 加分回答：
 * 「双指针方法的数学原理：
 *
 * 设链表 A 长度为 a，链表 B 长度为 b，公共部分长度为 c
 *
 * 指针 A 走的路径：a + (b - c)
 * 指针 B 走的路径：b + (a - c)
 *
 * 两个路径长度相等：a + b - c
 *
 * 所以两个指针会同时到达交点！
 *
 * 如果不相交（c = 0）：
 * - 两个指针会同时到达 null
 * - 返回 null
 *
 * 代码：
 * ```
 * while (pA !== pB) {
 *   pA = pA === null ? headB : pA.next;
 *   pB = pB === null ? headA : pB.next;
 * }
 * return pA; // 交点或 null
 * ```
 *
 * 注意：比较的是节点引用，不是值！」
 *
 * 🔄 可能的追问：
 * - 如何处理有环的情况？
 * - 能否在一次遍历中完成？（不能，除非用哈希表）
 */

// ============================================================
// Q9: 链表和数组怎么选择？
// ============================================================

/**
 * 📝 问题：什么时候用链表，什么时候用数组？
 *
 * ✅ 标准答案：
 *
 * 用数组：
 * - 需要随机访问（按下标访问）
 * - 大小固定或变化不大
 * - 内存连续，缓存友好
 *
 * 用链表：
 * - 频繁在头部或中间插入/删除
 * - 大小变化频繁
 * - 不需要随机访问
 *
 * ⭐ 加分回答：
 * 「实际应用中，数组用得更多，因为：
 *
 * 1. CPU 缓存友好：
 *    - 数组元素连续存储，预取效率高
 *    - 链表节点分散，缓存命中率低
 *
 * 2. JavaScript 数组优化：
 *    - V8 对数组有特殊优化
 *    - push/pop 是 O(1)
 *    - shift/unshift 虽然是 O(n)，但有优化
 *
 * 3. 内存开销：
 *    - 链表每个节点都有指针开销
 *    - 32 位系统指针 4 字节，64 位系统 8 字节
 *
 * 链表适合的场景：
 * - 实现队列、栈（但 JS 数组也行）
 * - LRU 缓存（需要 O(1) 删除任意位置）
 * - 操作历史（撤销/重做）
 * - React Fiber 架构
 *
 * 面试中链表是为了考察指针操作和递归思维。」
 *
 * 🔄 可能的追问：
 * - 数组的 shift 操作真的是 O(n) 吗？
 * - 什么是跳表？（有序链表 + 多层索引）
 */

// ============================================================
// Q10: 链表题常见的陷阱有哪些？
// ============================================================

/**
 * 📝 问题：做链表题时有哪些常见的错误和陷阱？
 *
 * ✅ 标准答案：
 *
 * 1. 空指针访问：
 *    - 访问 node.next 前先检查 node
 *    - 访问 node.next.next 前先检查 node.next
 *
 * 2. 链表断裂：
 *    - 反转时先保存 next 再修改指针
 *    - 不保存就会丢失后续节点
 *
 * 3. 忘记返回正确的头：
 *    - 使用 dummy 时返回 dummy.next
 *    - 反转时返回 prev，不是 curr
 *
 * 4. 循环条件错误：
 *    - fast && fast.next（检测环）
 *    - fast.next && fast.next.next（找中点靠左）
 *
 * ⭐ 加分回答：
 * 「调试链表问题的技巧：
 *
 * 1. 画图！画图！画图！
 *    - 每一步操作都在图上标出指针位置
 *    - 特别是指针修改前后的状态
 *
 * 2. 测试边界情况：
 *    - 空链表 null
 *    - 单节点 [1]
 *    - 两个节点 [1, 2]
 *    - 操作涉及头节点或尾节点
 *
 * 3. 检查操作顺序：
 *    - 先保存，再修改，再移动
 *    - 顺序错了会链表断裂或形成环
 *
 * 4. 使用 dummy 简化边界：
 *    - 不确定头节点是否变化时用 dummy
 *    - 统一处理逻辑
 *
 * 经验：链表题目 80% 的 bug 是指针操作顺序问题。」
 *
 * 🔄 可能的追问：
 * - 如何调试链表代码？
 * - 怎么避免形成环？
 */

// ============================================================
// 📋 面试问答速查表
// ============================================================

/**
 * ┌─────────────────────────────────────────────────────────────────────────┐
 * │                           面试问答速查表                                 │
 * ├────────────────────────────────┬────────────────────────────────────────┤
 * │           问题类型             │              核心答案要点               │
 * ├────────────────────────────────┼────────────────────────────────────────┤
 * │ 反转链表迭代 vs 递归           │ 迭代 O(1) 空间推荐，递归 O(n) 栈空间    │
 * │ 快慢指针检测环                 │ 快走两步慢走一步，追及问题              │
 * │ 找环入口数学原理               │ a = (n-1)c + (c-b)，同时走会在入口相遇  │
 * │ 虚拟头节点作用                 │ 统一边界处理，返回 dummy.next          │
 * │ 链表排序用什么                 │ 归并排序，O(n log n)，链表合并 O(1) 空间│
 * │ 倒数第 K 个节点                │ 快慢指针间隔 K，一次遍历               │
 * │ LRU 缓存实现                   │ 哈希表 + 双向链表，O(1) get/put        │
 * │ 回文链表 O(1) 空间             │ 快慢指针找中点 + 反转后半部分          │
 * │ 链表相交双指针                 │ A 走完走 B，B 走完走 A，同时到交点      │
 * │ 常见陷阱                       │ 空指针、链表断裂、返回值错误、循环条件  │
 * └────────────────────────────────┴────────────────────────────────────────┘
 */

// ============================================================
// 🎯 回答问题的技巧
// ============================================================

/**
 * 链表题目的回答模板：
 *
 * 1. 识别问题类型：
 *    「这是一个[快慢指针/反转/合并]类型的问题」
 *
 * 2. 说明核心技巧：
 *    「我用[虚拟头节点/快慢指针/双指针]来解决」
 *
 * 3. 画图说明：
 *    「让我画个图说明指针的移动...」
 *
 * 4. 处理边界：
 *    「需要考虑空链表、单节点的情况」
 *
 * 5. 复杂度分析：
 *    「时间 O(n)，空间 O(1)，因为只用了几个指针变量」
 *
 * 示例回答：
 * 「这道题是检测链表环，是快慢指针的经典应用。
 * 让快指针走两步、慢指针走一步，如果有环，它们一定会在环内相遇。
 * 因为快指针每次比慢指针多走一步，相当于在追及慢指针。
 * 需要注意的是循环条件是 fast && fast.next，避免空指针。
 * 时间 O(n)，空间 O(1)。」
 */

export {};

