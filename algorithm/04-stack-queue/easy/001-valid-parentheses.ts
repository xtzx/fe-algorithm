/**
 * 📝 题目：有效的括号
 * 🔗 链接：https://leetcode.cn/problems/valid-parentheses/
 * 🏷️ 难度：Easy
 * 🏷️ 标签：栈、字符串
 *
 * 📋 题目描述：
 * 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s，判断字符串是否有效。
 *
 * 有效字符串需满足：
 * 1. 左括号必须用相同类型的右括号闭合。
 * 2. 左括号必须以正确的顺序闭合。
 * 3. 每个右括号都有一个对应的相同类型的左括号。
 *
 * 示例：
 * 输入：s = "()"
 * 输出：true
 *
 * 输入：s = "()[]{}"
 * 输出：true
 *
 * 输入：s = "(]"
 * 输出：false
 */

// ============================================================
// 💡 思路分析：这道题的解法是怎么想出来的？
// ============================================================
//
// 括号匹配的典型特征：
// - 最近的左括号要和最近的右括号匹配
// - 这种「后进先出」的特性正好适合用栈
//
// 算法：
// 1. 遇到左括号：入栈
// 2. 遇到右括号：检查栈顶是否匹配，匹配则出栈，不匹配则返回 false
// 3. 最后检查栈是否为空

// ============================================================
// 解法一：栈（推荐）
// ============================================================
// ⏱️ 时间复杂度：O(n) | 空间复杂度：O(n)

/**
 * 📊 执行过程图解：
 *
 * 输入: "({[]})"
 *
 *   字符   操作       栈状态
 *   '('    入栈       ['(']
 *   '{'    入栈       ['(', '{']
 *   '['    入栈       ['(', '{', '[']
 *   ']'    匹配出栈   ['(', '{']
 *   '}'    匹配出栈   ['(']
 *   ')'    匹配出栈   []
 *
 *   栈空 → 返回 true
 *
 * 输入: "([)]"
 *
 *   字符   操作       栈状态
 *   '('    入栈       ['(']
 *   '['    入栈       ['(', '[']
 *   ')'    栈顶是'['，不匹配 → 返回 false
 */
function isValid_v1(s: string): boolean {
  const stack: string[] = [];

  // 右括号 → 左括号的映射
  const pairs: { [key: string]: string } = {
    ')': '(',
    ']': '[',
    '}': '{',
  };

  for (const char of s) {
    if (char === '(' || char === '[' || char === '{') {
      // 左括号入栈
      stack.push(char);
    } else {
      // 右括号：检查栈顶是否匹配
      if (stack.length === 0 || stack.pop() !== pairs[char]) {
        return false;
      }
    }
  }

  // 最后栈必须为空
  return stack.length === 0;
}

// ============================================================
// 解法二：用 Map 代替对象
// ============================================================
// ⏱️ 时间复杂度：O(n) | 空间复杂度：O(n)
function isValid_v2(s: string): boolean {
  if (s.length % 2 !== 0) return false; // 奇数长度必定无效

  const stack: string[] = [];
  const map = new Map([
    [')', '('],
    [']', '['],
    ['}', '{'],
  ]);

  for (const char of s) {
    if (map.has(char)) {
      // 右括号
      if (stack.pop() !== map.get(char)) {
        return false;
      }
    } else {
      // 左括号
      stack.push(char);
    }
  }

  return stack.length === 0;
}

// ============================================================
// 解法三：替换法（不推荐，仅供了解）
// ============================================================
// ⏱️ 时间复杂度：O(n²) | 空间复杂度：O(n)
function isValid_v3(s: string): boolean {
  while (s.includes('()') || s.includes('[]') || s.includes('{}')) {
    s = s.replace('()', '').replace('[]', '').replace('{}', '');
  }
  return s.length === 0;
}

// ============================================================
// 🔄 解法对比
// ============================================================
/**
 * | 解法     | 时间   | 空间  | 特点                     |
 * |---------|--------|-------|-------------------------|
 * | 栈      | O(n)   | O(n)  | 推荐，标准解法            |
 * | 替换    | O(n²)  | O(n)  | 简单但慢，不推荐          |
 */

// ============================================================
// ⚠️ 易错点
// ============================================================
/**
 * 1. 栈空时遇到右括号：
 *    - 需要先检查 stack.length > 0
 *    - 或者 stack.pop() 返回 undefined 也不匹配
 *
 * 2. 遍历结束后检查栈：
 *    - 可能有多余的左括号
 *    - 例如 "((" 栈不为空
 *
 * 3. 奇数长度优化：
 *    - 奇数长度必定无效，可以提前返回
 *
 * 4. 空字符串：
 *    - "" 是有效的，返回 true
 */

// ============================================================
// 🔗 举一反三：相似题目
// ============================================================
/**
 * - 括号生成 → 回溯
 * - 最长有效括号 → 动态规划 / 栈
 * - 删除无效的括号 → BFS / 回溯
 * - 使括号有效的最少添加 → 贪心 / 栈
 */

// ============================================================
// 🏢 前端业务场景
// ============================================================
/**
 * 1. HTML 标签匹配：检查 <div></div> 是否配对
 * 2. JSON 格式验证：检查 {} [] 是否匹配
 * 3. 代码编辑器：语法高亮中的括号匹配
 * 4. 表达式验证：检查数学表达式括号是否有效
 */

export { isValid_v1, isValid_v2, isValid_v3 };
export default isValid_v1;

