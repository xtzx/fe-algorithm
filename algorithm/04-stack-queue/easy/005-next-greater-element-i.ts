/**
 * 📝 题目：下一个更大元素 I
 * 🔗 链接：https://leetcode.cn/problems/next-greater-element-i/
 * 🏷️ 难度：Easy
 * 🏷️ 标签：栈、数组、哈希表、单调栈
 *
 * 📋 题目描述：
 * nums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置右侧的第一个比 x 大的元素。
 * 给你两个没有重复元素的数组 nums1 和 nums2，其中 nums1 是 nums2 的子集。
 * 请你找出 nums1 中每个元素在 nums2 中的下一个更大元素。
 * 如果不存在，对应位置输出 -1。
 *
 * 示例：
 * 输入：nums1 = [4,1,2], nums2 = [1,3,4,2]
 * 输出：[-1,3,-1]
 * 解释：
 * - 4 在 nums2 中右侧没有更大元素，返回 -1
 * - 1 在 nums2 中右侧第一个更大的是 3
 * - 2 在 nums2 中右侧没有更大元素，返回 -1
 *
 * 输入：nums1 = [2,4], nums2 = [1,2,3,4]
 * 输出：[3,-1]
 */

// ============================================================
// 💡 思路分析
// ============================================================
//
// 这是单调栈的入门题！
//
// 核心思路：
// 1. 先用单调栈预处理 nums2，找到每个元素的下一个更大元素
// 2. 用哈希表存储 nums2 中每个元素的下一个更大元素
// 3. 遍历 nums1，从哈希表中查找答案
//
// 为什么这样做？
// - 暴力解法对每个元素都要向右查找，O(n*m)
// - 单调栈可以一次遍历找到所有元素的下一个更大元素，O(n+m)

// ============================================================
// 解法一：单调栈 + 哈希表（推荐）
// ============================================================
// ⏱️ 时间复杂度：O(n + m) | 空间复杂度：O(n)

/**
 * 📊 单调栈执行过程图解：
 *
 * nums2 = [1, 3, 4, 2]
 *
 * 使用单调递减栈（栈底到栈顶递减）
 *
 * i=0, num=1: 栈空，入栈           栈: [1]      map: {}
 * i=1, num=3: 3>1，弹出1，入栈     栈: [3]      map: {1:3}
 * i=2, num=4: 4>3，弹出3，入栈     栈: [4]      map: {1:3, 3:4}
 * i=3, num=2: 2<4，入栈            栈: [4,2]    map: {1:3, 3:4}
 *
 * 遍历结束，栈中剩余元素没有更大的
 *
 * 最终 map = {1:3, 3:4}
 *
 * 查询 nums1 = [4,1,2]:
 * - 4 不在 map 中 → -1
 * - 1 在 map 中 → 3
 * - 2 不在 map 中 → -1
 *
 * 结果: [-1, 3, -1]
 */
function nextGreaterElement_v1(nums1: number[], nums2: number[]): number[] {
  // 单调栈预处理 nums2
  const map = new Map<number, number>();
  const stack: number[] = [];

  for (const num of nums2) {
    // 当前元素比栈顶大，说明找到了栈顶的下一个更大元素
    while (stack.length > 0 && num > stack[stack.length - 1]) {
      const top = stack.pop()!;
      map.set(top, num);
    }
    stack.push(num);
  }

  // 查询 nums1 的结果
  return nums1.map((num) => map.get(num) ?? -1);
}

// ============================================================
// 解法二：暴力（对比用）
// ============================================================
// ⏱️ 时间复杂度：O(n × m) | 空间复杂度：O(1)

function nextGreaterElement_v2(nums1: number[], nums2: number[]): number[] {
  const result: number[] = [];

  for (const num of nums1) {
    // 在 nums2 中找到 num 的位置
    let index = nums2.indexOf(num);
    let found = -1;

    // 向右查找更大的元素
    for (let i = index + 1; i < nums2.length; i++) {
      if (nums2[i] > num) {
        found = nums2[i];
        break;
      }
    }

    result.push(found);
  }

  return result;
}

// ============================================================
// 🔄 解法对比
// ============================================================
/**
 * | 解法      | 时间     | 空间  | 特点                        |
 * |----------|---------|-------|----------------------------|
 * | 单调栈   | O(n+m)  | O(n)  | 推荐，预处理 + 查询          |
 * | 暴力     | O(n×m)  | O(1)  | 简单但效率低                 |
 */

// ============================================================
// ⚠️ 易错点
// ============================================================
/**
 * 1. 单调栈存值还是存索引：
 *    - 本题存值，因为需要用值作为 map 的 key
 *    - 如果需要计算距离，应该存索引
 *
 * 2. 栈中剩余元素：
 *    - 栈中剩余的元素没有更大的
 *    - 用 ?? -1 处理不存在的情况
 *
 * 3. 单调递减还是递增：
 *    - 找下一个更大用递减栈
 *    - 找下一个更小用递增栈
 */

// ============================================================
// 📊 单调栈总结
// ============================================================
/**
 * 单调栈适用场景：
 * - 下一个更大元素：单调递减栈
 * - 下一个更小元素：单调递增栈
 * - 上一个更大元素：反向遍历或入栈时记录
 * - 上一个更小元素：反向遍历或入栈时记录
 *
 * 时间复杂度 O(n) 的原因：
 * - 每个元素最多入栈一次、出栈一次
 * - 总操作次数 ≤ 2n
 */

// ============================================================
// 🔗 举一反三：相似题目
// ============================================================
/**
 * - 下一个更大元素 II（循环数组）→ 遍历两遍
 * - 每日温度 → 下一个更高温度的距离
 * - 柱状图中最大的矩形 → 找左右边界
 *
 * 共同模式：单调栈找下一个更大/小元素
 */

// ============================================================
// 🏢 前端业务场景
// ============================================================
/**
 * 1. 股票图表：找下一个更高价格
 * 2. 性能监控：找下一个异常峰值
 * 3. 滚动优化：找下一个更高元素位置
 * 4. 数据分析：找局部极值点
 */

export { nextGreaterElement_v1, nextGreaterElement_v2 };
export default nextGreaterElement_v1;

