/**
 * 📝 题目：下一个更大元素 II
 * 🔗 链接：https://leetcode.cn/problems/next-greater-element-ii/
 * 🏷️ 难度：Medium
 * 🏷️ 标签：栈、数组、单调栈
 *
 * 📋 题目描述：
 * 给定一个循环数组 nums（nums[nums.length - 1] 的下一个元素是 nums[0]），
 * 返回 nums 中每个元素的 下一个更大元素。
 *
 * 数字 x 的 下一个更大的元素 是按数组遍历顺序，
 * 这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。
 * 如果不存在，则输出 -1。
 *
 * 示例：
 * 输入：nums = [1,2,1]
 * 输出：[2,-1,2]
 * 解释：第一个 1 的下一个更大的数是 2；
 *       数字 2 找不到下一个更大的数；
 *       第二个 1 的下一个更大的数需要循环搜索，结果也是 2。
 *
 * 输入：nums = [1,2,3,4,3]
 * 输出：[2,3,4,-1,4]
 */

// ============================================================
// 💡 思路分析：这道题的解法是怎么想出来的？
// ============================================================
//
// 与普通的「下一个更大元素」的区别：循环数组
//
// 处理循环的技巧：
// - 遍历两遍数组（或者把数组复制一份拼接）
// - 用取模操作 i % n 来处理索引
//
// 算法：
// - 单调栈 + 遍历两遍
// - 第二遍只是为了让栈中剩余元素有机会找到答案

// ============================================================
// 解法一：单调栈 + 遍历两遍
// ============================================================
// ⏱️ 时间复杂度：O(n) | 空间复杂度：O(n)

/**
 * 📊 执行过程图解：
 *
 * nums = [1, 2, 3, 4, 3]
 *         0  1  2  3  4
 *
 * 第一遍（正常遍历）：
 * i=0, num=1: 栈空，入栈           栈:[0]      result:[-1,-1,-1,-1,-1]
 * i=1, num=2: 2>1，弹0，入1        栈:[1]      result:[2,-1,-1,-1,-1]
 * i=2, num=3: 3>2，弹1，入2        栈:[2]      result:[2,3,-1,-1,-1]
 * i=3, num=4: 4>3，弹2，入3        栈:[3]      result:[2,3,4,-1,-1]
 * i=4, num=3: 3<4，入4             栈:[3,4]    result:[2,3,4,-1,-1]
 *
 * 第二遍（循环回来）：
 * i=5%5=0, num=1: 1<3，入0        不入栈（第二遍不入栈）
 * i=6%5=1, num=2: 2<3，入1        不入栈
 * i=7%5=2, num=3: 3<3，入2        不入栈
 * i=8%5=3, num=4: 4>3，弹4        栈:[3]      result:[2,3,4,-1,4]
 *                 4>=4，不弹3
 * i=9%5=4, num=3: 3<4             结束
 *
 * 最终: [2, 3, 4, -1, 4]
 */
function nextGreaterElements(nums: number[]): number[] {
  const n = nums.length;
  const result = new Array(n).fill(-1);
  const stack: number[] = []; // 单调递减栈，存储索引

  // 遍历两遍
  for (let i = 0; i < 2 * n; i++) {
    const index = i % n;

    // 单调栈处理
    while (
      stack.length > 0 &&
      nums[stack[stack.length - 1]] < nums[index]
    ) {
      const prevIndex = stack.pop()!;
      result[prevIndex] = nums[index];
    }

    // 第一遍才入栈（第二遍只是为了处理栈中剩余元素）
    if (i < n) {
      stack.push(index);
    }
  }

  return result;
}

// ============================================================
// 解法二：不使用取模，直接倒着遍历两遍
// ============================================================
// ⏱️ 时间复杂度：O(n) | 空间复杂度：O(n)
function nextGreaterElements_v2(nums: number[]): number[] {
  const n = nums.length;
  const result = new Array(n).fill(-1);
  const stack: number[] = [];

  // 从后往前遍历两遍
  for (let i = 2 * n - 1; i >= 0; i--) {
    const index = i % n;

    // 移除栈中所有小于等于当前元素的
    while (stack.length > 0 && stack[stack.length - 1] <= nums[index]) {
      stack.pop();
    }

    // 栈顶就是下一个更大元素
    if (i < n && stack.length > 0) {
      result[index] = stack[stack.length - 1];
    }

    // 当前元素入栈
    stack.push(nums[index]);
  }

  return result;
}

// ============================================================
// 🔄 解法对比
// ============================================================
/**
 * | 解法           | 时间  | 空间  | 特点                     |
 * |---------------|-------|-------|-------------------------|
 * | 正向遍历两遍   | O(n)  | O(n)  | 推荐，思路直观            |
 * | 反向遍历两遍   | O(n)  | O(n)  | 另一种思路               |
 */

// ============================================================
// ⚠️ 易错点
// ============================================================
/**
 * 1. 循环数组的处理：
 *    - 遍历 2n 次
 *    - 用 i % n 获取实际索引
 *
 * 2. 第二遍不入栈：
 *    - 第二遍只是为了让第一遍入栈的元素找到答案
 *    - 如果第二遍也入栈，会导致结果重复计算
 *
 * 3. 与普通版本的区别：
 *    - 普通版本栈中剩余元素结果是 -1
 *    - 循环版本需要继续遍历来处理
 */

// ============================================================
// 🔗 举一反三：相似题目
// ============================================================
/**
 * - 下一个更大元素 I → 非循环版本，用哈希表
 * - 每日温度 → 下一个更大元素的应用
 * - 循环数组其他问题 → 相同的取模技巧
 */

// ============================================================
// 🏢 前端业务场景
// ============================================================
/**
 * 1. 轮播图：循环查找下一个/上一个
 * 2. 循环列表：循环数据的处理
 * 3. 时间轮：循环时间任务调度
 */

export { nextGreaterElements, nextGreaterElements_v2 };
export default nextGreaterElements;

