/**
 * 📝 题目：验证栈序列
 * 🔗 链接：https://leetcode.cn/problems/validate-stack-sequences/
 * 🏷️ 难度：Medium
 * 🏷️ 标签：栈、数组、模拟
 *
 * 📋 题目描述：
 * 给定 pushed 和 popped 两个序列，每个序列中的值都不重复，
 * 只有当它们可能是在最初空栈上进行的推入 push 和弹出 pop 操作序列的结果时，返回 true；
 * 否则，返回 false。
 *
 * 示例：
 * 输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]
 * 输出：true
 * 解释：可以按以下顺序执行：
 * push(1), push(2), push(3), push(4), pop() -> 4,
 * push(5), pop() -> 5, pop() -> 3, pop() -> 2, pop() -> 1
 *
 * 输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2]
 * 输出：false
 * 解释：1 不能在 2 之前弹出
 */

// ============================================================
// 💡 思路分析
// ============================================================
//
// 这道题是栈操作的模拟题
//
// 核心思路：
// 1. 模拟入栈和出栈操作
// 2. 遍历 pushed，每个元素入栈
// 3. 每次入栈后，检查栈顶是否等于当前要出栈的元素
// 4. 如果相等，出栈，继续检查
// 5. 最后检查栈是否为空（或 popped 是否遍历完）

// ============================================================
// 解法一：模拟（推荐）
// ============================================================
// ⏱️ 时间复杂度：O(n) | 空间复杂度：O(n)

/**
 * 📊 模拟执行过程图解：
 *
 * pushed = [1,2,3,4,5], popped = [4,5,3,2,1]
 *
 * j=0, popped[j]=4
 *
 * push(1): 栈[1], 栈顶≠4
 * push(2): 栈[1,2], 栈顶≠4
 * push(3): 栈[1,2,3], 栈顶≠4
 * push(4): 栈[1,2,3,4], 栈顶=4, pop → 栈[1,2,3], j=1
 *          栈顶=3≠5
 * push(5): 栈[1,2,3,5], 栈顶=5, pop → 栈[1,2,3], j=2
 *          栈顶=3=3, pop → 栈[1,2], j=3
 *          栈顶=2=2, pop → 栈[1], j=4
 *          栈顶=1=1, pop → 栈[], j=5
 *
 * 栈为空，j=5=popped.length，返回 true
 *
 * ---
 *
 * pushed = [1,2,3,4,5], popped = [4,3,5,1,2]
 *
 * j=0, popped[j]=4
 *
 * push(1): 栈[1]
 * push(2): 栈[1,2]
 * push(3): 栈[1,2,3]
 * push(4): 栈[1,2,3,4], 栈顶=4, pop → 栈[1,2,3], j=1
 *          栈顶=3=3, pop → 栈[1,2], j=2
 *          栈顶=2≠5
 * push(5): 栈[1,2,5], 栈顶=5, pop → 栈[1,2], j=3
 *          栈顶=2≠1
 *
 * 遍历结束，栈[1,2]非空，返回 false
 * （1 在 2 下面，不可能先弹出 1 再弹出 2）
 */
function validateStackSequences_v1(
  pushed: number[],
  popped: number[]
): boolean {
  const stack: number[] = [];
  let j = 0; // popped 的指针

  for (const num of pushed) {
    // 入栈
    stack.push(num);

    // 尝试出栈：栈顶等于当前要出栈的元素
    while (stack.length > 0 && stack[stack.length - 1] === popped[j]) {
      stack.pop();
      j++;
    }
  }

  // 如果所有元素都正确出栈，栈应该为空
  return stack.length === 0;
}

// ============================================================
// 解法二：双指针（空间优化）
// ============================================================
// ⏱️ 时间复杂度：O(n) | 空间复杂度：O(1)（原地修改 pushed 数组）
// 📝 不推荐，因为修改了输入数组，但面试时可以提一下

function validateStackSequences_v2(
  pushed: number[],
  popped: number[]
): boolean {
  let i = 0; // pushed 数组模拟栈顶位置
  let j = 0; // popped 的指针

  for (const num of pushed) {
    // 用 pushed[i] 作为栈顶
    pushed[i] = num;
    i++;

    // 尝试出栈
    while (i > 0 && pushed[i - 1] === popped[j]) {
      i--;
      j++;
    }
  }

  return i === 0;
}

// ============================================================
// 🔄 解法对比
// ============================================================
/**
 * | 解法       | 时间  | 空间  | 特点                        |
 * |-----------|-------|-------|----------------------------|
 * | 模拟栈    | O(n)  | O(n)  | 推荐，清晰易懂              |
 * | 双指针    | O(n)  | O(1)  | 空间优化，但修改了输入       |
 */

// ============================================================
// ⚠️ 易错点
// ============================================================
/**
 * 1. 每次入栈后都要尝试出栈：
 *    - 不是入完所有再出
 *    - 而是边入边检查能否出
 *
 * 2. while 循环出栈：
 *    - 可能连续出多个
 *    - 不是只出一个
 *
 * 3. 最终判断：
 *    - 栈为空说明所有元素都正确出栈
 *    - 也可以判断 j === popped.length
 *
 * 4. 边界检查：
 *    - 出栈前检查栈是否为空
 */

// ============================================================
// 🔗 举一反三：相似题目
// ============================================================
/**
 * - 用栈实现队列 → 栈的模拟操作
 * - 用队列实现栈 → 栈的模拟操作
 * - 栈排序 → 辅助栈操作
 * - 最小栈 → 栈的设计
 *
 * 共同模式：理解栈的 LIFO 特性
 */

// ============================================================
// 🏢 前端业务场景
// ============================================================
/**
 * 1. 撤销操作验证：验证操作序列是否合法
 * 2. 历史记录：验证浏览历史是否合理
 * 3. 事务处理：验证事务的开始和结束顺序
 * 4. 调试工具：验证函数调用和返回顺序
 */

export { validateStackSequences_v1, validateStackSequences_v2 };
export default validateStackSequences_v1;

