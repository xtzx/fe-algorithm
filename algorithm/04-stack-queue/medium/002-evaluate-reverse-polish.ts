/**
 * 📝 题目：逆波兰表达式求值
 * 🔗 链接：https://leetcode.cn/problems/evaluate-reverse-polish-notation/
 * 🏷️ 难度：Medium
 * 🏷️ 标签：栈、数组、数学
 *
 * 📋 题目描述：
 * 给你一个字符串数组 tokens，表示一个根据 逆波兰表示法 表示的算术表达式。
 * 请你计算该表达式。返回一个表示表达式值的整数。
 *
 * 注意：
 * - 有效的算符为 '+'、'-'、'*' 和 '/'
 * - 每个操作数（运算对象）都可以是一个整数或者另一个表达式
 * - 两个整数之间的除法总是 向零截断
 * - 表达式中不含除零运算
 * - 输入是一个根据逆波兰表示法表示的算术表达式
 *
 * 示例：
 * 输入：tokens = ["2","1","+","3","*"]
 * 输出：9
 * 解释：((2 + 1) * 3) = 9
 *
 * 输入：tokens = ["4","13","5","/","+"]
 * 输出：6
 * 解释：(4 + (13 / 5)) = 6
 */

// ============================================================
// 💡 思路分析：这道题的解法是怎么想出来的？
// ============================================================
//
// 逆波兰表达式（后缀表达式）的特点：
// - 操作符在操作数后面
// - 不需要括号就能表示运算优先级
// - 天然适合用栈来计算
//
// 算法：
// 1. 遇到数字：入栈
// 2. 遇到操作符：弹出两个数，计算结果，结果入栈
// 3. 最后栈中只剩一个数，就是答案

// ============================================================
// 解法：栈
// ============================================================
// ⏱️ 时间复杂度：O(n) | 空间复杂度：O(n)

/**
 * 📊 执行过程图解：
 *
 * tokens = ["2", "1", "+", "3", "*"]
 *
 * "2": 入栈           栈: [2]
 * "1": 入栈           栈: [2, 1]
 * "+": 弹出1,2; 2+1=3 栈: [3]
 * "3": 入栈           栈: [3, 3]
 * "*": 弹出3,3; 3*3=9 栈: [9]
 *
 * 结果: 9
 *
 * tokens = ["4", "13", "5", "/", "+"]
 *
 * "4":  入栈              栈: [4]
 * "13": 入栈              栈: [4, 13]
 * "5":  入栈              栈: [4, 13, 5]
 * "/":  弹出5,13; 13/5=2  栈: [4, 2]
 * "+":  弹出2,4; 4+2=6    栈: [6]
 *
 * 结果: 6
 *
 * ⚠️ 注意操作数顺序：
 * 先弹出的是右操作数，后弹出的是左操作数
 * 比如 "/" 时：left=13, right=5, 结果是 13/5
 */
function evalRPN(tokens: string[]): number {
  const stack: number[] = [];
  const operators = new Set(['+', '-', '*', '/']);

  for (const token of tokens) {
    if (operators.has(token)) {
      // 操作符：弹出两个数进行计算
      const right = stack.pop()!; // 注意顺序：先弹出的是右操作数
      const left = stack.pop()!;

      let result: number;
      switch (token) {
        case '+':
          result = left + right;
          break;
        case '-':
          result = left - right;
          break;
        case '*':
          result = left * right;
          break;
        case '/':
          // 向零截断：正数向下取整，负数向上取整
          result = Math.trunc(left / right);
          break;
        default:
          result = 0;
      }

      stack.push(result);
    } else {
      // 数字：入栈
      stack.push(parseInt(token, 10));
    }
  }

  return stack[0];
}

// ============================================================
// 解法二：使用对象映射操作符
// ============================================================
function evalRPN_v2(tokens: string[]): number {
  const stack: number[] = [];

  const operations: { [key: string]: (a: number, b: number) => number } = {
    '+': (a, b) => a + b,
    '-': (a, b) => a - b,
    '*': (a, b) => a * b,
    '/': (a, b) => Math.trunc(a / b),
  };

  for (const token of tokens) {
    if (token in operations) {
      const right = stack.pop()!;
      const left = stack.pop()!;
      stack.push(operations[token](left, right));
    } else {
      stack.push(parseInt(token, 10));
    }
  }

  return stack[0];
}

// ============================================================
// 📖 逆波兰表达式的来源
// ============================================================
/**
 * 中缀表达式 → 后缀表达式（逆波兰）
 *
 * 中缀: (2 + 1) * 3
 * 后缀: 2 1 + 3 *
 *
 * 后缀表达式的优点：
 * 1. 不需要括号
 * 2. 计算简单（用栈一次遍历）
 * 3. 计算机容易处理
 *
 * 这就是为什么很多计算器内部使用后缀表达式
 */

// ============================================================
// ⚠️ 易错点
// ============================================================
/**
 * 1. 操作数顺序：
 *    - 先弹出的是右操作数（right）
 *    - 后弹出的是左操作数（left）
 *    - 减法和除法顺序很重要！
 *
 * 2. 除法向零截断：
 *    - Math.trunc() 或 (x / y) | 0
 *    - 不是 Math.floor()！
 *    - Math.floor(-6.5) = -7, Math.trunc(-6.5) = -6
 *
 * 3. 数字解析：
 *    - 可能有负数，如 "-11"
 *    - parseInt(token, 10) 能正确处理
 */

// ============================================================
// 🔗 举一反三：相似题目
// ============================================================
/**
 * - 基本计算器 → 中缀表达式求值（更难）
 * - 基本计算器 II → 只有 +-*/
 * - 字符串转整数 → 字符串处理
 */

// ============================================================
// 🏢 前端业务场景
// ============================================================
/**
 * 1. 公式计算器：电子表格中的公式计算
 * 2. 配置表达式：解析和计算配置中的表达式
 * 3. 规则引擎：计算业务规则表达式
 */

export { evalRPN, evalRPN_v2 };
export default evalRPN;

