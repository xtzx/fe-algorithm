/**
 * ============================================================
 * 📚 回溯算法 - 面试高频问答
 * ============================================================
 *
 * 本文件包含回溯算法相关的面试高频问题，每个问题包含：
 * 1. 问题本身
 * 2. 标准答案
 * 3. 加分回答（展示深度理解）
 * 4. 追问方向
 */

// ============================================================
// Q1: 什么是回溯算法？和递归有什么区别？
// ============================================================

/**
 * 📝 问题：什么是回溯算法？和递归/DFS有什么区别？
 *
 * ✅ 标准答案：
 * 回溯是一种通过穷举来寻找问题所有解的算法。
 *
 * 核心思想：
 * - 选择一个选项
 * - 继续往下探索
 * - 如果走不通，撤销选择，换一个选项
 *
 * 与递归/DFS的关系：
 * - 递归：一种编程技巧，函数调用自身
 * - DFS：一种遍历策略，深度优先
 * - 回溯：DFS + 状态重置，用于求解所有可能的解
 *
 * ⭐ 加分回答：
 * 「回溯的本质是遍历决策树：
 *
 *              []
 *       /      |      \
 *     [1]     [2]     [3]
 *    /   \     |
 *  [1,2] [1,3] [2,3]
 *
 * 三个核心操作：
 * 1. 做选择：path.push()
 * 2. 递归：backtrack()
 * 3. 撤销选择：path.pop()（这是回溯的精髓！）
 *
 * 回溯和普通 DFS 的区别：
 * - DFS 只是遍历
 * - 回溯要"恢复现场"，因为要尝试其他分支
 *
 * 时间复杂度通常是指数级：O(n!) 或 O(2^n)
 * 所以回溯题目的数据规模通常很小（n ≤ 20）。」
 *
 * 🔄 可能的追问：
 * - 回溯能优化吗？（剪枝）
 * - 和动态规划有什么区别？
 */

// ============================================================
// Q2: 排列、组合、子集有什么区别？
// ============================================================

/**
 * 📝 问题：排列、组合、子集问题有什么区别？怎么选择模板？
 *
 * ✅ 标准答案：
 *
 * 排列：元素顺序有关，[1,2] 和 [2,1] 不同
 * 组合：元素顺序无关，[1,2] 和 [2,1] 相同
 * 子集：每个元素选或不选
 *
 * 去重方式：
 * - 排列：用 used 数组
 * - 组合/子集：用 start 参数
 *
 * ⭐ 加分回答：
 * 「核心区别总结：
 *
 * ┌─────────┬─────────┬────────────┬─────────────────┐
 * │ 问题    │ 顺序    │ 去重方式    │ 收集时机         │
 * ├─────────┼─────────┼────────────┼─────────────────┤
 * │ 排列    │ 有关    │ used 数组  │ path.length = n │
 * │ 组合    │ 无关    │ start 参数 │ 满足目标条件     │
 * │ 子集    │ 无关    │ start 参数 │ 每个节点都收集   │
 * └─────────┴─────────┴────────────┴─────────────────┘
 *
 * 为什么排列用 used？
 * - 排列每次要从头遍历所有元素
 * - 但已选的不能再选，用 used 标记
 *
 * 为什么组合/子集用 start？
 * - [1,2] 和 [2,1] 是同一个组合
 * - 只选当前位置之后的，就不会重复
 *
 * 快速判断：
 * - "全排列" → 排列
 * - "所有组合"、"选 k 个" → 组合
 * - "所有子集"、"幂集" → 子集」
 *
 * 🔄 可能的追问：
 * - 组合总和可以重复选怎么处理？
 * - 有重复元素怎么去重？
 */

// ============================================================
// Q3: 如何处理重复元素？
// ============================================================

/**
 * 📝 问题：回溯中如何处理重复元素？
 *
 * ✅ 标准答案：
 * 两步：
 * 1. 先排序，让相同元素相邻
 * 2. 同一层跳过重复元素
 *
 * 组合/子集：if (i > start && nums[i] === nums[i-1]) continue;
 * 排列：if (i > 0 && nums[i] === nums[i-1] && !used[i-1]) continue;
 *
 * ⭐ 加分回答：
 * 「去重的本质是理解"树层"和"树枝"：
 *
 *              []
 *       /      |      \
 *     [1]     [1]     [2]    ← 同一层，要去重
 *    /   \     |
 *  [1,1] [1,2] [1,2]          ← 不同层，不去重
 *
 * 排列去重条件分析：
 * if (i > 0 && nums[i] === nums[i-1] && !used[i-1])
 *
 * - nums[i] === nums[i-1]：当前元素和前一个相同
 * - !used[i-1]：前一个没被使用 = 同一层
 *
 * 为什么是 !used[i-1] 而不是 used[i-1]？
 * - used[i-1] = true：前一个在路径中，这是不同层（树枝）
 * - used[i-1] = false：前一个不在路径中，刚被撤销，这是同一层
 *
 * 组合去重条件分析：
 * if (i > start && nums[i] === nums[i-1])
 *
 * - i > start：不是这一层的第一个元素
 * - nums[i] === nums[i-1]：和前一个相同
 *
 * 这个条件更简单，因为组合本身就不会选同一个元素两次。」
 *
 * 🔄 可能的追问：
 * - 为什么组合用 i > start 而不是 i > 0？
 * - 不排序能去重吗？（可以用 Set，但效率低）
 */

// ============================================================
// Q4: 什么是剪枝？怎么剪枝？
// ============================================================

/**
 * 📝 问题：什么是剪枝？回溯中怎么剪枝优化？
 *
 * ✅ 标准答案：
 * 剪枝是提前终止不可能的分支，减少搜索空间。
 *
 * 常见剪枝策略：
 * 1. 可行性剪枝：不满足约束条件就跳过
 * 2. 最优性剪枝：不可能比已知解更好就跳过
 * 3. 重复剪枝：去除重复的选择
 *
 * ⭐ 加分回答：
 * 「剪枝的关键是找到"无效分支"的特征。
 *
 * 例1：组合总和
 * - 排序后，如果当前数 > 剩余目标，后面的更大
 * - 直接 break，不用 continue
 *
 * for (let i = start; i < nums.length; i++) {
 *   if (nums[i] > remaining) break;  // 剪枝
 *   // ...
 * }
 *
 * 例2：N皇后
 * - 放置皇后前检查行、列、对角线
 * - 不满足直接跳过，不进入递归
 *
 * if (!isValid(row, col)) continue;  // 剪枝
 *
 * 例3：回溯题常见优化
 * - 选择列表能排序就排序
 * - 用 break 代替 continue（适当时候）
 * - 记忆化（某些场景）
 *
 * 剪枝效果：
 * - 好的剪枝可以把指数级降到多项式级
 * - 但最坏情况复杂度不变」
 *
 * 🔄 可能的追问：
 * - break 和 continue 什么时候用？
 * - 回溯能用记忆化吗？
 */

// ============================================================
// Q5: 回溯结果为什么要拷贝？
// ============================================================

/**
 * 📝 问题：为什么 result.push([...path]) 要拷贝？直接 push(path) 不行吗？
 *
 * ✅ 标准答案：
 * 不行！path 是同一个数组引用，后续修改会影响已收集的结果。
 *
 * 错误：result.push(path)
 * 正确：result.push([...path]) 或 result.push(path.slice())
 *
 * ⭐ 加分回答：
 * 「这是 JavaScript 引用类型的经典问题。
 *
 * 错误示例：
 * const result = [];
 * const path = [];
 *
 * path.push(1);
 * result.push(path);  // result = [[1]]
 *
 * path.push(2);
 * result.push(path);  // result = [[1,2], [1,2]]  ← 第一个也变了！
 *
 * path.pop();
 * // result = [[1], [1]]  ← 全变了！
 *
 * 因为 result 里存的是 path 的引用，不是值。
 *
 * 正确做法：
 * result.push([...path]);  // ES6 展开
 * result.push(path.slice());  // slice 浅拷贝
 * result.push(Array.from(path));  // Array.from
 *
 * 这在所有需要收集结果的回溯题中都是必须的！
 *
 * 类似问题：
 * - 深拷贝 vs 浅拷贝
 * - 对象/数组的引用传递」
 *
 * 🔄 可能的追问：
 * - 什么时候需要深拷贝？
 * - 其他语言有这个问题吗？
 */

// ============================================================
// Q6: 组合总和可以重复选怎么处理？
// ============================================================

/**
 * 📝 问题：组合总和中元素可以重复使用，怎么处理？
 *
 * ✅ 标准答案：
 * 递归时传 i 而不是 i+1。
 *
 * 不可重复：backtrack(i + 1, ...)
 * 可重复：backtrack(i, ...)
 *
 * ⭐ 加分回答：
 * 「区别在于"下一次从哪里开始选"。
 *
 * 不可重复选：
 * - 每个元素只能用一次
 * - 下一次从 i+1 开始
 * - 例：[2,3,6,7] 选出和为 7 → [7]（不能 [2,2,3]）
 *
 * 可重复选：
 * - 每个元素可以用多次
 * - 下一次还是从 i 开始
 * - 例：[2,3,6,7] 选出和为 7 → [2,2,3], [7]
 *
 * for (let i = start; i < nums.length; i++) {
 *   path.push(nums[i]);
 *
 *   // 可重复选
 *   backtrack(i, remaining - nums[i]);
 *
 *   // 不可重复选
 *   // backtrack(i + 1, remaining - nums[i]);
 *
 *   path.pop();
 * }
 *
 * 注意：
 * - 可重复选 + 有重复元素 = 组合总和 II
 * - 需要先排序 + 去重逻辑」
 *
 * 🔄 可能的追问：
 * - 组合总和 II 怎么处理？
 * - 为什么还是从 i 开始不会无限循环？
 */

// ============================================================
// Q7: N皇后问题怎么解？
// ============================================================

/**
 * 📝 问题：N皇后问题怎么用回溯解决？
 *
 * ✅ 标准答案：
 * 逐行放置皇后，每行选一个位置，检查是否和已放置的冲突。
 *
 * 约束条件：
 * - 不同行：每行放一个，天然满足
 * - 不同列：记录已用列
 * - 不同对角线：主对角线 row-col 相同，副对角线 row+col 相同
 *
 * ⭐ 加分回答：
 * 「N皇后的关键是高效检查冲突。
 *
 * 暴力检查：O(n) 遍历所有已放置皇后
 * 优化：用 Set 记录，O(1) 检查
 *
 * const cols = new Set();      // 已用的列
 * const diag1 = new Set();     // 主对角线 row - col
 * const diag2 = new Set();     // 副对角线 row + col
 *
 * function isValid(row, col) {
 *   return !cols.has(col) &&
 *          !diag1.has(row - col) &&
 *          !diag2.has(row + col);
 * }
 *
 * 回溯过程：
 * 1. 从第 0 行开始
 * 2. 尝试每一列
 * 3. 如果合法，放置皇后，进入下一行
 * 4. 递归返回时撤销
 *
 * 时间复杂度：O(n!)
 * - 第一行 n 种选择
 * - 第二行 n-1 种
 * - ...
 *
 * 经典变体：
 * - 返回解的数量
 * - 返回一个可行解
 * - 判断是否有解」
 *
 * 🔄 可能的追问：
 * - 对角线为什么用 row±col？
 * - 能优化到更快吗？（位运算优化）
 */

// ============================================================
// Q8: 回溯和动态规划有什么区别？
// ============================================================

/**
 * 📝 问题：回溯和动态规划有什么区别？什么时候用哪个？
 *
 * ✅ 标准答案：
 *
 * 回溯：穷举所有可能的解
 * 动态规划：求最优解或计数
 *
 * 选择依据：
 * - 要所有具体方案 → 回溯
 * - 只要最优值/数量 → DP
 *
 * ⭐ 加分回答：
 * 「两者的本质区别：
 *
 * ┌──────────┬─────────────────┬─────────────────┐
 * │          │     回溯         │      DP        │
 * ├──────────┼─────────────────┼─────────────────┤
 * │ 目标     │ 所有可能的解     │ 最优解/计数     │
 * │ 过程     │ 试错 + 撤销      │ 状态转移        │
 * │ 重复计算 │ 有               │ 消除了          │
 * │ 复杂度   │ 指数级           │ 多项式          │
 * │ 剪枝     │ 可以             │ 天然最优子结构  │
 * └──────────┴─────────────────┴─────────────────┘
 *
 * 联系：
 * - 回溯可以加记忆化变成 DP
 * - 有些问题两种方法都能做
 *
 * 例：背包问题
 * - 求最大价值 → DP
 * - 求所有装法 → 回溯
 *
 * 例：组合总和
 * - 求方案数 → DP
 * - 求所有方案 → 回溯
 *
 * 实际面试中的判断：
 * - "所有"、"列出"、"打印" → 回溯
 * - "最大"、"最小"、"多少种" → DP」
 *
 * 🔄 可能的追问：
 * - 回溯能加记忆化吗？
 * - 什么问题两种方法都能做？
 */

// ============================================================
// Q9: 电话号码的字母组合怎么解？
// ============================================================

/**
 * 📝 问题：电话号码的字母组合怎么用回溯解决？
 *
 * ✅ 标准答案：
 * 每个数字对应多个字母，依次选择每个数字对应的字母组合。
 *
 * 与普通组合的区别：
 * - 普通组合：从同一个数组选
 * - 这道题：从不同的数组选
 *
 * ⭐ 加分回答：
 * 「这是"多个选择列表"的组合问题。
 *
 * const mapping = {
 *   '2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl',
 *   '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'
 * };
 *
 * function backtrack(index, path) {
 *   if (index === digits.length) {
 *     result.push(path);
 *     return;
 *   }
 *
 *   const letters = mapping[digits[index]];
 *   for (const letter of letters) {
 *     backtrack(index + 1, path + letter);
 *   }
 * }
 *
 * 这道题的特点：
 * 1. 用 index 表示当前处理第几个数字
 * 2. 选择列表是当前数字对应的字母
 * 3. 不需要 used 或 start，因为每个数字只处理一次
 *
 * 优化：
 * - 这道题用字符串拼接 path + letter
 * - 因为字符串是不可变的，不需要撤销
 * - 如果用数组需要 push/pop」
 *
 * 🔄 可能的追问：
 * - 为什么用字符串不用撤销？
 * - 时间复杂度是多少？（O(4^n)，最多每个数字4个字母）
 */

// ============================================================
// Q10: 单词搜索问题怎么解？
// ============================================================

/**
 * 📝 问题：在二维网格中搜索单词怎么做？
 *
 * ✅ 标准答案：
 * DFS + 回溯，从每个格子出发尝试匹配。
 *
 * 步骤：
 * 1. 遍历每个格子作为起点
 * 2. DFS 四个方向
 * 3. 匹配成功继续，失败回溯
 * 4. 标记已访问防止重复
 *
 * ⭐ 加分回答：
 * 「这是二维回溯的经典题。
 *
 * function exist(board, word) {
 *   for (let i = 0; i < rows; i++) {
 *     for (let j = 0; j < cols; j++) {
 *       if (dfs(i, j, 0)) return true;
 *     }
 *   }
 *   return false;
 * }
 *
 * function dfs(i, j, k) {
 *   // 边界检查
 *   if (i < 0 || i >= rows || j < 0 || j >= cols) return false;
 *   // 字符不匹配
 *   if (board[i][j] !== word[k]) return false;
 *   // 找到了
 *   if (k === word.length - 1) return true;
 *
 *   // 标记已访问
 *   const temp = board[i][j];
 *   board[i][j] = '#';
 *
 *   // 四个方向
 *   const found = dfs(i+1, j, k+1) || dfs(i-1, j, k+1) ||
 *                 dfs(i, j+1, k+1) || dfs(i, j-1, k+1);
 *
 *   // 撤销（回溯）
 *   board[i][j] = temp;
 *
 *   return found;
 * }
 *
 * 技巧：
 * 1. 原地修改标记已访问，避免额外空间
 * 2. 提前返回，找到就停止
 * 3. 方向数组简化代码
 *
 * 进阶：单词搜索 II（多个单词）
 * - 用字典树优化」
 *
 * 🔄 可能的追问：
 * - 时间复杂度是多少？
 * - 多个单词怎么优化？（Trie）
 */

// ============================================================
// 📋 面试问答速查表
// ============================================================

/**
 * ┌─────────────────────────────────────────────────────────────────────────┐
 * │                           面试问答速查表                                 │
 * ├────────────────────────────────────┬────────────────────────────────────┤
 * │           问题类型                 │              核心答案要点           │
 * ├────────────────────────────────────┼────────────────────────────────────┤
 * │ 回溯是什么                         │ 穷举+剪枝，做选择→递归→撤销选择     │
 * │ 排列/组合/子集区别                 │ 顺序有关→排列，无关→组合/子集       │
 * │ 重复元素去重                       │ 排序+同层跳过，排列用!used[i-1]     │
 * │ 剪枝优化                           │ 不满足条件提前return/continue/break │
 * │ 结果为什么要拷贝                   │ 引用类型，后续修改会影响已收集结果   │
 * │ 可重复选                           │ 递归传i而不是i+1                    │
 * │ N皇后                              │ 逐行放置，检查列和对角线             │
 * │ 回溯 vs DP                         │ 求所有解→回溯，求最优→DP            │
 * │ 电话号码组合                       │ 多个选择列表的组合                   │
 * │ 单词搜索                           │ 二维DFS+回溯，原地标记               │
 * └────────────────────────────────────┴────────────────────────────────────┘
 */

// ============================================================
// 🎯 回答问题的技巧
// ============================================================

/**
 * 回溯题目的回答模板：
 *
 * 1. 识别问题类型：
 *    「这是一个[排列/组合/子集/分割/棋盘]问题」
 *
 * 2. 确定去重方式：
 *    「因为[顺序有关/无关]，用[used数组/start参数]去重」
 *
 * 3. 说明收集时机：
 *    「当[path长度=n/满足条件/每个节点]时收集结果」
 *
 * 4. 是否需要剪枝：
 *    「可以通过[条件]剪枝优化」
 *
 * 5. 复杂度分析：
 *    「时间 O(n!/2^n)，空间 O(n)递归栈」
 *
 * 示例回答（全排列）：
 * 「这是一个排列问题，[1,2] 和 [2,1] 是不同的结果。
 * 用 used 数组标记已选元素，每次从头遍历跳过已选的。
 * 当 path.length 等于数组长度时收集结果。
 * 如果有重复元素，先排序，然后用 !used[i-1] 判断同层去重。
 * 时间复杂度 O(n!)，空间复杂度 O(n)。」
 */

export {};

