/**
 * 📝 题目：解数独
 * 🔗 链接：https://leetcode.cn/problems/sudoku-solver/
 * 🏷️ 难度：Hard
 * 🏷️ 标签：数组、哈希表、回溯、矩阵
 *
 * 📋 题目描述：
 * 编写一个程序，通过填充空格来解决数独问题。
 *
 * 数独的解法需 遵循如下规则：
 * 1. 数字 1-9 在每一行只能出现一次
 * 2. 数字 1-9 在每一列只能出现一次
 * 3. 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次
 *
 * 空白格用 '.' 表示。
 *
 * 示例：
 * 输入：
 * [["5","3",".",".","7",".",".",".","."],
 *  ["6",".",".","1","9","5",".",".","."],
 *  [".","9","8",".",".",".",".","6","."],
 *  ["8",".",".",".","6",".",".",".","3"],
 *  ["4",".",".","8",".","3",".",".","1"],
 *  ["7",".",".",".","2",".",".",".","6"],
 *  [".","6",".",".",".",".","2","8","."],
 *  [".",".",".","4","1","9",".",".","5"],
 *  [".",".",".",".","8",".",".","7","9"]]
 */

// ============================================================
// 💡 思路分析：这道题的解法是怎么想出来的？
// ============================================================
//
// 典型的约束满足问题 (CSP)
//
// 回溯思路：
// 1. 找到一个空格
// 2. 尝试填入 1-9
// 3. 检查是否满足三个约束
// 4. 如果满足，递归处理下一个空格
// 5. 如果不满足或后续无解，撤销并尝试下一个数字
//
// 优化：
// - 用位运算或集合记录每行/列/宫已使用的数字
// - 找空格时可以优先选择选择最少的格子（MRV 启发式）

// ============================================================
// 解法：回溯
// ============================================================
// ⏱️ 时间复杂度：O(9^(81)) 最坏，实际远小于 | 空间复杂度：O(81)

/**
 * 📊 数独约束图解：
 *
 * ┌───────┬───────┬───────┐
 * │ 5 3 . │ . 7 . │ . . . │  ← 行约束
 * │ 6 . . │ 1 9 5 │ . . . │
 * │ . 9 8 │ . . . │ . 6 . │
 * ├───────┼───────┼───────┤
 * │ 8 . . │ . 6 . │ . . 3 │
 * │ 4 . . │ 8 . 3 │ . . 1 │
 * │ 7 . . │ . 2 . │ . . 6 │
 * ├───────┼───────┼───────┤
 * │ . 6 . │ . . . │ 2 8 . │
 * │ . . . │ 4 1 9 │ . . 5 │
 * │ . . . │ . 8 . │ . 7 9 │
 * └───────┴───────┴───────┘
 *   ↑ 列约束    ↑ 3x3宫约束
 *
 * 宫的索引：boxIndex = floor(row/3) * 3 + floor(col/3)
 */
function solveSudoku(board: string[][]): void {
  // 记录每行、每列、每个 3x3 宫格中已使用的数字
  const rows: Set<string>[] = Array.from({ length: 9 }, () => new Set());
  const cols: Set<string>[] = Array.from({ length: 9 }, () => new Set());
  const boxes: Set<string>[] = Array.from({ length: 9 }, () => new Set());

  // 初始化已有数字
  for (let r = 0; r < 9; r++) {
    for (let c = 0; c < 9; c++) {
      if (board[r][c] !== '.') {
        const num = board[r][c];
        const boxIndex = Math.floor(r / 3) * 3 + Math.floor(c / 3);
        rows[r].add(num);
        cols[c].add(num);
        boxes[boxIndex].add(num);
      }
    }
  }

  function backtrack(row: number, col: number): boolean {
    // 找下一个空格
    while (row < 9 && board[row][col] !== '.') {
      col++;
      if (col === 9) {
        col = 0;
        row++;
      }
    }

    // 所有格子都填完了
    if (row === 9) {
      return true;
    }

    const boxIndex = Math.floor(row / 3) * 3 + Math.floor(col / 3);

    // 尝试填入 1-9
    for (let num = 1; num <= 9; num++) {
      const numStr = String(num);

      // 检查是否满足约束
      if (rows[row].has(numStr) || cols[col].has(numStr) || boxes[boxIndex].has(numStr)) {
        continue;
      }

      // 填入数字
      board[row][col] = numStr;
      rows[row].add(numStr);
      cols[col].add(numStr);
      boxes[boxIndex].add(numStr);

      // 递归
      if (backtrack(row, col)) {
        return true; // 找到解，直接返回
      }

      // 撤销
      board[row][col] = '.';
      rows[row].delete(numStr);
      cols[col].delete(numStr);
      boxes[boxIndex].delete(numStr);
    }

    return false; // 无解
  }

  backtrack(0, 0);
}

// ============================================================
// 🔑 宫格索引的计算
// ============================================================

/**
 * 9x9 数独分成 9 个 3x3 宫格
 *
 * 宫格索引：
 * ┌───┬───┬───┐
 * │ 0 │ 1 │ 2 │
 * ├───┼───┼───┤
 * │ 3 │ 4 │ 5 │
 * ├───┼───┼───┤
 * │ 6 │ 7 │ 8 │
 * └───┴───┴───┘
 *
 * boxIndex = floor(row / 3) * 3 + floor(col / 3)
 *
 * 例如：
 * (0,0) → 0, (0,5) → 1, (4,4) → 4, (8,8) → 8
 */

// ============================================================
// ⚠️ 易错点
// ============================================================
/**
 * 1. 返回值：
 *    - 需要返回 boolean，表示是否找到解
 *    - 找到解后立即返回 true，停止搜索
 *
 * 2. 宫格索引计算：
 *    - boxIndex = floor(row/3) * 3 + floor(col/3)
 *    - 不要写错公式
 *
 * 3. 数字类型：
 *    - 题目给的是字符串 '1'-'9'
 *    - 注意类型转换
 *
 * 4. 状态撤销：
 *    - 要完整撤销所有标记
 */

// ============================================================
// 🔗 举一反三：相似题目
// ============================================================
/**
 * - 有效的数独 → 只验证不求解
 * - N 皇后 → 类似的约束满足问题
 */

// ============================================================
// 🏢 前端业务场景
// ============================================================
/**
 * 1. 表格验证：多重约束的表格数据校验
 * 2. 排班系统：满足多种约束的自动排班
 * 3. 游戏开发：数独游戏的自动求解和生成
 */

export { solveSudoku };
export default solveSudoku;

