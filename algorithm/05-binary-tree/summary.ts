/**
 * ============================================================
 * 📊 Step 05: 二叉树 - 问题归类总结
 * ============================================================
 *
 * 本文件用于帮助你：
 * 1. 快速识别问题类型
 * 2. 选择合适的解法模式
 * 3. 建立题目之间的联系
 */

// ============================================================
// 1. 题目分类
// ============================================================

/**
 * ┌─────────────────────────────────────────────────────────────────────┐
 * │                        二叉树问题分类                                │
 * ├─────────────────────────────────────────────────────────────────────┤
 * │                                                                     │
 * │  【遍历类】                                                          │
 * │   ├─ 二叉树的前序遍历                       Easy                    │
 * │   ├─ 二叉树的中序遍历                       Easy                    │
 * │   ├─ 二叉树的后序遍历                       Easy                    │
 * │   ├─ 二叉树的层序遍历                       Medium                  │
 * │   └─ 二叉树的锯齿形层序遍历                 Medium                  │
 * │                                                                     │
 * │  【属性类】                                                          │
 * │   ├─ 二叉树的最大深度                       Easy                    │
 * │   ├─ 二叉树的最小深度                       Easy                    │
 * │   ├─ 翻转二叉树                             Easy                    │
 * │   ├─ 对称二叉树                             Easy                    │
 * │   ├─ 平衡二叉树                             Easy                    │
 * │   └─ 相同的树                               Easy                    │
 * │                                                                     │
 * │  【路径类】                                                          │
 * │   ├─ 路径总和                               Easy                    │
 * │   ├─ 路径总和 II                            Medium                  │
 * │   ├─ 二叉树的直径                           Easy                    │
 * │   └─ 二叉树中的最大路径和                   Hard                    │
 * │                                                                     │
 * │  【构造类】                                                          │
 * │   ├─ 从前序与中序遍历序列构造二叉树         Medium                  │
 * │   ├─ 从中序与后序遍历序列构造二叉树         Medium                  │
 * │   └─ 将有序数组转换为二叉搜索树             Easy                    │
 * │                                                                     │
 * │  【BST 类】                                                          │
 * │   ├─ 验证二叉搜索树                         Medium                  │
 * │   ├─ 二叉搜索树中第 K 小的元素              Medium                  │
 * │   └─ 二叉搜索树的最近公共祖先               Easy                    │
 * │                                                                     │
 * │  【公共祖先/结构】                                                    │
 * │   ├─ 二叉树的最近公共祖先                   Medium                  │
 * │   ├─ 二叉树展开为链表                       Medium                  │
 * │   └─ 二叉树的序列化与反序列化               Hard                    │
 * │                                                                     │
 * └─────────────────────────────────────────────────────────────────────┘
 */

// ============================================================
// 2. 信号词 → 解法模式
// ============================================================

/**
 * 🎯 信号词识别表
 *
 * ┌──────────────────────┬────────────────────────┬──────────────────────┐
 * │      信号词          │       解法模式          │       典型题目        │
 * ├──────────────────────┼────────────────────────┼──────────────────────┤
 * │ 前序/中序/后序       │ DFS 递归/迭代          │ 二叉树遍历            │
 * │ 层序、每层、BFS      │ BFS + 队列             │ 层序遍历              │
 * │                      │                        │                      │
 * │ 深度、高度           │ 递归分解               │ 最大深度              │
 * │ 对称、相同           │ 递归比较               │ 对称二叉树            │
 * │ 翻转、镜像           │ 递归交换               │ 翻转二叉树            │
 * │                      │                        │                      │
 * │ 路径、路径和         │ DFS + 回溯             │ 路径总和              │
 * │ 最大路径和           │ 后序位置计算           │ 最大路径和            │
 * │                      │                        │                      │
 * │ 构造、还原           │ 递归 + 分治            │ 前序+中序构造         │
 * │ 序列化               │ DFS/BFS + 标记空节点   │ 序列化与反序列化      │
 * │                      │                        │                      │
 * │ 第 K 大/小（BST）    │ 中序遍历               │ BST 第 K 小           │
 * │ 验证 BST             │ 中序递增/区间限制      │ 验证二叉搜索树        │
 * │ 公共祖先             │ 递归搜索               │ 最近公共祖先          │
 * │ 展开、链表           │ 前序遍历 + 指针操作    │ 展开为链表            │
 * └──────────────────────┴────────────────────────┴──────────────────────┘
 */

// ============================================================
// 3. 递归思维框架
// ============================================================

/**
 * 📋 二叉树递归两种思路：
 *
 * ```mermaid
 * flowchart TD
 *     A[二叉树问题] --> B{问题类型?}
 *     B -->|遍历相关| C[遍历思路]
 *     B -->|属性/结构| D[分解思路]
 *
 *     C --> C1[用外部变量记录结果]
 *     C --> C2[像遍历树一样走一遍]
 *     C --> C3[前序/中序/后序位置处理]
 *
 *     D --> D1[函数有返回值]
 *     D --> D2[子问题推导出当前问题]
 *     D --> D3[类似动态规划思想]
 * ```
 *
 * 【遍历思路】
 * - 定义外部变量存储结果
 * - 在遍历过程中更新结果
 * - 适合：统计、搜索、路径记录
 *
 * 【分解思路】
 * - 函数返回子问题的解
 * - 由子问题组合出当前问题的解
 * - 适合：深度、判断结构、构造
 */

// ============================================================
// 4. 三个遍历位置
// ============================================================

/**
 * 📊 前序、中序、后序位置的意义：
 *
 * function traverse(root) {
 *   if (!root) return;
 *
 *   // 前序位置：进入节点时
 *   // - 适合自顶向下的逻辑
 *   // - 比如：传递参数给子树
 *
 *   traverse(root.left);
 *
 *   // 中序位置：左子树处理完，准备处理右子树
 *   // - BST 中是有序访问的位置
 *
 *   traverse(root.right);
 *
 *   // 后序位置：离开节点时
 *   // - 适合自底向上的逻辑
 *   // - 比如：汇总子树信息
 * }
 *
 * 选择指南：
 * ┌──────────┬──────────────────────────────────────────┐
 * │ 位置     │ 适用场景                                  │
 * ├──────────┼──────────────────────────────────────────┤
 * │ 前序位置 │ 需要先处理根再处理子树（传递信息向下）    │
 * │ 中序位置 │ BST 相关，需要有序访问                    │
 * │ 后序位置 │ 需要先知道子树信息再处理根（汇总信息向上）│
 * └──────────┴──────────────────────────────────────────┘
 */

// ============================================================
// 5. 本章习题清单
// ============================================================

export const problemList = {
  easy: [
    {
      id: '001',
      title: '二叉树的最大深度',
      leetcode: 104,
      techniques: ['递归分解', 'BFS'],
      keyPoint: '分解思路入门题',
    },
    {
      id: '002',
      title: '翻转二叉树',
      leetcode: 226,
      techniques: ['递归', 'BFS'],
      keyPoint: '前序/后序都可以，但不能中序',
    },
    {
      id: '003',
      title: '对称二叉树',
      leetcode: 101,
      techniques: ['递归', 'BFS'],
      keyPoint: '镜像比较：左左对右右',
    },
    {
      id: '004',
      title: '路径总和',
      leetcode: 112,
      techniques: ['递归', 'DFS'],
      keyPoint: '必须到达叶子节点',
    },
    {
      id: '005',
      title: '二叉树的前序遍历',
      leetcode: 144,
      techniques: ['递归', '迭代', 'Morris'],
      keyPoint: '三种遍历方式的基础',
    },
    {
      id: '006',
      title: '二叉树的直径',
      leetcode: 543,
      techniques: ['后序遍历', 'DFS'],
      keyPoint: '左深度+右深度，后序位置更新',
    },
  ],

  medium: [
    {
      id: '001',
      title: '二叉树的层序遍历',
      leetcode: 102,
      techniques: ['BFS', '递归'],
      keyPoint: 'BFS 模板题，记录层大小',
    },
    {
      id: '002',
      title: '验证二叉搜索树',
      leetcode: 98,
      techniques: ['中序遍历', '区间限制'],
      keyPoint: '不能只比较直接子节点',
    },
    {
      id: '003',
      title: '二叉树的最近公共祖先',
      leetcode: 236,
      techniques: ['递归'],
      keyPoint: '左右都找到则当前为 LCA',
    },
    {
      id: '004',
      title: '从前序与中序遍历序列构造二叉树',
      leetcode: 105,
      techniques: ['递归', '分治'],
      keyPoint: '前序第一个是根，中序划分左右',
    },
    {
      id: '005',
      title: '二叉树展开为链表',
      leetcode: 114,
      techniques: ['递归', '前驱节点'],
      keyPoint: '后序位置处理',
    },
    {
      id: '006',
      title: '二叉搜索树中第 K 小的元素',
      leetcode: 230,
      techniques: ['中序遍历'],
      keyPoint: 'BST 中序是有序的',
    },
    {
      id: '007',
      title: '二叉树的右视图',
      leetcode: 199,
      techniques: ['BFS', 'DFS'],
      keyPoint: 'BFS每层最后一个，或DFS先右后左',
    },
  ],

  hard: [
    {
      id: '001',
      title: '二叉树中的最大路径和',
      leetcode: 124,
      techniques: ['递归', '后序位置'],
      keyPoint: '区分向上贡献和经过当前节点的路径',
    },
    {
      id: '002',
      title: '二叉树的序列化与反序列化',
      leetcode: 297,
      techniques: ['DFS', 'BFS'],
      keyPoint: '空节点必须标记',
    },
  ],
};

// ============================================================
// 6. 学习检查清单
// ============================================================

/**
 * ✅ 二叉树学习检查清单：
 *
 * 基础遍历：
 * □ 能写出递归版前/中/后序遍历
 * □ 能写出迭代版前/中/后序遍历
 * □ 能写出层序遍历（BFS）
 * □ 理解三种递归位置的意义
 *
 * 递归思维：
 * □ 理解遍历思路和分解思路的区别
 * □ 能用分解思路求最大深度
 * □ 能用递归判断对称/相同的树
 *
 * 路径问题：
 * □ 能解决根到叶子的路径和问题
 * □ 能解决最大路径和问题（Hard）
 *
 * BST 相关：
 * □ 理解 BST 的性质（左 < 根 < 右）
 * □ 能用中序遍历验证 BST
 * □ 能在 BST 中找第 K 小元素
 *
 * 构造与序列化：
 * □ 能从前序+中序构造二叉树
 * □ 能序列化和反序列化二叉树
 *
 * 其他重要题目：
 * □ 能找到二叉树的最近公共祖先
 * □ 能将二叉树展开为链表
 */

// ============================================================
// 7. 常见错误总结
// ============================================================

/**
 * ⚠️ 二叉树常见错误：
 *
 * 1. Base Case 遗漏
 *    错误: 忘记处理空节点
 *    正确: if (!root) return null/0/true;
 *
 * 2. 遍历位置选错
 *    错误: 翻转二叉树用中序遍历
 *    正确: 用前序或后序，中序会翻转两次
 *
 * 3. BST 验证只比较直接子节点
 *    错误: root.val > root.left.val
 *    正确: 用区间限制或中序遍历
 *
 * 4. 路径问题忘记回溯
 *    错误: path.push(node.val) 后不 pop
 *    正确: 递归返回后要恢复状态
 *
 * 5. 最大路径和的两种计算混淆
 *    错误: 返回 left + node + right
 *    正确: 返回 max(left, right) + node，但更新答案时用 left + node + right
 *
 * 6. 构造树时区间划分错误
 *    错误: leftSize = rootIndex
 *    正确: leftSize = rootIndex - inStart
 */

// ============================================================
// 8. 复杂度速查表
// ============================================================

/**
 * ┌─────────────────────────┬────────────┬────────────┐
 * │        操作             │ 时间复杂度  │ 空间复杂度  │
 * ├─────────────────────────┼────────────┼────────────┤
 * │ 递归遍历                │   O(n)     │   O(h)     │
 * │ 迭代遍历（栈）          │   O(n)     │   O(h)     │
 * │ 层序遍历（队列）        │   O(n)     │   O(w)     │
 * │ Morris 遍历             │   O(n)     │   O(1)     │
 * │ 求深度/高度             │   O(n)     │   O(h)     │
 * │ 判断对称/相同           │   O(n)     │   O(h)     │
 * │ 构造二叉树              │   O(n)     │   O(n)     │
 * │ 最近公共祖先            │   O(n)     │   O(h)     │
 * │ BST 查找                │ O(h)       │   O(h)     │
 * │ BST 中序遍历            │   O(n)     │   O(h)     │
 * └─────────────────────────┴────────────┴────────────┘
 *
 * h = 树高，平衡时 O(log n)，最坏时 O(n)
 * w = 最大宽度，完全二叉树约为 n/2
 */

// ============================================================
// 9. 面试高频问答速查
// ============================================================

/**
 * 📋 面试必会问答（详细内容见 interview-qa.ts）
 *
 * ┌───────────────────────────────────────────────────────────────────────┐
 * │ Q: 前中后序遍历有什么区别？                                            │
 * │ A: 根的访问位置不同，前序自顶向下，后序自底向上，中序用于BST           │
 * ├───────────────────────────────────────────────────────────────────────┤
 * │ Q: 递归和迭代遍历有什么区别？                                          │
 * │ A: 本质一样（都用栈），迭代更可控，Morris可O(1)空间                    │
 * ├───────────────────────────────────────────────────────────────────────┤
 * │ Q: 如何验证二叉搜索树？                                                │
 * │ A: 中序遍历递增，或区间限制法，不能只比较直接子节点                    │
 * ├───────────────────────────────────────────────────────────────────────┤
 * │ Q: 最近公共祖先怎么找？                                                │
 * │ A: 递归搜索，左右都找到则当前是LCA，否则返回找到的那边                 │
 * ├───────────────────────────────────────────────────────────────────────┤
 * │ Q: 最大路径和怎么求？                                                  │
 * │ A: 后序遍历，区分向上贡献和经过当前节点的路径，用全局变量更新最大值    │
 * ├───────────────────────────────────────────────────────────────────────┤
 * │ Q: 前序+中序如何构造二叉树？                                           │
 * │ A: 前序确定根，中序划分左右子树，递归构建                              │
 * └───────────────────────────────────────────────────────────────────────┘
 */

// ============================================================
// 10. 进阶变形题识别指南
// ============================================================

/**
 * 🧩 遍历系列
 *
 * ┌─────────────────────────────────────────────────────────────┐
 * │  前序遍历 → 递归/迭代/Morris                                │
 * │  层序遍历 → BFS + 记录层大小                                │
 * │  锯齿形层序 → 层序 + 奇偶层反转                             │
 * │  右视图/左视图 → 层序每层最后/第一个，或DFS先右/左          │
 * └─────────────────────────────────────────────────────────────┘
 *
 * 🧩 属性/结构系列
 *
 * ┌─────────────────────────────────────────────────────────────┐
 * │  最大深度 → 分解思路，max(左,右)+1                          │
 * │  最小深度 → 注意空子树情况                                  │
 * │  二叉树直径 → 左深度+右深度，后序更新                       │
 * │  平衡二叉树 → 后序求深度，顺便检查差值                      │
 * │  对称二叉树 → 递归比较，左左对右右                          │
 * └─────────────────────────────────────────────────────────────┘
 *
 * 🧩 路径系列
 *
 * ┌─────────────────────────────────────────────────────────────┐
 * │  路径总和 → DFS + 减法，到叶子时检查                        │
 * │  路径总和 II → DFS + 回溯，记录路径                         │
 * │  最大路径和 → 后序，区分贡献值和路径值                      │
 * │  二叉树所有路径 → DFS + 回溯                                │
 * └─────────────────────────────────────────────────────────────┘
 *
 * 🧩 BST 系列
 *
 * ┌─────────────────────────────────────────────────────────────┐
 * │  验证 BST → 中序递增，或区间限制                            │
 * │  第 K 小 → 中序遍历计数                                     │
 * │  BST 公共祖先 → 利用 BST 性质，比普通二叉树简单             │
 * │  删除 BST 节点 → 三种情况，注意后继节点                     │
 * └─────────────────────────────────────────────────────────────┘
 *
 * 🧩 构造系列
 *
 * ┌─────────────────────────────────────────────────────────────┐
 * │  前序+中序 → 前序第一个是根，中序划分左右                   │
 * │  后序+中序 → 后序最后是根，中序划分左右                     │
 * │  有序数组转BST → 二分取中点为根                             │
 * │  序列化 → 空节点必须标记                                    │
 * └─────────────────────────────────────────────────────────────┘
 */

// ============================================================
// 11. 相关文件索引
// ============================================================

/**
 * 📂 本章文件结构：
 *
 * 05-binary-tree/
 * ├── index.ts              # 核心模板与基础讲解
 * ├── summary.ts            # 问题归类总结（本文件）
 * ├── interview-qa.ts       # 面试高频问答
 * ├── frontend-examples.ts  # 前端业务场景代码
 * ├── easy/
 * │   ├── 001-max-depth.ts
 * │   ├── 002-invert-binary-tree.ts
 * │   ├── 003-symmetric-tree.ts
 * │   ├── 004-path-sum.ts
 * │   ├── 005-binary-tree-preorder.ts
 * │   └── 006-diameter-of-binary-tree.ts
 * ├── medium/
 * │   ├── 001-level-order.ts
 * │   ├── 002-validate-bst.ts
 * │   ├── 003-lowest-common-ancestor.ts
 * │   ├── 004-construct-from-preorder-inorder.ts
 * │   ├── 005-flatten-binary-tree.ts
 * │   ├── 006-kth-smallest-bst.ts
 * │   └── 007-right-side-view.ts
 * └── hard/
 *     ├── 001-binary-tree-max-path-sum.ts
 *     └── 002-serialize-deserialize.ts
 */

export default problemList;

