/**
 * 📝 题目：翻转二叉树
 * 🔗 链接：https://leetcode.cn/problems/invert-binary-tree/
 * 🏷️ 难度：Easy
 * 🏷️ 标签：树、深度优先搜索、广度优先搜索、二叉树
 *
 * 📋 题目描述：
 * 给你一棵二叉树的根节点 root，翻转这棵二叉树，并返回其根节点。
 *
 * 示例：
 *      4                4
 *    /   \            /   \
 *   2     7    =>    7     2
 *  / \   / \        / \   / \
 * 1   3 6   9      9   6 3   1
 *
 * 输入：root = [4,2,7,1,3,6,9]
 * 输出：[4,7,2,9,6,3,1]
 */

class TreeNode {
  val: number;
  left: TreeNode | null;
  right: TreeNode | null;
  constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
    this.val = val === undefined ? 0 : val;
    this.left = left === undefined ? null : left;
    this.right = right === undefined ? null : right;
  }
}

// ============================================================
// 💡 思路分析：这道题的解法是怎么想出来的？
// ============================================================
//
// 翻转二叉树 = 交换每个节点的左右子节点
//
// 递归思路：
// - 翻转当前节点的左右子节点
// - 递归翻转左子树
// - 递归翻转右子树
//
// 可以前序、后序、层序，但不能中序！
// 中序会导致：翻转左 → 交换 → 翻转右（此时右是原来的左，会翻转两次）

// ============================================================
// 解法一：递归 - 前序（推荐）
// ============================================================
// ⏱️ 时间复杂度：O(n) | 空间复杂度：O(h)

/**
 * 📊 执行过程图解：
 *
 *      4              4              4
 *    /   \          /   \          /   \
 *   2     7   =>   7     2   =>   7     2
 *  / \   / \      / \   / \      / \   / \
 * 1   3 6   9    6   9 1   3    9   6 3   1
 *
 *  Step 1: 交换 4 的左右子节点
 *  Step 2: 递归翻转原右子树（现在是左子树）
 *  Step 3: 递归翻转原左子树（现在是右子树）
 */
function invertTree_v1(root: TreeNode | null): TreeNode | null {
  if (!root) return null;

  // 前序位置：先交换左右子节点
  [root.left, root.right] = [root.right, root.left];

  // 递归翻转左右子树
  invertTree_v1(root.left);
  invertTree_v1(root.right);

  return root;
}

// ============================================================
// 解法二：递归 - 后序
// ============================================================
// ⏱️ 时间复杂度：O(n) | 空间复杂度：O(h)
function invertTree_v2(root: TreeNode | null): TreeNode | null {
  if (!root) return null;

  // 先递归翻转左右子树
  const left = invertTree_v2(root.left);
  const right = invertTree_v2(root.right);

  // 后序位置：交换左右子节点
  root.left = right;
  root.right = left;

  return root;
}

// ============================================================
// 解法三：BFS 层序遍历
// ============================================================
// ⏱️ 时间复杂度：O(n) | 空间复杂度：O(w)
function invertTree_v3(root: TreeNode | null): TreeNode | null {
  if (!root) return null;

  const queue: TreeNode[] = [root];

  while (queue.length > 0) {
    const node = queue.shift()!;

    // 交换左右子节点
    [node.left, node.right] = [node.right, node.left];

    // 子节点入队
    if (node.left) queue.push(node.left);
    if (node.right) queue.push(node.right);
  }

  return root;
}

// ============================================================
// 🔄 解法对比
// ============================================================
/**
 * | 解法       | 时间  | 空间  | 特点                     |
 * |-----------|-------|-------|-------------------------|
 * | 前序递归   | O(n)  | O(h)  | 推荐，最直观              |
 * | 后序递归   | O(n)  | O(h)  | 同样可以                 |
 * | BFS       | O(n)  | O(w)  | 迭代方式                 |
 */

// ============================================================
// ⚠️ 易错点
// ============================================================
/**
 * 1. 不能用中序遍历：
 *    - 中序：左 → 根 → 右
 *    - 处理完左子树，交换，处理右子树
 *    - 但交换后，右子树是原来的左子树，会被处理两次！
 *
 * 2. 空节点处理：
 *    - 空节点直接返回 null
 *
 * 3. 返回值：
 *    - 返回 root，方便链式调用
 */

// ============================================================
// 🔗 举一反三：相似题目
// ============================================================
/**
 * - 对称二叉树 → 判断是否是翻转的
 * - 相同的树 → 结构比较
 */

// ============================================================
// 🏢 前端业务场景
// ============================================================
/**
 * 1. 镜像布局：实现 RTL（从右到左）布局
 * 2. 树形组件：翻转树形菜单的展开方向
 */

export { TreeNode, invertTree_v1, invertTree_v2, invertTree_v3 };
export default invertTree_v1;

