/**
 * ============================================================
 * 📚 二叉树 - 面试高频问答
 * ============================================================
 *
 * 本文件包含二叉树相关的面试高频问题，每个问题包含：
 * 1. 问题本身
 * 2. 标准答案
 * 3. 加分回答（展示深度理解）
 * 4. 追问方向
 */

// ============================================================
// Q1: 二叉树的前中后序遍历有什么区别？
// ============================================================

/**
 * 📝 问题：二叉树的前中后序遍历有什么区别？什么时候用哪种？
 *
 * ✅ 标准答案：
 *
 * 前序遍历（根 → 左 → 右）：
 * - 先访问根节点
 * - 适合自顶向下处理，如打印路径、复制树
 *
 * 中序遍历（左 → 根 → 右）：
 * - 根在中间访问
 * - BST 的中序遍历是有序的
 *
 * 后序遍历（左 → 右 → 根）：
 * - 最后访问根节点
 * - 适合自底向上汇总，如求高度、删除树
 *
 * ⭐ 加分回答：
 * 「这三种遍历本质上是一个递归框架的三个位置：
 *
 * function traverse(root) {
 *   if (!root) return;
 *
 *   // 前序位置：进入节点时
 *   traverse(root.left);
 *   // 中序位置：左子树处理完
 *   traverse(root.right);
 *   // 后序位置：离开节点时
 * }
 *
 * 选择指南：
 * - 需要先处理根再处理子树 → 前序
 * - 需要先知道子树信息才能处理根 → 后序
 * - BST 相关问题 → 中序
 *
 * 例如：
 * - 求树的深度：后序（需要先知道左右子树深度）
 * - 翻转二叉树：前序或后序都行，但不能中序（会翻转两次）
 * - 验证 BST：中序遍历判断是否递增」
 *
 * 🔄 可能的追问：
 * - 为什么翻转二叉树不能用中序？
 * - 迭代版本怎么写？
 */

// ============================================================
// Q2: 递归遍历和迭代遍历有什么区别？
// ============================================================

/**
 * 📝 问题：二叉树遍历用递归和迭代有什么区别？什么时候用迭代？
 *
 * ✅ 标准答案：
 *
 * 递归：
 * - 代码简洁易懂
 * - 系统维护调用栈
 * - 可能栈溢出（深度很大时）
 *
 * 迭代：
 * - 手动维护栈
 * - 更可控，可以随时停止
 * - 空间可优化（如 Morris 遍历 O(1)）
 *
 * ⭐ 加分回答：
 * 「递归和迭代本质是一样的，都是用栈。
 * 递归用的是系统调用栈，迭代用的是自己维护的栈。
 *
 * 什么时候用迭代？
 * 1. 担心栈溢出：树非常深或不平衡
 * 2. 需要中途停止：如找到第 K 个就返回
 * 3. 面试官要求
 *
 * 迭代的三种遍历：
 * - 前序最简单：弹出访问，右左入栈
 * - 中序用循环：一直走到最左，回溯访问
 * - 后序最复杂：用标记法或反转结果
 *
 * Morris 遍历可以做到 O(1) 空间，
 * 利用叶子节点的空指针临时建立连接，
 * 但会临时修改树结构，不是所有场景都适用。」
 *
 * 🔄 可能的追问：
 * - 中序迭代怎么写？
 * - Morris 遍历的原理？
 */

// ============================================================
// Q3: BFS 和 DFS 有什么区别？
// ============================================================

/**
 * 📝 问题：二叉树的 BFS 和 DFS 有什么区别？什么时候用哪个？
 *
 * ✅ 标准答案：
 *
 * DFS（深度优先）：
 * - 一条路走到底再回溯
 * - 用栈实现（递归/迭代）
 * - 空间 O(h)，h 是树高
 *
 * BFS（广度优先）：
 * - 一层一层遍历
 * - 用队列实现
 * - 空间 O(w)，w 是最大宽度
 *
 * ⭐ 加分回答：
 * 「选择指南：
 *
 * 用 DFS 的场景：
 * - 路径问题（需要回溯）
 * - 求深度/高度
 * - 需要先处理叶子节点
 *
 * 用 BFS 的场景：
 * - 层序相关（每层处理、层数）
 * - 最短路径（无权图）
 * - 需要逐层扩展
 *
 * 空间复杂度对比：
 * - 平衡树：DFS O(log n)，BFS O(n/2)
 * - 链状树：DFS O(n)，BFS O(1)
 *
 * 层序遍历的关键技巧：
 * 用 levelSize = queue.length 记录当前层的节点数，
 * 这样可以知道一层什么时候结束。」
 *
 * 🔄 可能的追问：
 * - 层序遍历怎么知道一层结束了？
 * - 锯齿形层序遍历怎么做？
 */

// ============================================================
// Q4: 二叉树的最大深度怎么求？
// ============================================================

/**
 * 📝 问题：二叉树的最大深度怎么求？有几种方法？
 *
 * ✅ 标准答案：
 *
 * 方法一：递归（分解思路）
 * - maxDepth(root) = 1 + max(maxDepth(left), maxDepth(right))
 * - 时间 O(n)，空间 O(h)
 *
 * 方法二：BFS 层序遍历
 * - 遍历完成后统计层数
 * - 时间 O(n)，空间 O(w)
 *
 * ⭐ 加分回答：
 * 「这道题体现了二叉树的"分解思路"：
 *
 * 把问题分解为子问题：
 * - 树的最大深度 = 左子树深度和右子树深度的最大值 + 1
 *
 * 这是后序遍历的位置，因为需要先知道子树的深度。
 *
 * 深度 vs 高度的区别：
 * - 深度：从根到该节点的边数（自顶向下）
 * - 高度：从该节点到最远叶子的边数（自底向上）
 * - 根节点的高度 = 树的最大深度 - 1（边数表示）
 *
 * 还有一种遍历思路：
 * 在前序位置记录当前深度，到达节点时更新最大值，
 * 回溯时深度 -1。这种方式更像 DFS 遍历。」
 *
 * 🔄 可能的追问：
 * - 最小深度怎么求？（注意空子树）
 * - 分解思路和遍历思路有什么区别？
 */

// ============================================================
// Q5: 如何验证二叉搜索树？
// ============================================================

/**
 * 📝 问题：如何验证一棵树是否是二叉搜索树？
 *
 * ✅ 标准答案：
 *
 * 方法一：中序遍历递增
 * - BST 的中序遍历是严格递增的
 * - 遍历过程中检查是否递增
 *
 * 方法二：区间限制
 * - 每个节点有一个合法区间 (min, max)
 * - 递归时传递区间限制
 *
 * ⭐ 加分回答：
 * 「常见错误是只比较直接子节点：
 *
 *       5
 *      / \
 *     1   6
 *        / \
 *       3   7
 *
 * 3 < 6 满足，但 3 < 5 不满足（3 应该在 5 的右子树）。
 *
 * 正确做法是传递区间：
 * - 左子树的所有节点 < 根
 * - 右子树的所有节点 > 根
 *
 * function isValidBST(root, min, max) {
 *   if (!root) return true;
 *   if (root.val <= min || root.val >= max) return false;
 *   return isValidBST(root.left, min, root.val) &&
 *          isValidBST(root.right, root.val, max);
 * }
 *
 * 中序遍历法更简洁：
 * - 用一个 prev 变量记录前一个节点的值
 * - 每次检查 current > prev
 *
 * 注意：题目说的是严格大于，不是大于等于。」
 *
 * 🔄 可能的追问：
 * - 如果有重复值怎么处理？
 * - BST 中第 K 小的元素怎么找？
 */

// ============================================================
// Q6: 二叉树的最近公共祖先怎么找？
// ============================================================

/**
 * 📝 问题：如何找二叉树的最近公共祖先（LCA）？
 *
 * ✅ 标准答案：
 * 递归搜索：
 * 1. 如果当前节点是 p 或 q，返回当前节点
 * 2. 在左右子树分别搜索
 * 3. 如果左右都找到了，当前节点就是 LCA
 * 4. 如果只有一边找到，返回那一边的结果
 *
 * 时间 O(n)，空间 O(h)
 *
 * ⭐ 加分回答：
 * 「这道题的关键是理解递归的返回值：
 *
 * 返回值的含义：在以 root 为根的子树中，是否找到了 p 或 q
 *
 * 三种情况：
 * 1. p 和 q 分别在左右子树 → 当前节点是 LCA
 * 2. p 和 q 都在左子树 → 左子树的返回值就是 LCA
 * 3. p 和 q 都在右子树 → 右子树的返回值就是 LCA
 *
 * if (left && right) return root;  // 分别在左右
 * return left || right;            // 只有一边找到
 *
 * 变体：BST 的最近公共祖先
 * - 利用 BST 性质
 * - 如果 p, q 都小于 root，在左子树找
 * - 如果 p, q 都大于 root，在右子树找
 * - 否则 root 就是 LCA
 *
 * BST 版本时间复杂度可以优化到 O(h)。」
 *
 * 🔄 可能的追问：
 * - 如果不保证 p 和 q 都在树中呢？
 * - BST 的 LCA 怎么优化？
 */

// ============================================================
// Q7: 二叉树的序列化和反序列化怎么做？
// ============================================================

/**
 * 📝 问题：如何序列化和反序列化一棵二叉树？
 *
 * ✅ 标准答案：
 *
 * 方法一：前序遍历
 * - 用 # 或 null 标记空节点
 * - 序列化：前序遍历生成字符串
 * - 反序列化：按顺序构建
 *
 * 方法二：层序遍历
 * - 用 null 标记空节点
 * - 类似 LeetCode 的输入格式
 *
 * ⭐ 加分回答：
 * 「关键是空节点必须标记！
 *
 * 为什么需要标记空节点？
 * - 只用前序遍历结果无法唯一确定一棵树
 * - 前序 + 中序可以，但需要两个序列
 * - 标记空节点后，只需要一个序列
 *
 * 前序序列化：
 *      1
 *     / \
 *    2   3
 *       / \
 *      4   5
 *
 * 序列化：1,2,#,#,3,4,#,#,5,#,#
 *
 * 反序列化用队列：
 * - 取出一个值作为根
 * - 递归构建左子树
 * - 递归构建右子树
 *
 * 层序方法更直观，也是 LeetCode 官方的格式，
 * 但实现稍微复杂一些。」
 *
 * 🔄 可能的追问：
 * - 为什么前序+中序可以唯一确定一棵树？
 * - 如何压缩序列化结果？
 */

// ============================================================
// Q8: 二叉树中的最大路径和怎么求？
// ============================================================

/**
 * 📝 问题：如何求二叉树中的最大路径和？
 *
 * ✅ 标准答案：
 * 关键是理解"路径"的定义：
 * - 路径可以从任意节点开始到任意节点结束
 * - 路径上的节点只能出现一次
 *
 * 用后序遍历，在每个节点计算：
 * 1. 经过该节点的最大路径和（更新全局最大值）
 * 2. 该节点向上贡献的最大值（返回给父节点）
 *
 * ⭐ 加分回答：
 * 「这是一道经典的后序位置题目。
 *
 * 两个值的区别：
 * 1. 经过当前节点的路径：left + node + right
 *    - 这是完整路径，用于更新全局最大值
 *
 * 2. 向上贡献的值：max(left, right) + node
 *    - 只能选一边，因为路径不能分叉
 *    - 这个值返回给父节点使用
 *
 * 还要注意：
 * - 如果子树贡献是负数，可以不选（取 0）
 * - 节点值可能是负数
 *
 * function maxPathSum(node):
 *   if (!node) return 0
 *
 *   left = max(0, maxPathSum(node.left))
 *   right = max(0, maxPathSum(node.right))
 *
 *   // 更新全局最大值：经过当前节点的路径
 *   maxSum = max(maxSum, left + node.val + right)
 *
 *   // 返回向上贡献的值
 *   return max(left, right) + node.val
 *
 * 这道题考察对后序位置的理解，以及两种计算的区分。」
 *
 * 🔄 可能的追问：
 * - 为什么返回值和更新值不一样？
 * - 如果要求输出路径呢？
 */

// ============================================================
// Q9: 前序+中序如何构造二叉树？
// ============================================================

/**
 * 📝 问题：给定前序和中序遍历，如何构造二叉树？
 *
 * ✅ 标准答案：
 * 1. 前序第一个元素是根
 * 2. 在中序中找到根的位置
 * 3. 中序中根左边是左子树，右边是右子树
 * 4. 根据左子树大小，划分前序数组
 * 5. 递归构建左右子树
 *
 * ⭐ 加分回答：
 * 「这道题的关键是划分数组。
 *
 * 前序: [根, [左子树], [右子树]]
 * 中序: [[左子树], 根, [右子树]]
 *
 * 步骤：
 * 1. 前序第一个 = 根
 * 2. 在中序中找根的位置 rootIndex
 * 3. 左子树大小 = rootIndex - inStart
 * 4. 划分区间：
 *    - 左子树中序: [inStart, rootIndex - 1]
 *    - 右子树中序: [rootIndex + 1, inEnd]
 *    - 左子树前序: [preStart + 1, preStart + leftSize]
 *    - 右子树前序: [preStart + leftSize + 1, preEnd]
 *
 * 优化：用哈希表存储中序值到索引的映射，O(1) 查找。
 *
 * 为什么前序+中序或后序+中序可以唯一确定？
 * - 中序可以区分左右子树
 * - 前序/后序可以确定根
 *
 * 前序+后序不能唯一确定：
 * - 都只能确定根，不能区分左右子树
 * - 除非没有单子树的情况」
 *
 * 🔄 可能的追问：
 * - 后序+中序怎么构造？
 * - 时间复杂度是多少？（O(n)，用哈希表优化）
 */

// ============================================================
// Q10: React/Vue 虚拟 DOM 和二叉树有什么关系？
// ============================================================

/**
 * 📝 问题：React/Vue 的虚拟 DOM 和二叉树有什么关系？
 *
 * ✅ 标准答案：
 * 虚拟 DOM 本质上是一棵树结构（不一定是二叉树）。
 *
 * 相关操作：
 * - Diff 算法：树的比较
 * - 更新：树的遍历
 * - 渲染：树的序列化
 *
 * ⭐ 加分回答：
 * 「虚拟 DOM 和二叉树的联系：
 *
 * 1. 结构相似：
 *    - 都是树形结构
 *    - 节点有值和子节点
 *    - 可以用递归处理
 *
 * 2. Diff 算法：
 *    - 传统树 Diff 是 O(n³)
 *    - React 的 Diff 是 O(n)，因为有三个假设：
 *      a. 不同类型的元素产生不同的树
 *      b. 通过 key 标识同一层的子节点
 *      c. 同层比较，不跨层比较
 *
 * 3. Fiber 架构（React）：
 *    - Fiber 节点形成链表式的树
 *    - child、sibling、return 三个指针
 *    - 深度优先遍历 Fiber 树
 *
 * 4. 组件树：
 *    - 组件嵌套形成树
 *    - 生命周期是树的遍历
 *    - 状态更新触发子树重渲染
 *
 * 前端开发中很多数据结构都是树：
 * DOM 树、虚拟 DOM、AST、文件系统、路由配置...
 * 理解二叉树的操作对前端开发很有帮助。」
 *
 * 🔄 可能的追问：
 * - React Diff 算法的具体策略？
 * - 为什么 key 很重要？
 */

// ============================================================
// 📋 面试问答速查表
// ============================================================

/**
 * ┌─────────────────────────────────────────────────────────────────────────┐
 * │                           面试问答速查表                                 │
 * ├────────────────────────────────┬────────────────────────────────────────┤
 * │           问题类型             │              核心答案要点               │
 * ├────────────────────────────────┼────────────────────────────────────────┤
 * │ 前中后序区别                   │ 根的位置不同，适用场景不同              │
 * │ 递归 vs 迭代                   │ 本质一样，迭代更可控可优化              │
 * │ BFS vs DFS                    │ 层序用 BFS，路径用 DFS                  │
 * │ 最大深度                       │ 分解思路，max(左深度,右深度)+1          │
 * │ 验证 BST                       │ 中序递增，或区间限制                    │
 * │ 最近公共祖先                   │ 左右都找到则当前是 LCA                  │
 * │ 序列化                         │ 空节点必须标记                          │
 * │ 最大路径和                     │ 区分向上贡献和经过当前的路径            │
 * │ 前序+中序构造                  │ 前序确定根，中序划分左右                │
 * │ 虚拟 DOM                       │ 树结构，Diff 是树比较                   │
 * └────────────────────────────────┴────────────────────────────────────────┘
 */

// ============================================================
// 🎯 回答问题的技巧
// ============================================================

/**
 * 二叉树题目的回答模板：
 *
 * 1. 识别问题类型：
 *    「这是一个[遍历/属性/路径/构造/BST]类型的问题」
 *
 * 2. 选择遍历方式：
 *    「我用[前序/中序/后序/层序]遍历来解决」
 *
 * 3. 说明递归定义：
 *    「递归的定义是：对于每个节点...」
 *
 * 4. Base Case：
 *    「当节点为空时，返回...」
 *
 * 5. 复杂度分析：
 *    「时间 O(n)，因为每个节点访问一次；
 *      空间 O(h)，递归栈深度等于树高」
 *
 * 示例回答（最大深度）：
 * 「这是一个求属性的问题，我用分解思路来解决。
 * 定义：maxDepth(node) 返回以 node 为根的子树的最大深度。
 * 递归：maxDepth(node) = 1 + max(maxDepth(left), maxDepth(right))
 * Base Case：空节点返回 0。
 * 这是后序位置的处理，因为需要先知道子树的深度。
 * 时间 O(n)，空间 O(h)。」
 */

export {};

