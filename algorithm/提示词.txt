

Step 01：数组与双指针（提示词）

你现在是「资深前端工程师 + 算法面试官」，请为一本《前端算法面试通关指南》写其中的一个章节。

【章节信息】
- Step：01
- 主题：数组与双指针（包含：双指针、快慢指针、滑动窗口、前缀和等）
- 目标读者：有一定 JS/TS 基础的前端工程师，正在准备大厂前端算法面试

【输出要求】
1. 使用 Markdown 格式，整体结构清晰，有主标题和小节标题。
2. 整体语气友好、务实，偏「面试实战 + 前端场景」，不要太学术。
3. 所有代码示例使用 TypeScript。

【内容结构】
请严格按照下面的结构组织内容：

1. 概念速览
   - 一句话解释「数组与双指针」在算法中的角色
   - 说明本专题覆盖：对撞指针、快慢指针、滑动窗口、前缀和
   - 用 1 个简单的小例子解释什么是双指针（文字 + 简单示意）

2. 🎯 适用场景与信号词
   - 列出：什么时候应该优先考虑用双指针 / 滑动窗口 / 前缀和
   - 给出题目中常见的「关键词 / 信号词」，例如：
     - 「有序数组 + 找两个数」→ 对撞指针
     - 「原地去重 / 移动元素」→ 快慢指针
     - 「连续子数组/子串 + 最长/最短 + 满足某条件」→ 滑动窗口
     - 「子数组和 / 统计区间和」→ 前缀和
   - 简要对比：什么时候不用双指针（比如数据结构比较复杂时）

3. 问题归类与通用模型
   - 把本专题拆成 3 类核心模型：
     - 对撞指针模型
     - 快慢指针模型
     - 滑动窗口模型（可带前缀和）
   - 对每一类：
     - 用 2～3 句总结「这类题长什么样」
     - 用 1 个通用伪代码/思路描述核心套路

4. TypeScript 代码模板
   - 给出以下 3 个模板的通用写法（尽量精简，但要清晰）：
     - 「对撞指针」在有序数组中查找某种关系的模板
     - 「快慢指针」在数组/链表中做原地去重/移动元素的模板
     - 「滑动窗口」在字符串/数组中寻找满足条件的最长/最短子串的模板
   - 每个模板都用 TypeScript，适当加注释说明每个指针的含义

5. 典型题目精讲（至少 2 题）
   - 从下列题目中挑 2～3 题做「思路 + 多解法对比」：
     - 两数之和 II - 输入有序数组（对撞指针）
     - 移动零（快慢指针）
     - 删除有序数组中的重复项（快慢指针）
     - 三数之和（排序 + 双指针）
     - 盛最多水的容器（对撞指针）
     - 无重复字符的最长子串（滑动窗口）
     - 长度最小的子数组（滑动窗口）
     - 和为 K 的子数组（前缀和 + 哈希）
   - 每题结构：
     - 简短题意 + 关键点
     - 暴力解法思路（O(n²) 等）+ 为何会超时/不优
     - 优化解法（双指针或滑动窗口）详细思路 + TS 代码
     - 时间/空间复杂度分析
     - 这题能推广到哪一类问题（举一反三）

6. 复杂度与解法对比
   - 对比「暴力枚举」vs「双指针/滑动窗口」在时间复杂度上的差异
   - 举 1～2 个例子说明「用空间换时间」的典型场景（如前缀和）

7. ⚠️ 易错点与调试建议
   - 按类别列出常见坑：
     - 对撞指针：左右指针移动条件错误、死循环、边界漏解
     - 快慢指针：slow 与 fast 的含义混乱、覆盖顺序错误
     - 滑动窗口：左指针收缩条件、计数/条件维护错误
   - 给出简单的调试建议：用小样例手动跑一遍指针变化

8. 🏢 前端业务场景举例
   - 至少给出 3 个前端实际开发场景，说明数组 & 双指针 / 滑动窗口的应用：
     - 例如：日志列表中查找某时间区间、虚拟滚动窗口、推荐列表中寻找符合条件的连续片段等

9. 推荐练习题清单
   - 用 Markdown 表格列出本专题推荐的 10～16 道题
   - 每一行包含：难度（Easy/Medium/Hard）、题目名称、关键技巧（如「对撞指针 + 排序」）、建议练习顺序（1,2,3…）、LeetCode 题目链接（写出中文站链接即可）

请确保存量内容足够一个独立章节阅读，不要求写所有题的完整解法，但典型题要写得详细。











Step 02：哈希表与字符串（提示词）

你现在是「资深前端工程师 + 算法面试官」，请为《前端算法面试通关指南》写其中一个章节。

【章节信息】
- Step：02
- 主题：哈希表与字符串
- 目标读者：有一定 JS/TS 基础的前端工程师，准备前端算法面试

【输出要求】
1. 使用 Markdown 格式，结构清晰，有主标题和小节标题。
2. 风格偏「实战 + 可落地」，少讲抽象理论，多讲识题套路与代码。
3. 所有代码用 TypeScript。

【内容结构】

1. 概念速览
   - 一句话说明哈希表在算法题中的定位（「O(1) 查找的瑞士军刀」）
   - 一句话说明常见字符串问题涉及的核心操作（计数、匹配、查找、构造）
   - 简要说明：Map / Set 在 JavaScript / TypeScript 中的使用特点

2. 🎯 适用场景与信号词
   - 列出：什么时候优先考虑哈希表？
     - 「查找是否存在」「是否出现过」「统计频次」「去重」「前 K 个高频」
   - 列出：典型字符串信号词：
     - 「异位词」「回文串」「子串出现次数」「字符频率」等
   - 用几条规则帮助快速判断：用数组当哈希 vs 用 Map

3. 问题归类与模型
   - 把本专题分为 3 类模型：
     - 频次统计模型（如异位词、第一唯一字符）
     - 映射关系模型（如两数之和、同构字符串）
     - 字符串滑动窗口 + 哈希（如异位词子串、最小覆盖子串）
   - 每一类：
     - 总结问题长相
     - 给一个典型例子名字

4. TypeScript 代码模板
   - 频次统计模板：如何用 Map / 对象统计字符频次
   - 映射模型模板：如两数之和中「值 → 索引」的模式
   - 字符串滑动窗口 + 哈希的模板：窗口内频次数组/Map 维护方式

5. 典型题目精讲（至少 2～3 题）
   - 从下列题中选 2～3 题详细展开：
     - 两数之和（哈希表）
     - 有效的字母异位词（频次统计）
     - 字母异位词分组（排序 + 哈希 / 计数编码 + 哈希）
     - 最长回文子串（中心扩展/DP，可重点讲思路而非全代码）
     - 找到字符串中所有字母异位词（滑动窗口 + 频次统计）
     - 最长连续序列（哈希集合）
     - 前 K 个高频元素（哈希 + 堆）
   - 每题结构：
     - 题意精简 + 本题关键难点
     - 暴力思路 & 为何不优
     - 基于哈希的高效解法：详细思路 + TS 代码
     - 复杂度分析、适用场景、举一反三到其他题

6. 复杂度与解法对比
   - 说明哈希表带来的典型复杂度提升：O(n²) → O(n)
   - 简单讨论哈希表的空间消耗和时间换空间 trade-off

7. ⚠️ 易错点与注意事项
   - JS/TS 中对象键为字符串/符号的坑，建议优先使用 Map/Set
   - 统计频次时容易忘记删除为 0 的键、或比较两个 Map 是否相等
   - Unicode / 大小写 / 非字母字符的处理注意点（简要说明即可）

8. 🏢 前端业务场景
   - 至少举 3 个例子：
     - 例如：敏感词过滤（哈希 + 字典树预热）、前端埋点去重、缓存键值映射、字符串模板渲染中的占位符统计等

9. 推荐练习题清单
   - 用表格列出本专题的 10～16 道推荐题目：
     - 包含：难度、题目名称、关键标签（哈希/字符串/滑动窗口等）、LeetCode 中文站链接、建议练习顺序

请把本章节写得足够完整，可以独立阅读学习。














Step 03：链表（提示词）

你现在是「资深前端工程师 + 算法面试官」，请为《前端算法面试通关指南》写其中一个章节。

【章节信息】
- Step：03
- 主题：链表
- 目标读者：有一定 JS/TS 基础，了解基本数据结构，但对链表题不太熟练的前端工程师

【输出要求】
1. 使用 Markdown 格式，结构要清晰。
2. 所有代码使用 TypeScript，定义一个 ListNode 节点类型。
3. 重点放在：常见链表题型、快慢指针技巧、链表与数组的思维差异。

【内容结构】

1. 概念速览
   - 一句话解释：链表与数组的本质差异（内存连续性/随机访问 vs 指针/引用）
   - 简要说明：单向链表、双向链表、带随机指针链表

2. 🎯 适用场景与信号词
   - 什么时候题目在「暗示」你用链表思路？
     - 题目给出的是 ListNode 类型
     - 频繁插入删除、要求 O(1) 插入删除
   - 常见信号词：环、倒数第 N 个节点、重排、合并 K 个链表等

3. 问题归类与模型
   - 把链表问题分为 4 类：
     - 基本操作：反转、合并两个有序链表、删除节点
     - 快慢指针应用：找中点、检测环、倒数第 N 个节点
     - 高级构造：复制带随机指针的链表、重排链表
     - 设计题：LRU 缓存（链表 + 哈希）
   - 每类用 2～3 句话描述典型需求和解法核心想法

4. TypeScript 链表基础模板
   - 定义 ListNode 类型（包含 val 和 next）
   - 写出：
     - 反转链表的通用迭代模板
     - 合并两个有序链表的模板（使用虚拟头节点 dummy）
     - 快慢指针找中点/检测环的模板

5. 典型题精讲（至少 3 题）
   - 从下面题目中选 3～4 题展开：
     - 反转链表
     - 合并两个有序链表
     - 环形链表 & 环形链表 II
     - 删除链表的倒数第 N 个结点
     - 回文链表（快慢指针 + 反转后半段）
     - 合并 K 个升序链表（分治/堆）
     - LRU 缓存（哈希 + 双向链表，重点讲结构不一定写完所有代码）
   - 每题结构：
     - 思路演化：暴力/额外数组 → 原地链表操作
     - 画出指针变化的逻辑（用文字描述即可）
     - 给出 TypeScript 代码，变量命名清晰
     - 复杂度分析和容易出错的地方

6. ⚠️ 易错点与调试技巧
   - 指针指向丢失（先保存 next，再修改 next）
   - 处理头节点的常见 bug → 推荐统一用 dummy 节点
   - 链表环导致死循环的风险，如何在调试时发现

7. 🏢 前端业务场景举例
   - 例如：
     - 手写 LRU 缓存，用于前端数据缓存
     - 历史记录/撤销栈的一种实现方式
     - 虚拟 DOM 树的兄弟节点链表化（可简单类比）

8. 推荐练习题清单
   - 用表格列出 10～16 题链表相关题目：
     - 反转链表、合并两个有序链表、环形链表 I/II、删除倒数第 N 个节点、排序链表、重排链表、复制带随机指针的链表、合并 K 个链表、K 个一组翻转链表、LRU 缓存等
   - 每题列出：难度、题名、关键技巧、LeetCode 链接、建议顺序

请把这章写成一个「链表题型总复盘」，让读者看完后对链表基础题有信心。












Step 04：栈与队列（提示词）

你现在是「资深前端工程师 + 算法面试官」，请为《前端算法面试通关指南》写其中一个章节。

【章节信息】
- Step：04
- 主题：栈与队列（包含：基础栈/队列，单调栈，单调队列）
- 目标读者：准备前端算法面试、有一定 JS/TS 基础的工程师

【输出要求】
1. 使用 Markdown 格式。
2. 所有代码使用 TypeScript。
3. 特别强调：单调栈/单调队列在高频题中的重要性。

【内容结构】

1. 概念速览
   - 一句话解释栈（LIFO）与队列（FIFO）
   - 简单说明单调栈 / 单调队列的直觉（「维护一个有序的结构」）

2. 🎯 适用场景与信号词
   - 普通栈：
     - 括号匹配、撤销操作、表达式求值、路径化简
   - 单调栈：
     - 「下一个更大/更小元素」「每一天要等几天」之类问法
     - 区间最大矩形（如柱状图最大矩形）
   - 单调队列：
     - 滑动窗口内的最大/最小值问题
   - 给出：题目描述中出现什么，就应该联想到哪类结构

3. 问题归类与模型
   - 分类：
     - 栈模拟：括号匹配、逆波兰表达式求值、字符串解码、简化路径
     - 单调栈：每日温度、下一个更大元素 II、柱状图中最大的矩形、接雨水（可选）
     - 单调队列：滑动窗口最大值
   - 每类用几句话形容其「套路」

4. TypeScript 代码模板
   - 用数组实现栈、队列的基本操作
   - 单调栈模板：如何维持「从栈底到栈顶单调递增/递减」
   - 单调队列模板：实现一个支持 push/pop/获取窗口最大值的结构

5. 典型题精讲（至少 3 题）
   - 从以下题中选 3～4 个深度讲：
     - 有效的括号（栈）
     - 每日温度（单调栈）
     - 下一个更大元素 II（单调栈 + 环形数组）
     - 柱状图中最大的矩形（单调栈）
     - 滑动窗口最大值（单调队列）
     - 字符串解码（栈）
   - 每题结构：
     - 题意 → 朴素想法 → 为何考虑栈 / 单调栈 / 单调队列
     - 关键思路：栈/队列中到底在存什么？（索引 / 值 / 频次）
     - TS 代码实现
     - 复杂度分析，讨论是否有别的写法

6. ⚠️ 易错点
   - 单调栈中 while 条件写反、漏掉等于号导致死循环或结果错误
   - 处理边界（哨兵技巧、最后清栈）
   - 滑动窗口时队列头元素过期的判断条件

7. 🏢 前端业务场景
   - 例如：
     - 浏览器前进/后退栈
     - 编辑器撤销/重做
     - 可视化图表中预处理「下一个更大值」以优化交互等

8. 推荐练习题清单
   - 表格列出本专题 10～16 道题：
     - 有效的括号、用栈实现队列、用队列实现栈、最小栈、每日温度、逆波兰表达式求值、字符串解码、下一个更大元素 II、简化路径、移掉 K 位数字、柱状图最大矩形、滑动窗口最大值、接雨水等
   - 每行含：难度、题名、关键技巧、LeetCode 链接、建议顺序

请让读者看完这一章之后，对「看到 next greater / 区间最大值」就能条件反射想到单调栈/队列。













Step 05：二叉树（提示词）

你现在是「资深前端工程师 + 算法面试官」，请为《前端算法面试通关指南》写一个关于二叉树的章节。

【章节信息】
- Step：05
- 主题：二叉树
- 目标读者：准备前端算法面试、对树有基础认知但不熟练的工程师

【输出要求】
1. 使用 Markdown 格式。
2. 所有代码使用 TypeScript，定义 TreeNode 类型。
3. 强调：递归思维、遍历方式、二叉搜索树性质。

【内容结构】

1. 概念速览
   - 一句话解释二叉树在算法题中的重要性（几乎是必考）
   - TreeNode 的基本结构：val / left / right

2. 🎯 适用场景与信号词
   - 题目给的结构一般就是树：节点 + left/right
   - 常见信号词：前序/中序/后序、层序遍历、最近公共祖先、搜索树、路径和

3. 问题归类与模型
   - 树的遍历模型：前序、中序、后序、层序（DFS/BFS）
   - 二叉搜索树（BST）模型：中序遍历有序、求第 K 小、验证 BST
   - 树形 DP / 路径型问题：求深度、最大路径和、路径总和等

4. TypeScript 代码模板
   - 递归遍历模板（前/中/后）
   - 迭代遍历栈写法（至少展示一种）
   - BFS 层序遍历模板（使用队列）
   - 最近公共祖先 LCA 的递归模板

5. 典型题精讲（至少 3～4 题）
   - 可选题：
     - 二叉树的最大深度
     - 翻转二叉树
     - 对称二叉树
     - 二叉树的层序遍历
     - 验证二叉搜索树
     - 二叉树的最近公共祖先
     - 从前序与中序遍历构造二叉树
     - 二叉树中的最大路径和
   - 每题结构：
     - 画树的思路 + 递归函数的语义设计
     - 先写「函数定义」再填「递归结束条件 + 递归逻辑」
     - 给出 TS 代码
     - 复杂度分析、易错点（例如：比较值 vs 引用、全局变量使用）

6. 树与递归思维
   - 讲「自顶向下」与「自底向上」思路的区别
   - 一个简单例子对比两种写法

7. 🏢 前端业务场景
   - 例如：
     - 权限树 / 菜单树 的遍历与渲染
     - 目录结构、路由配置树
     - 组件树遍历、查找某类组件等

8. 推荐练习题清单
   - 表格列出 10～16 道二叉树题：
     - 深度、翻转、对称、路径总和、前序/中序/后序、层序遍历、验证 BST、LCA、构造树、展开为链表、最大路径和、序列化与反序列化等
   - 每行包含：难度、题名、关键技巧（递归/BFS/BST 性质等）、链接、建议顺序

请写成一个「二叉树大杂烩 + 模板合集」，让读者看完就有树题自信。



















Step 06：二分查找（提示词）

你现在是「资深前端工程师 + 算法面试官」，请为《前端算法面试通关指南》写一个关于二分查找的章节。

【章节信息】
- Step：06
- 主题：二分查找（含答案二分）
- 目标读者：知道「二分查找」但经常边界写错的前端工程师

【输出要求】
1. 使用 Markdown 格式。
2. 所有代码使用 TypeScript。
3. 强调：模板统一、左闭右开/左闭右闭的区别、以及「在答案空间上二分」的思维。

【内容结构】

1. 概念速览
   - 一句话解释：什么是二分查找，核心是「有序 + 可判定」
   - 说明两种常见用法：
     - 在数组上二分（查找值/边界）
     - 在答案空间上二分（判定函数 check）

2. 🎯 适用场景与信号词
   - 什么时候应该想到二分？
     - 有序数组/单调性
     - 求「最小满足条件的 x」「最大满足条件的 x」
     - 题目给的数据规模较大，且有明显的 monotonic check 函数
   - 给出几个典型描述：「最小的…」「最大的…」「能否在 k 以内做到…」等

3. 问题归类与模型
   - 分类：
     - 标准二分：在有序数组中查一个数
     - 边界二分：找第一个 ≥ target 或最后一个 ≤ target
     - 旋转数组 & 有缺陷有序数组的二分
     - 答案二分：如「爱吃香蕉的珂珂」「分割数组的最大值」

4. TypeScript 代码模板
   - 统一给出「左闭右闭」或「左闭右开」的标准模板（任选其一，但要讲清楚）
   - 边界二分模板：如何找左边界/右边界
   - 答案二分模板：外层二分 + 内层 check 函数

5. 典型题精讲（至少 3 题）
   - 题目候选：
     - 二分查找
     - 搜索插入位置
     - 在排序数组中查找元素的第一个和最后一个位置
     - 搜索旋转排序数组
     - 爱吃香蕉的珂珂（答案二分）
     - 寻找旋转排序数组中的最小值
     - 寻找两个正序数组的中位数（可偏思路）
   - 每题结构：
     - 暴力方案 → 为什么二分更合适
     - 单调性/有序性的来源是什么？
     - TS 代码 + 边界细节说明
     - 对比两套不同二分模板的写法（如有必要）

6. ⚠️ 易错点
   - mid 计算溢出问题（虽然 JS 不太会，但最好提一下标准写法）
   - while 条件用 `<=` 还是 `<`
   - 更新 left/right 时是否 +1/-1
   - 死循环与无法收敛的典型坑

7. 🏢 前端业务场景
   - 例如：
     - 虚拟列表中用二分查找定位滚动位置
     - 搜索建议中按权重排序后做某种范围查找
     - 时间轴/日志查看中快速定位某时间点

8. 推荐练习题清单
   - 表格列出 10～12 道二分相关题：
     - 二分查找、搜索插入位置、x 的平方根、第一个错误的版本、在排序数组中查找元素的第一个和最后一个位置、搜索旋转排序数组、寻找旋转排序数组中的最小值、寻找峰值、爱吃香蕉的珂珂、搜索二维矩阵、寻找两个正序数组的中位数、分割数组的最大值等

请重点让读者形成「一套固定二分模板」，并知道何时用二分。
















Step 07：回溯算法（提示词）

你现在是「资深前端工程师 + 算法面试官」，请为《前端算法面试通关指南》写一个关于回溯算法的章节。

【章节信息】
- Step：07
- 主题：回溯算法（排列、组合、子集、搜索）
- 目标读者：知道「回溯」但经常写乱的前端工程师

【输出要求】
1. 使用 Markdown 格式。
2. 所有代码使用 TypeScript。
3. 强调：递归树、状态选择与撤销、剪枝。

【内容结构】

1. 概念速览
   - 一句话解释回溯：「暴力穷举 + 剪枝」的系统写法
   - 用简单的「全排列」示例描述递归树的形态

2. 🎯 适用场景与信号词
   - 问题特征：
     - 要求列出「所有方案/所有子集」「所有排列/组合」
     - 约束满足问题（N 皇后、解数独）
   - 题干中关键词：「所有」「全部可能」「组合」「排列」「子集」

3. 问题归类与模型
   - 三大模型：
     - 子集型：是否选择当前元素（start 参数控制）
     - 组合型：选 k 个元素 / 选出和为 target 的组合
     - 排列型：元素有顺序，通常用 used 数组
   - 高级约束型：
     - N 皇后、解数独、单词搜索等

4. 回溯函数模板（TypeScript）
   - 统一写一个伪代码模板：
     - path / result / 选择列表 / 剪枝 / 撤销选择
   - 展示子集/组合/排列三种模型的典型 TS 模板

5. 典型题精讲（至少 3～4 题）
   - 候选题：
     - 子集 / 子集 II
     - 全排列 / 全排列 II
     - 组合总和 / 组合总和 II
     - 电话号码的字母组合
     - 分割回文串
     - N 皇后
     - 解数独（可略缩代码，着重思路）
   - 每题结构：
     - 递归树大概长什么样（文字说明）
     - 递归函数参数设计：index / start / used / path 等
     - 剪枝条件说明（特别是去重逻辑）
     - TS 代码实现
     - 易错点：包括排序去重、used 数组使用、下标控制

6. ⚠️ 易错点
   - 忘记撤销选择（path.pop / used[i] = false）
   - 去重逻辑写错（如相邻相同元素的跳过条件）
   - 终止条件写错：路径长度 vs 下标位置 vs target

7. 🏢 前端业务场景
   - 例如：
     - 权限组合生成、多维筛选条件组合
     - 配置向导的所有方案遍历（在小规模下）
     - 简易表单测试数据生成

8. 推荐练习题清单
   - 表格列出 10～16 道回溯题目：
     - 子集、子集 II、全排列、全排列 II、组合总和、组合总和 II、电话号码的字母组合、分割回文串、N 皇后、解数独、单词搜索 II 等

请重点帮读者建立「一看题就能画出递归树 & 写出回溯模板」的能力。

















Step 08：动态规划（提示词）

你现在是「资深前端工程师 + 算法面试官」，请为《前端算法面试通关指南》写一个关于动态规划的章节。

【章节信息】
- Step：08
- 主题：动态规划（DP）
- 目标读者：对 DP 感到恐惧、容易看不懂状态转移方程的前端工程师

【输出要求】
1. 使用 Markdown 格式。
2. 所有代码使用 TypeScript。
3. 尽量用「表格/数组示意 + 口语化解释」，少用纯公式堆砌。

【内容结构】

1. 概念速览
   - 一句话解释：DP = 记住过去的结果，避免重复计算
   - 说明核心要素：状态定义、状态转移、初始条件、答案位置

2. 🎯 适用场景与信号词
   - 「最值」：最大/最小、最长/最短
   - 「方案数」：有多少种走法/拆分方式
   - 「是否可行」：能否凑出某个和、能否拆分成…等
   - 数据规模通常较大，暴力/回溯很容易超时

3. 问题归类与模型
   - 一维 DP：爬楼梯、打家劫舍、买卖股票
   - 二维 DP：网格路径、最长公共子序列、编辑距离
   - 背包 DP：0-1 背包、完全背包、子集和
   - 区间 DP / 状态机 DP（简单提及）

4. 通用 DP 思考流程
   - 逐步示范：
     - 明确子问题
     - 定义 dp[i]/dp[i][j] 的含义（用自然语言描述）
     - 找到「最后一步」的关系，推导状态转移
     - 确定初始值和遍历顺序
   - 可以用「爬楼梯」或「最大子数组和」做完整示范

5. TypeScript 模板
   - 一维数组 DP 模板
   - 二维数组 DP 模板
   - 背包问题的双重循环模板（外层遍历物品/内层遍历容量）

6. 典型题精讲（至少 3～4 题）
   - 从以下中选：
     - 爬楼梯
     - 打家劫舍 / 打家劫舍 II
     - 最大子数组和
     - 买卖股票的最佳时机（1 / 多次）
     - 不同路径 / 最小路径和
     - 零钱兑换
     - 最长递增子序列
     - 最长公共子序列
     - 编辑距离
   - 每题结构：
     - 先用平实语言讲子问题和 dp 含义
     - 写出状态转移方程
     - 给出 TS 代码
     - 说明时间复杂度 & 是否可以优化空间

7. ⚠️ 易错点
   - dp[i] 的语义不清晰，导致转移方程混乱
   - 初始化错误（dp[0]/dp[1] 等）
   - 遍历顺序错误（如背包问题中导致被重复使用）

8. 🏢 前端业务场景
   - 例如：
     - 前端路由权限判定中，某些 DP 思维可优化判断
     - 表格/报表中动态计算某些指标
     - 文本相似度/差异比对（编辑距离）

9. 推荐练习题清单
   - 表格列出 15～18 道 DP 题：
     - 爬楼梯、打家劫舍、最大子数组和、买卖股票 I/II、使用最小花费爬楼梯、不同路径、最小路径和、零钱兑换、最长递增子序列、最长公共子序列、单词拆分、分割等和子集、打家劫舍 II、解码方法、编辑距离、戳气球、正则表达式匹配等

请用尽量「接地气」的方式让读者对 DP 不再恐惧。



















Step 09：堆与优先队列（提示词）

你现在是「资深前端工程师 + 算法面试官」，请为《前端算法面试通关指南》写一个关于堆与优先队列的章节。

【章节信息】
- Step：09
- 主题：堆与优先队列
- 目标读者：中高级前端工程师，准备更高难度的算法面试

【输出要求】
1. 使用 Markdown 格式。
2. 所有代码使用 TypeScript，自己实现一个简易二叉堆（最小堆）。
3. 强调：Top K 问题、数据流、合并 K 个有序结构。

【内容结构】

1. 概念速览
   - 一句话解释堆：支持「快速取极值」的数据结构
   - 说明最小堆 & 最大堆，及优先队列概念

2. 🎯 适用场景与信号词
   - Top K 最大/最小元素
   - 数据流中的中位数/Top K
   - 合并 K 个有序数组/链表
   - 每次从一堆候选中选出「最优」的元素

3. 堆的实现与 API
   - 用 TypeScript 手写一个最小堆类：
     - `push`、`pop`、`peek`、`size`
     - 使用数组实现二叉堆
   - 解释上浮/下沉过程

4. 常见题型模型
   - Top K 模型：维护一个大小为 K 的堆
   - 多路归并模型：K 个有序列表，堆中存放 K 个当前头元素
   - 对顶堆模型：数据流中位数

5. 典型题精讲（至少 3 题）
   - 候选题：
     - 数组中的第 K 个最大元素
     - 前 K 个高频元素
     - 合并 K 个升序链表
     - 数据流的中位数
     - IPO（贪心 + 堆）
   - 每题结构：
     - 为什么适合用堆：数据规模 vs 复杂度
     - 如果用排序 vs 用堆的复杂度对比
     - TS 代码（可以基于之前实现的堆类）

6. ⚠️ 易错点
   - 堆实现中的索引错误（父子节点计算）
   - 使用最大堆与最小堆的场景区分
   - 延迟删除 / 懒惰删除策略的简单说明（如滑动窗口最大值）

7. 🏢 前端业务场景
   - 例如：
     - 实时日志中展示 Top N 错误类型
     - 实时统计前端监控中最慢的 N 个接口
     - 聊天系统中最近活跃用户排序（数据量很大时）

8. 推荐练习题清单
   - 表格列出 10～12 道堆相关题：
     - 最后一块石头的重量、数组中的第 K 个最大元素、前 K 个高频元素、根据字符出现频率排序、查找和最小的 K 对数字、任务调度器、最接近原点的 K 个点、合并 K 个升序链表、数据流的中位数、滑动窗口最大值（堆解）、IPO 等

请侧重让读者理解「什么时候要想到堆，而不是排序或者别的数据结构」。

















Step 10：图论（提示词）

你现在是「资深前端工程师 + 算法面试官」，请为《前端算法面试通关指南》写一个关于图论的章节。

【章节信息】
- Step：10
- 主题：图论（DFS/BFS、拓扑排序、并查集、最短路）
- 目标读者：希望面试中能处理依赖关系/连通性问题的中高级前端工程师

【输出要求】
1. 使用 Markdown 格式。
2. 所有代码使用 TypeScript。
3. 重点讲：如何把题目建模为图 + 常见算法模板。

【内容结构】

1. 概念速览
   - 一句话解释图：节点 + 边 = 万物皆可图
   - 有向图 / 无向图 / 带权图 的直觉区别

2. 🎯 适用场景与信号词
   - 依赖关系：课程表、任务执行顺序、包依赖等
   - 连通性问题：朋友圈、岛屿数量、省份数量等
   - 最短路径：网络延迟时间、Word Ladder（步数最少）
   - 强调：只要一堆东西之间有「关系」，就有机会建模成图

3. 图的表示方法（TS）
   - 邻接表的实现方式（Map<number, number[]> 等）
   - 简单说明邻接矩阵 vs 邻接表的选择（但不必展开太多）

4. 核心算法模板
   - DFS：递归 / 栈形式
   - BFS：队列形式，特别强调「层数 = 距离」
   - 拓扑排序：入度数组 + 队列（Kahn 算法）
   - 并查集：`find` + `union` 实现（带路径压缩）
   - 简单的 Dijkstra 模板（可略）

5. 典型题精讲（至少 3～4 题）
   - 可选题：
     - 岛屿数量
     - 课程表 / 课程表 II
     - 冗余连接（并查集）
     - 省份数量（并查集 / DFS）
     - 腐烂的橘子（多源 BFS）
     - 单词接龙（BFS）
     - 网络延迟时间（Dijkstra）
   - 每题结构：
     - 如何把题转成图（节点是谁？边代表什么？）
     - 使用哪种遍历/结构（DFS/BFS/并查集/拓扑）
     - TS 代码实现 + 复杂度分析

6. ⚠️ 易错点
   - 无向图中重复访问（需要 visited 集合）
   - 有向图中检测环（拓扑排序 vs DFS 染色）
   - 并查集初始化 / 合并顺序问题

7. 🏢 前端业务场景
   - 例如：
     - 构建工具中的依赖图（webpack、rollup 的打包依赖）
     - 页面路由依赖、权限依赖
     - 前端微服务 / 模块依赖图可视化

8. 推荐练习题清单
   - 表格列出 12～15 道图论题：
     - 找到小镇的法官、岛屿数量、被围绕的区域、克隆图、课程表、课程表 II、冗余连接、省份数量、腐烂的橘子、最小基因变化、单词接龙、网络延迟时间、单词接龙 II、重新安排行程、外星文字典等

请特别帮助读者建立「看到依赖关系/连通性 → 想到图 + 模板」的反射。

















Step 11：字典树（Trie）（提示词）

你现在是「资深前端工程师 + 算法面试官」，请为《前端算法面试通关指南》写一个关于字典树（Trie）的章节。

【章节信息】
- Step：11
- 主题：字典树（Trie）与前缀问题
- 目标读者：面向高级前端面试，想提升算法区分度的工程师

【输出要求】
1. 使用 Markdown 格式。
2. 所有代码使用 TypeScript。
3. 强调：前缀匹配、搜索建议、敏感词过滤、异或 Trie。

【内容结构】

1. 概念速览
   - 一句话解释字典树：把一堆字符串「共享前缀」压缩存储的树结构
   - 对比：直接用哈希表存字符串 vs 用 Trie 的区别（前缀查询的复杂度）

2. 🎯 适用场景与信号词
   - 题目涉及「前缀匹配」「自动补全」「单词搜索」「敏感词」
   - 多个单词 / 字典 / 词典，需要频繁查询前缀或存在性

3. Trie 结构与 TypeScript 实现
   - 定义 TrieNode 结构：
     - 子节点映射（Map / 对象）
     - 是否是单词结束标记
   - 实现基本操作：
     - insert(word)
     - search(word)
     - startsWith(prefix)

4. 问题归类与模型
   - 基本 Trie 应用：实现 Trie、键值映射、单词替换
   - 搜索类：单词搜索 II（Trie + 回溯）
   - 高级：二进制 Trie 求最大异或值、回文对等

5. 典型题精讲（至少 2～3 题）
   - 候选题：
     - 实现 Trie (前缀树)
     - 添加与搜索单词
     - 键值映射
     - 单词替换
     - 数组中两个数的最大异或值（位 Trie）
     - 单词搜索 II（Trie + DFS）
   - 每题结构：
     - 为什么用 Trie 比哈希更合适
     - Trie 的构建和搜索过程
     - TS 代码实现，注意节点结构设计
     - 复杂度分析

6. ⚠️ 易错点
   - 子节点存储结构选择（对象 vs Map）
   - 字符集大小（仅小写字母 vs 任意字符）带来的实现差异
   - 回溯 + Trie 时的剪枝和访问标记

7. 🏢 前端业务场景
   - 例如：
     - 搜索框联想（自动补全）
     - 前端敏感词过滤
     - 输入法候选词列表（简化版本）

8. 推荐练习题清单
   - 表格列出 8～10 道 Trie 相关题：
     - 最长公共前缀（Trie 视角）、实现 Trie、添加与搜索单词、键值映射、单词替换、数组中两个数的最大异或值、连接词、单词搜索 II、回文对、数据流中的前 K 个高频单词等

请把这一章写成「高阶篇的亮点章」，让读者对前缀问题和 Trie 有清晰模型。

