# 排序算法自测清单

## 📋 使用说明

- 每个问题后有 **参考答案**（点击展开）
- 先自己思考，再对照答案
- 标注 **关联章节** 方便复习

---

## 🧮 模块一：基础概念

### Q1: 什么是时间复杂度？O(n log n) 比 O(n²) 快多少？

<details>
<summary>参考答案</summary>

时间复杂度描述算法执行时间与输入规模的增长关系。

当 n = 10000 时：
- O(n²) = 10^8 次操作
- O(n log n) ≈ 10000 × 13 = 1.3 × 10^5 次操作
- 快约 **770 倍**

**关联章节**：00-prerequisites/01-complexity.ts
</details>

---

### Q2: 什么是稳定排序？举例说明稳定性的实际意义

<details>
<summary>参考答案</summary>

**稳定排序**：相等的元素在排序后保持原始相对顺序。

**实际意义**：表格多列排序时，先按 A 列排序，再按 B 列排序后，B 列相同的行仍保持 A 列的排序结果。

**稳定的算法**：冒泡、插入、归并、TimSort、计数、基数
**不稳定的算法**：选择、希尔、快排、堆排

**关联章节**：05-表格排序实战.md
</details>

---

### Q3: 什么是原地排序？为什么归并排序不是原地排序？

<details>
<summary>参考答案</summary>

**原地排序**：只使用 O(1) 或 O(log n) 额外空间。

归并排序需要 O(n) 的辅助数组来合并两个有序子数组，所以不是原地排序。

**原地排序**：冒泡、选择、插入、希尔、快排、堆排
**非原地排序**：归并、TimSort、计数、桶、基数

**关联章节**：比较类排序/05-归并排序.md
</details>

---

### Q4: JavaScript 的 Array.sort() 有哪些陷阱？

<details>
<summary>参考答案</summary>

1. **默认按字符串排序**：`[10, 2].sort()` → `[10, 2]`
2. **比较函数返回值要求**：必须返回负数/零/正数，不能返回 boolean
3. **稳定性**：ES2019 后规范要求稳定，但旧环境可能不稳定
4. **原地修改**：会修改原数组
5. **NaN 问题**：比较函数返回 NaN 会导致不确定行为

**关联章节**：03-JS原生sort陷阱.md
</details>

---

## 📊 模块二：比较排序

### Q5: 冒泡排序的优化版本如何提前终止？时间复杂度如何？

<details>
<summary>参考答案</summary>

添加 `swapped` 标志，如果一轮遍历没有任何交换，说明已有序，可提前终止。

```typescript
for (let i = 0; i < n - 1; i++) {
  let swapped = false;
  for (let j = 0; j < n - 1 - i; j++) {
    if (arr[j] > arr[j + 1]) {
      [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
      swapped = true;
    }
  }
  if (!swapped) break; // 提前终止
}
```

**优化后**：最好 O(n)，平均/最坏 O(n²)

**关联章节**：比较类排序/01-冒泡排序.md
</details>

---

### Q6: 插入排序在什么场景下性能最好？为什么 TimSort 使用它？

<details>
<summary>参考答案</summary>

**最好场景**：
1. 数据近乎有序 → O(n)
2. 数据量很小（n < 16）

**TimSort 使用原因**：
- 小数组（< 64）直接用插入排序
- 对已检测到的 run 内部使用二分插入
- 常数因子小，缓存友好

**关联章节**：比较类排序/03-插入排序.md, 11-TimSort.md
</details>

---

### Q7: 快速排序如何避免 O(n²) 最坏情况？

<details>
<summary>参考答案</summary>

1. **随机选择 pivot**：避免有序/逆序输入导致的最坏情况
2. **三数取中**：取 left、mid、right 的中值作为 pivot
3. **Introsort**：递归深度超过 2·log₂(n) 时切换到堆排序
4. **三路快排**：处理大量重复元素

**关联章节**：比较类排序/06-快速排序.md, 10-Introsort.md
</details>

---

### Q8: 堆排序为什么不稳定？它的优势是什么？

<details>
<summary>参考答案</summary>

**不稳定原因**：堆化过程中，相等元素可能被交换到不同位置。

**优势**：
1. 最坏情况仍是 O(n log n)（快排最坏 O(n²)）
2. 原地排序，空间 O(1)
3. 适合流式取 TopK

**关联章节**：比较类排序/07-堆排序.md
</details>

---

### Q9: 归并排序的递归版和迭代版有什么区别？

<details>
<summary>参考答案</summary>

| 特性 | 递归版 | 迭代版 |
|------|--------|--------|
| 空间 | O(n) + O(log n) 栈 | O(n) |
| 方向 | 自顶向下 | 自底向上 |
| 缓存友好 | 较好 | 更好 |
| 实现复杂度 | 简单 | 稍复杂 |

**关联章节**：比较类排序/05-归并排序.md
</details>

---

### Q10: TimSort 的 run 检测和 minrun 策略是什么？

<details>
<summary>参考答案</summary>

**run 检测**：
- 识别数据中已有序的片段（升序或降序）
- 降序 run 会被反转为升序

**minrun 策略**：
- minrun 通常在 32-64 之间
- 如果 run 长度 < minrun，使用插入排序扩展
- 目标是让 run 数量是 2 的幂附近，优化归并

**关联章节**：比较类排序/11-TimSort.md
</details>

---

## 🔢 模块三：非比较排序

### Q11: 计数排序的适用条件是什么？为什么从后往前回填能保证稳定性？

<details>
<summary>参考答案</summary>

**适用条件**：
1. 整数（或可离散化）
2. 值域 k 不太大（k 不远大于 n）

**稳定性原理**：
- 前缀和表示"≤该值的元素个数"
- 从后往前遍历，相同值的后出现的元素放在后面的位置
- 保持了原始相对顺序

**关联章节**：非比较排序/01-计数排序.md
</details>

---

### Q12: 桶排序在什么情况下性能最差？如何设计好的映射函数？

<details>
<summary>参考答案</summary>

**性能最差**：所有元素落入同一个桶 → O(n²)

**好的映射函数**：
1. 使元素均匀分布到各个桶
2. 需要了解数据的分布特征
3. 桶数量通常 ≈ n

```typescript
// 均匀分布的 [0, 1) 浮点数
const getBucket = (x: number) => Math.floor(x * bucketCount);

// 已知范围的整数
const getBucket = (x: number) => Math.floor((x - min) / bucketSize);
```

**关联章节**：非比较排序/02-桶排序.md
</details>

---

### Q13: 基数排序为什么必须使用稳定的子排序？LSD 和 MSD 的区别？

<details>
<summary>参考答案</summary>

**必须稳定的原因**：
低位排序后，高位再排时不能打乱低位的相对顺序，否则结果错误。

**区别**：

| 类型 | 方向 | 特点 |
|------|------|------|
| LSD | 低位→高位 | 简单，适合等长数据 |
| MSD | 高位→低位 | 可提前终止，适合变长数据 |

**关联章节**：非比较排序/03-基数排序.md
</details>

---

### Q14: 外部归并排序的 K 路归并为什么使用最小堆？

<details>
<summary>参考答案</summary>

**原因**：
- 每次需要从 K 个有序块中取出最小值
- 最小堆可以 O(log K) 时间取出最小值并调整
- 总时间 O(n log K)

**替代方案**：
- 两路迭代归并：O(n log K)，但常数因子更大
- 直接遍历找最小：O(n × K)，K 大时效率低

**关联章节**：外部排序/01-外部归并排序.md
</details>

---

## 🌐 模块四：前端实战

### Q15: 表格多列排序有哪两种实现方式？各自的优缺点？

<details>
<summary>参考答案</summary>

**方式 A：稳定排序 + 逆序多次排序**
- 从次关键字到主关键字依次排序
- 优点：直观，易调试
- 缺点：性能 O(k · n log n)，代码顺序与优先级相反

**方式 B：组合比较器一次排序**
- 使用 compose 组合多个 comparator
- 优点：性能 O(n log n)，顺序与优先级一致
- 缺点：比较器组合可能复杂

**关联章节**：05-表格排序实战.md
</details>

---

### Q16: TopK 问题有哪几种解法？各自适用什么场景？

<details>
<summary>参考答案</summary>

| 方法 | 时间 | 空间 | 适用场景 |
|------|------|------|---------|
| 全量排序 | O(n log n) | O(n) | k ≈ n |
| TopK 堆 | O(n log k) | O(k) | k << n，流式数据 |
| 快速选择 | O(n) 平均 | O(1) | 内存敏感，一次性处理 |

**关联章节**：06-搜索结果与TopK.md
</details>

---

### Q17: 什么是游标分页？相比偏移量分页有什么优势？

<details>
<summary>参考答案</summary>

**游标分页**：用上一页最后一条的唯一标识作为下一页的起点。

**优势**：
1. 数据变化时仍能正确翻页（不会漏数据或重复）
2. 适合实时更新的列表

**劣势**：
- 不支持随机跳页
- 实现稍复杂

**关联章节**：06-搜索结果与TopK.md
</details>

---

### Q18: 如何验证一个排序算法的正确性？

<details>
<summary>参考答案</summary>

验证三个性质：

1. **有序性**：相邻元素满足排序条件
2. **置换性**：排序前后元素完全相同（不多不少）
3. **稳定性**（可选）：相等元素保持原始顺序

```typescript
import { verifySorted, verifyPermutation, verifyStable } from '公共库/src/正确性校验';

expect(verifySorted(sorted, cmp).passed).toBe(true);
expect(verifyPermutation(original, sorted).passed).toBe(true);
expect(verifyStable(original, sorted, cmp).passed).toBe(true);
```

**关联章节**：04-测试与基准指南.md
</details>

---

## 🎯 综合题

### Q19: 如果让你实现一个前端表格组件的排序功能，你会如何设计？

<details>
<summary>参考答案</summary>

**设计要点**：

1. **比较器模块**
   - 提供 numberAsc/desc, stringAsc/desc 等基础比较器
   - 提供 byField, compose, reverse 等组合函数
   - 处理 null/undefined（nullSafe）

2. **排序策略**
   - 使用稳定排序（stableSortBy 或 TimSort）
   - 支持多列组合排序
   - 考虑大数据量时使用 Web Worker

3. **状态管理**
   - 记录当前排序列和方向
   - 支持点击切换升序/降序/取消
   - 支持 Shift+点击添加次级排序

4. **性能优化**
   - 虚拟滚动
   - 防抖处理快速点击
   - 缓存排序结果

**关联章节**：05-表格排序实战.md, 公共库
</details>

---

### Q20: 面对 100 万条搜索结果，需要展示相关度最高的 20 条，你会怎么做？

<details>
<summary>参考答案</summary>

**方案**：使用 TopK 堆

```typescript
class TopKTracker<T> {
  private heap: MinHeap<T>; // 小顶堆

  add(item: T): boolean {
    if (heap.size() < k) {
      heap.push(item);
      return true;
    }
    if (cmp(item, heap.peek()) > 0) {
      heap.pop();
      heap.push(item);
      return true;
    }
    return false;
  }
}
```

**优化**：
1. 使用 Web Worker 避免阻塞 UI
2. 分批处理数据
3. 增量更新：新数据到来时只需 O(log k) 更新

**时间复杂度**：O(n log k) = O(100万 × log 20) ≈ O(100万 × 4.3)

**关联章节**：06-搜索结果与TopK.md
</details>

---

## 📈 完成度检查

- [ ] 模块一：基础概念 (4/4)
- [ ] 模块二：比较排序 (6/6)
- [ ] 模块三：非比较排序 (4/4)
- [ ] 模块四：前端实战 (4/4)
- [ ] 综合题 (2/2)

**总计**：20 道题

---

## 🎉 恭喜完成！

如果你能正确回答 16+ 道题，说明你已经掌握了排序算法的核心知识。

**下一步建议**：
1. 动手实现你不熟悉的算法
2. 在实际项目中应用这些知识
3. 尝试 LeetCode 上的排序相关题目

