# å¤–éƒ¨å½’å¹¶æ’åº (External Merge Sort)

## ğŸ“Œ æ ¸å¿ƒæ€æƒ³

å½“æ•°æ®**æ— æ³•ä¸€æ¬¡è£…å…¥å†…å­˜**æ—¶ï¼š
1. **åˆ†å—**ï¼šå°†æ•°æ®åˆ†æˆèƒ½è£…å…¥å†…å­˜çš„å°å—
2. **å†…éƒ¨æ’åº**ï¼šå¯¹æ¯ä¸ªå°å—è¿›è¡Œæ’åº
3. **å¤šè·¯å½’å¹¶**ï¼šä½¿ç”¨æœ€å°å †è¿›è¡Œ K è·¯å½’å¹¶

> å…³é”®æ´å¯Ÿï¼šç£ç›˜ I/O æ˜¯ç“¶é¢ˆï¼Œå°½é‡å‡å°‘è¯»å†™æ¬¡æ•°ï¼Œé¡ºåºè®¿é—®ã€‚

---

## ğŸš¨ é€‚ç”¨è¾¹ç•Œ

| æ¡ä»¶ | è¯´æ˜ |
|------|------|
| **æ•°æ®é‡** | è¶…è¿‡å¯ç”¨å†…å­˜ |
| **å­˜å‚¨** | éœ€è¦å¤–éƒ¨å­˜å‚¨ï¼ˆç£ç›˜/æ–‡ä»¶ï¼‰ |
| **å‰ç«¯åœºæ™¯** | å¤§æ•°ç»„åˆ†ç‰‡å¤„ç†ã€æµå¼æ•°æ® |

### âš ï¸ å‰ç«¯ç±»æ¯”

è™½ç„¶å‰ç«¯å¾ˆå°‘ç›´æ¥æ“ä½œç£ç›˜ï¼Œä½†ä»¥ä¸‹åœºæ™¯ç±»ä¼¼ï¼š
- å¤„ç†è¶…å¤§ JSON æ•°ç»„ï¼ˆéœ€è¦åˆ†ç‰‡ï¼‰
- æµå¼å¤„ç†å¤§é‡æ•°æ®
- Web Worker åˆ†ç‰‡æ’åº

---

## ğŸ¯ åœºæ™¯è¯†åˆ«ä¿¡å·

| ä¿¡å· | æ¨èåº¦ |
|------|-------|
| æ•°æ®å¤ªå¤§æ— æ³•ä¸€æ¬¡è£…å…¥å†…å­˜ | â­â­â­â­â­ |
| æµå¼/åˆ†é¡µæ•°æ®æ’åº | â­â­â­â­ |
| éœ€è¦åˆå¹¶å¤šä¸ªæœ‰åºæ•°æ®æº | â­â­â­â­ |
| å°æ•°æ®é‡ | âŒ ä¸éœ€è¦ |

---

## ğŸ“Š å¤æ‚åº¦åˆ†æ

| æŒ‡æ ‡ | å€¼ | è¯´æ˜ |
|------|-----|------|
| **æ—¶é—´å¤æ‚åº¦** | O(n log n) | ä¸å½’å¹¶æ’åºç›¸åŒ |
| **I/O å¤æ‚åº¦** | O(n/B Â· log_{M/B}(n/B)) | B æ˜¯å—å¤§å°ï¼ŒM æ˜¯å†…å­˜ |
| **ç©ºé—´å¤æ‚åº¦** | O(M) | å¯ç”¨å†…å­˜ |

---

## ğŸ”„ ç®—æ³•æµç¨‹ï¼ˆMermaidï¼‰

```mermaid
flowchart TD
    A["å¤§æ•°æ®é›†ï¼ˆæ— æ³•è£…å…¥å†…å­˜ï¼‰"] --> B["1. åˆ†å—"]

    subgraph "åˆ†å—é˜¶æ®µ"
        B --> C1["å—1"]
        B --> C2["å—2"]
        B --> C3["å—3"]
        B --> C4["..."]
        B --> Ck["å—K"]
    end

    subgraph "å†…éƒ¨æ’åºé˜¶æ®µ"
        C1 --> D1["æ’åºåå—1"]
        C2 --> D2["æ’åºåå—2"]
        C3 --> D3["æ’åºåå—3"]
        Ck --> Dk["æ’åºåå—K"]
    end

    D1 --> E["2. Kè·¯å½’å¹¶"]
    D2 --> E
    D3 --> E
    Dk --> E

    E --> F["æœ€ç»ˆæœ‰åºç»“æœ"]

    style F fill:#90EE90
```

### K è·¯å½’å¹¶è¯¦è§£

```mermaid
flowchart LR
    subgraph "æœ€å°å †"
        H["å †é¡¶ï¼šå½“å‰æœ€å°å€¼"]
    end

    subgraph "K ä¸ªæœ‰åºå—"
        B1["å—1: [1, 4, 7]"]
        B2["å—2: [2, 5, 8]"]
        B3["å—3: [3, 6, 9]"]
    end

    B1 -->|"å–é¦–å…ƒç´ "| H
    B2 -->|"å–é¦–å…ƒç´ "| H
    B3 -->|"å–é¦–å…ƒç´ "| H

    H -->|"å¼¹å‡ºæœ€å°"| O["è¾“å‡º"]
    H -->|"ä»å¯¹åº”å—è¡¥å……"| H
```

---

## ğŸ’» æ ¸å¿ƒå®ç°

```typescript
/**
 * å¤–éƒ¨å½’å¹¶æ’åºï¼ˆå†…å­˜æ¨¡æ‹Ÿç‰ˆï¼‰
 *
 * @param arr å¾…æ’åºæ•°ç»„
 * @param chunkSize æ¯å—å¤§å°ï¼ˆæ¨¡æ‹Ÿå†…å­˜é™åˆ¶ï¼‰
 * @param cmp æ¯”è¾ƒå‡½æ•°
 */
export function externalMergeSort<T>(
  arr: readonly T[],
  chunkSize: number,
  cmp: Comparator<T>
): T[] {
  const n = arr.length;
  if (n <= chunkSize) {
    // èƒ½ä¸€æ¬¡è£…å…¥å†…å­˜ï¼Œç›´æ¥æ’åº
    return [...arr].sort(cmp);
  }

  // 1. åˆ†å—å¹¶æ’åº
  const sortedChunks: T[][] = [];
  for (let i = 0; i < n; i += chunkSize) {
    const chunk = arr.slice(i, Math.min(i + chunkSize, n));
    sortedChunks.push(chunk.sort(cmp));
  }

  // 2. K è·¯å½’å¹¶
  return kWayMerge(sortedChunks, cmp);
}

/**
 * K è·¯å½’å¹¶ï¼ˆä½¿ç”¨æœ€å°å †ï¼‰
 */
function kWayMerge<T>(
  chunks: T[][],
  cmp: Comparator<T>
): T[] {
  const k = chunks.length;
  if (k === 0) return [];
  if (k === 1) return chunks[0];

  // å †å…ƒç´ ï¼š[å€¼, å—ç´¢å¼•, å—å†…ç´¢å¼•]
  type HeapItem = { value: T; chunkIdx: number; itemIdx: number };

  // åˆå§‹åŒ–å †
  const heap: HeapItem[] = [];

  for (let i = 0; i < k; i++) {
    if (chunks[i].length > 0) {
      heap.push({
        value: chunks[i][0],
        chunkIdx: i,
        itemIdx: 0,
      });
    }
  }

  // å»ºæœ€å°å †
  buildMinHeap(heap, (a, b) => cmp(a.value, b.value));

  const result: T[] = [];

  while (heap.length > 0) {
    // å–å‡ºæœ€å°å€¼
    const min = heap[0];
    result.push(min.value);

    // ä»åŒä¸€å—å–ä¸‹ä¸€ä¸ªå…ƒç´ 
    const nextIdx = min.itemIdx + 1;
    if (nextIdx < chunks[min.chunkIdx].length) {
      heap[0] = {
        value: chunks[min.chunkIdx][nextIdx],
        chunkIdx: min.chunkIdx,
        itemIdx: nextIdx,
      };
      heapifyDown(heap, 0, (a, b) => cmp(a.value, b.value));
    } else {
      // è¯¥å—å·²ç©ºï¼Œç§»é™¤
      heap[0] = heap[heap.length - 1];
      heap.pop();
      if (heap.length > 0) {
        heapifyDown(heap, 0, (a, b) => cmp(a.value, b.value));
      }
    }
  }

  return result;
}

// æœ€å°å †è¾…åŠ©å‡½æ•°
function buildMinHeap<T>(heap: T[], cmp: Comparator<T>): void {
  for (let i = Math.floor(heap.length / 2) - 1; i >= 0; i--) {
    heapifyDown(heap, i, cmp);
  }
}

function heapifyDown<T>(heap: T[], i: number, cmp: Comparator<T>): void {
  const n = heap.length;
  while (true) {
    let smallest = i;
    const left = 2 * i + 1;
    const right = 2 * i + 2;

    if (left < n && cmp(heap[left], heap[smallest]) < 0) {
      smallest = left;
    }
    if (right < n && cmp(heap[right], heap[smallest]) < 0) {
      smallest = right;
    }

    if (smallest === i) break;

    [heap[i], heap[smallest]] = [heap[smallest], heap[i]];
    i = smallest;
  }
}
```

---

## ğŸ”§ å¯æ’æ‹”è®¾è®¡

```typescript
/**
 * å¯é…ç½®çš„å¤–éƒ¨å½’å¹¶æ’åº
 */
export interface ExternalSortOptions<T> {
  chunkSize: number;
  sortChunk: (chunk: T[], cmp: Comparator<T>) => T[];
  mergeChunks: (chunks: T[][], cmp: Comparator<T>) => T[];
}

export function externalMergeSortConfigurable<T>(
  arr: readonly T[],
  cmp: Comparator<T>,
  options: ExternalSortOptions<T>
): T[] {
  const { chunkSize, sortChunk, mergeChunks } = options;

  // åˆ†å—
  const chunks: T[][] = [];
  for (let i = 0; i < arr.length; i += chunkSize) {
    chunks.push(arr.slice(i, i + chunkSize));
  }

  // æ’åºæ¯ä¸ªå—
  const sortedChunks = chunks.map(chunk => sortChunk([...chunk], cmp));

  // åˆå¹¶
  return mergeChunks(sortedChunks, cmp);
}

// ä½¿ç”¨ç¤ºä¾‹
const options: ExternalSortOptions<number> = {
  chunkSize: 1000,
  sortChunk: (chunk, cmp) => timsort(chunk, cmp), // ä½¿ç”¨ TimSort
  mergeChunks: kWayMerge,
};
```

---

## ğŸŒ å‰ç«¯ä¸šåŠ¡åœºæ™¯

### 1. å¤§æ•°ç»„åˆ†ç‰‡æ’åº

```typescript
// å¤„ç†è¶…å¤§ JSON æ•°ç»„
async function sortLargeArray<T>(
  data: T[],
  cmp: Comparator<T>,
  chunkSize = 10000
): Promise<T[]> {
  // åˆ†ç‰‡å¤„ç†ï¼Œé¿å…é˜»å¡ä¸»çº¿ç¨‹
  return externalMergeSort(data, chunkSize, cmp);
}
```

### 2. ä½¿ç”¨ Web Worker å¹¶è¡Œæ’åº

```typescript
// ä¸»çº¿ç¨‹
async function parallelSort<T>(data: T[], cmp: Comparator<T>): Promise<T[]> {
  const chunkSize = Math.ceil(data.length / navigator.hardwareConcurrency);
  const chunks: T[][] = [];

  for (let i = 0; i < data.length; i += chunkSize) {
    chunks.push(data.slice(i, i + chunkSize));
  }

  // å¹¶è¡Œæ’åºæ¯ä¸ªå—
  const sortedChunks = await Promise.all(
    chunks.map(chunk => sortInWorker(chunk, cmp))
  );

  // ä¸»çº¿ç¨‹å½’å¹¶
  return kWayMerge(sortedChunks, cmp);
}
```

### 3. æµå¼æ•°æ®æ’åº

```typescript
// æ¨¡æ‹Ÿæµå¼æ•°æ®åˆ°è¾¾åæ’åº
class StreamSorter<T> {
  private chunks: T[][] = [];
  private buffer: T[] = [];
  private chunkSize: number;
  private cmp: Comparator<T>;

  constructor(chunkSize: number, cmp: Comparator<T>) {
    this.chunkSize = chunkSize;
    this.cmp = cmp;
  }

  add(item: T): void {
    this.buffer.push(item);
    if (this.buffer.length >= this.chunkSize) {
      this.flush();
    }
  }

  private flush(): void {
    if (this.buffer.length > 0) {
      const sorted = [...this.buffer].sort(this.cmp);
      this.chunks.push(sorted);
      this.buffer = [];
    }
  }

  getResult(): T[] {
    this.flush();
    return kWayMerge(this.chunks, this.cmp);
  }
}
```

---

## ğŸ“š å»¶ä¼¸é˜…è¯»

1. **Replacement Selection**ï¼šç”Ÿæˆæ›´é•¿çš„åˆå§‹ run
2. **Polyphase Merge**ï¼šä¼˜åŒ–ç£ç›˜ I/O
3. **Multiway Merge**ï¼šå¹³è¡¡ I/O å’Œ CPU
4. **External Memory Algorithms**ï¼šæ›´å¹¿æ³›çš„å¤–éƒ¨ç®—æ³•

---

## âœ… è‡ªæ£€æ¸…å•

- [ ] ç†è§£åˆ†å—-æ’åº-å½’å¹¶ä¸‰æ­¥æµç¨‹
- [ ] çŸ¥é“ä¸ºä»€ä¹ˆç”¨æœ€å°å †åš K è·¯å½’å¹¶
- [ ] èƒ½åˆ†æ I/O å¤æ‚åº¦
- [ ] èƒ½å®ç°å¯é…ç½®çš„å¤–éƒ¨æ’åºæ¥å£
- [ ] çŸ¥é“å‰ç«¯åœºæ™¯å¦‚ä½•ç±»æ¯”åº”ç”¨ï¼ˆå¤§æ•°ç»„/Web Workerï¼‰

