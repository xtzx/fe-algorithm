# 排序算法教程生成提示词（共 6 次对话）

> 目标目录：`algorithm/排序/`
> 分 6 步完成：S0（骨架）→ S1a（基础4种）→ S1b（高级3种）→ S2（工业级）→ S3（非比较）→ S4（实战）

---






## S0.prompt.md（骨架 + 公共库 + 基准测试框架）

你现在是「算法与工程化写作专家（JS/TS）」。

【本次任务】S0：在 `algorithm/排序/` 目录下搭建"教程 + 可复用代码公共库 + 基准测试框架"的骨架。
后续 S1a–S4 会继续往里补充具体算法文件。

【必须生成的目录结构】
```
algorithm/排序/
├── README.md                          # 项目总览
│
├── 文档/
│   ├── 00-总览.md
│   ├── 01-选型决策树.md
│   ├── 02-复杂度对比表.md
│   ├── 03-JS原生sort陷阱.md
│   ├── 04-测试与基准指南.md
│   └── 算法详解/
│       ├── 比较类排序/               # 占位，S1a/S1b 补充
│       ├── 非比较排序/               # 占位，S3 补充
│       └── 外部排序/                 # 占位，S3 补充
│
├── 算法包/
│   └── 公共库/
│       ├── README.md
│       └── src/
│           ├── 比较器.ts
│           ├── 数据生成器.ts
│           ├── 正确性校验.ts
│           ├── 稳定排序辅助.ts
│           └── 性能计时.ts
│
└── 基准测试/
    ├── README.md
    └── src/
        ├── 测试用例集.ts
        └── 运行基准.ts
```

【内容要求】

1) **文档要求**：
   - 图解直觉为主，辅以少量不变式/正确性说明
   - 大量使用 Mermaid 图表

2) **00-总览.md 必须包含**：
   - 学习路线图（Mermaid flowchart）
   - 各算法适用场景速查表
   - 文件索引

3) **01-选型决策树.md 必须包含**：
   - 场景 → 算法的 Mermaid 决策树（看到场景就能选算法）
   - 稳定性/原地/额外内存的判定流程图

4) **02-复杂度对比表.md 必须包含**：
   - 比较排序 vs 非比较排序分类
   - 时间复杂度（最好/平均/最坏）+ 空间复杂度 + 是否稳定 + 是否原地
   - 表头先写好，具体算法行标注"S1a/S1b/S2/S3 补充"

5) **03-JS原生sort陷阱.md 必须覆盖**：
   - comparator 必须满足自反/传递/一致性
   - 字符串 localeCompare 成本、数字排序坑（"10" vs "2"）
   - 稳定性：现代 JS sort 要求稳定，但不能依赖历史实现细节
   - 给出"显式稳定排序"的做法（引用 公共库/稳定排序辅助.ts）

6) **公共库代码要求**：
   - 仅用 TS/JS 标准能力（不引入第三方库）
   - 测试用纯手写断言（不依赖 Jest/Vitest）
   - 提供：
     - 比较器规范（数字、字符串、对象字段）
     - 数据生成器（随机/近乎有序/重复多/逆序/已排序）
     - 正确性校验（有序性、置换性、稳定性）
     - 性能计时（比较次数/交换次数/耗时）
   - 稳定排序辅助：Schwartzian transform / decorate-sort-undecorate

7) **基准测试框架**：
   - 运行基准.ts：能对"已存在的算法包"做统一跑分
   - 测试用例集.ts：定义多种数据规模与分布（含表格数据、搜索结果数据）

【输出顺序】
- 先输出完整目录树
- 再按文件路径顺序，逐文件输出完整内容
- 不要生成任何工程配置文件（package.json、tsconfig.json 等）

---









## S1a.prompt.md（基础排序：冒泡/选择/插入/希尔）

你现在是「排序算法讲师 + TS 实现工程师」。

【本次任务】S1a：在 `algorithm/排序/` 内补齐"基础比较排序"的文档与代码。
严格在既有目录内新增文件，不要改动 S0 已生成文件内容。

【需要补齐的算法】
- 冒泡排序、选择排序、插入排序、希尔排序

【必须生成的目录结构】
```
algorithm/排序/
├── 文档/算法详解/比较类排序/
│   ├── 01-冒泡排序.md
│   ├── 02-选择排序.md
│   ├── 03-插入排序.md
│   └── 04-希尔排序.md
│
└── 算法包/
    ├── 冒泡排序/
    │   ├── README.md           # 快速使用指南
    │   ├── src/index.ts        # 算法实现
    │   ├── src/demo.ts         # 使用示例
    │   └── test/index.test.ts  # 测试用例
    ├── 选择排序/（同结构）
    ├── 插入排序/（同结构）
    └── 希尔排序/（同结构）
```

【统一接口规范（所有算法包都必须遵守）】
```typescript
// src/index.ts 必须导出：

// 不修改原数组，返回新数组
export function sort<T>(arr: readonly T[], cmp: (a: T, b: T) => number): T[];

// 原地排序（可选但推荐）
export function sortInPlace<T>(arr: T[], cmp: (a: T, b: T) => number): T[];

// 元信息
export const meta = {
  name: '冒泡排序',
  stable: true,           // 是否稳定
  inPlace: true,          // 是否原地
  timeComplexity: {
    best: 'O(n)',
    average: 'O(n²)',
    worst: 'O(n²)'
  },
  spaceComplexity: 'O(1)',
  适用场景: ['教学演示', '小规模数据'],
  不适用场景: ['大规模数据', '性能敏感场景']
};
```

【demo.ts 要求】
- 演示对"表格行对象"的排序（按分数降序、同分按姓名升序）
- 演示对"搜索结果对象"的排序（按 relevance 降序、同分按时间降序）

【test 要求】
- 使用 `算法包/公共库/src/正确性校验.ts` 做校验
- 用纯手写断言（不依赖 Jest/Vitest）
- 覆盖：空数组、单元素、重复多、已排序、逆序、随机
- 对于稳定排序，必须额外测试"稳定性"

【文档要求（每篇算法文档都必须包含）】
1) **核心思想**（图解直觉）
2) **适用场景**：什么时候用、什么时候别用（"看到场景就能选"）
3) **优缺点**（含工程点：常数因子、缓存友好）
4) **变种/优化点**（如冒泡的提前终止优化）
5) **复杂度分析**：时间（最好/平均/最坏）、空间、稳定性、是否原地
6) **Mermaid 图**：至少 1 张流程图或过程示意图
7) **正确性说明**：2-5 行不变式解释"为什么对"
8) **前端场景**：表格排序稳定性、搜索结果场景

【README.md（算法包）分工说明】
- README.md：快速使用（API、示例调用）
- 文档/算法详解/：详细原理讲解

【输出顺序】
- 先输出本次新增的目录树
- 再逐文件输出完整内容
- 不要生成任何工程配置文件

---










## S1b.prompt.md（高级比较排序：归并/快排/堆排 + 快速选择）

你现在是「排序算法讲师 + TS 实现工程师」。

【本次任务】S1b：在 `algorithm/排序/` 内补齐"高级比较排序"的文档与代码。

【需要补齐的算法】
- 归并排序、快速排序、堆排序
- 快速选择（quickSelect，用于 TopK 问题）

【必须生成的目录结构】
```
algorithm/排序/
├── 文档/算法详解/比较类排序/
│   ├── 05-归并排序.md
│   ├── 06-快速排序.md
│   ├── 07-堆排序.md
│   └── 08-快速选择.md
│
└── 算法包/
    ├── 归并排序/（标准结构）
    ├── 快速排序/（标准结构）
    ├── 堆排序/（标准结构）
    └── 快速选择/
        ├── README.md
        ├── src/index.ts        # quickSelect 实现
        ├── src/demo.ts         # TopK 使用示例
        └── test/index.test.ts
```

【快速选择接口规范】
```typescript
// 找到第 k 小的元素（k 从 0 开始）
export function quickSelect<T>(
  arr: readonly T[],
  k: number,
  cmp: (a: T, b: T) => number
): T;

// TopK：返回最小的 k 个元素（无序）
export function topK<T>(
  arr: readonly T[],
  k: number,
  cmp: (a: T, b: T) => number
): T[];

export const meta = {
  name: '快速选择',
  timeComplexity: { average: 'O(n)', worst: 'O(n²)' },
  spaceComplexity: 'O(1)',
  适用场景: ['第K大/小元素', 'TopK问题', '中位数']
};
```

【文档额外要求】
1) **归并排序**：必须包含递归版和迭代版（自底向上）
2) **快速排序**：
   - 必须讲解 pivot 选择策略（首元素/随机/三数取中）
   - 必须讲解尾递归优化
   - 必须警告最坏情况风险
3) **堆排序**：
   - 必须讲解 heapify 的两种方式（自顶向下/自底向上建堆）
   - 必须说明为何不稳定
4) **快速选择**：
   - 必须讲解与快排的关系
   - 必须讲解 TopK 问题的多种解法对比（全排序 vs 堆 vs 快选）

【Mermaid 图要求】
- 归并：分治合并过程图
- 快排：partition 分区过程图
- 堆排：堆化过程图
- 快选：与快排的对比决策图

【输出顺序】
- 先输出本次新增的目录树
- 再逐文件输出完整内容
- 不要生成任何工程配置文件

---











## S2.prompt.md（工业级变种：三路快排/Introsort/TimSort）

你现在是「排序算法讲师 + 工程实践派」。

【本次任务】S2：在 `algorithm/排序/` 内新增"工业级/变种排序"的文档与代码。
重点强调：看到数据特征（重复多/近乎有序/最坏情况风险）就知道该选哪种变体。

【需要新增的算法】
- 三路快速排序（大量重复元素时）
- Introsort（避免快排最坏情况）
- TimSort（近乎有序、稳定，适合表格/业务数据）

【必须生成的目录结构】
```
algorithm/排序/
├── 文档/算法详解/比较类排序/
│   ├── 09-三路快排.md
│   ├── 10-Introsort.md
│   └── 11-TimSort.md
│
└── 算法包/
    ├── 三路快排/（标准结构）
    ├── Introsort/（标准结构）
    └── TimSort/（标准结构）
```

【实现要求】

1) **三路快排**：
   - 必须是经典 Dijkstra 3-way partition（< pivot / = pivot / > pivot）
   - 解释为何对重复多数据更快

2) **Introsort**：
   - 递归深度阈值：2 * floor(log2(n))
   - 超过阈值切换到堆排序
   - 小数组使用插入排序优化（阈值 <= 16）
   - 可复用 S1b 的堆排序逻辑

3) **TimSort**：
   - 实现"教学版简化实现"，但必须具备：
     - run 检测（上升/下降 run，下降需要反转）
     - 最小 run（minrun）策略
     - 稳定合并（merge）
     - galloping 模式（可选，讲清楚即可）
   - 重点保证：稳定性 + 近乎有序数据表现好

4) **demo.ts 必须包含**：
   - "表格多列稳定排序"的例子
   - 明确指出 TimSort 的优势

【文档要求】
- 每篇必须有 Mermaid：
  - 三路快排：分区过程图
  - Introsort：决策流程图（快排→深度阈值→堆排兜底→小数组插入）
  - TimSort：run 检测与合并栈流程图

- 每篇必须给出"场景识别信号"：
  - 重复多 → 三路快排
  - 担心最坏情况/对抗输入 → Introsort
  - 近乎有序/业务表格多列/稳定强需求 → TimSort

- 每篇必须给出 2-5 行不变式/正确性解释

【输出顺序】
- 目录树（本次新增）
- 逐文件完整内容
- 不要生成任何工程配置文件

---













## S3.prompt.md（非比较排序 + 外部归并）

你现在是「排序算法讲师（强调适用边界）」。

【本次任务】S3：在 `algorithm/排序/` 内新增"非比较排序 + 外部排序"的文档与代码。
重点：让读者一眼看出"什么时候能用非比较排序（整数键/范围小/定长）"。

【需要新增的算法】

**非比较排序**：
- 计数排序
- 桶排序
- 基数排序（LSD 优先，支持非负整数）

**外部排序**：
- 外部归并排序（分块排序 + k 路归并；前端可类比分片处理大数组）

【必须生成的目录结构】
```
algorithm/排序/
├── 文档/算法详解/
│   ├── 非比较排序/
│   │   ├── 01-计数排序.md
│   │   ├── 02-桶排序.md
│   │   └── 03-基数排序.md
│   └── 外部排序/
│       └── 01-外部归并排序.md
│
└── 算法包/
    ├── 计数排序/（标准结构）
    ├── 桶排序/（标准结构）
    ├── 基数排序/（标准结构）
    └── 外部归并排序/（标准结构）
```

【实现要求】

1) **非比较排序必须明确输入限制**，代码层做 runtime 校验：
   - 计数：整数且范围可控（需要 min/max）
   - 桶：可映射到 [0,1) 或区间；给出 bucketIndex 函数
   - 基数：非负整数（默认），解释位数/基数选择

2) **稳定性实现**：
   - 计数排序（稳定版实现）
   - 基数排序（基于稳定子排序）
   - 桶排序稳定性取决于桶内排序（说明并实现稳定版本）

3) **外部归并**：
   - 用 chunkSize 把数组分块
   - 每块用内部排序（可调用 TimSort 或归并）
   - 再做 k 路归并
   - 提供可插拔的 sortChunk 和 mergeK 设计

4) **demo.ts 必须包含**：
   - 表格场景：按整数列排序（如 score）
   - 搜索结果场景：按整数/时间戳字段排序
   - 讨论"是否值得用非比较排序"

5) **test 要求**：
   - 覆盖边界（空/重复/极值/非法输入）
   - 对稳定算法验证稳定性

【文档要求】
- 每篇至少 1 张 Mermaid：
  - 计数：计数→前缀和→回填
  - 基数：按位多轮稳定排序流程
  - 外部归并：分块→排序→多路归并流程图

- 每篇必须明确"什么时候别用"

- 给出"看到场景就选"的信号：
  - 小范围整数 → 计数
  - 均匀分布、可映射桶 → 桶
  - 固定位数/整数键、需要稳定 → 基数
  - 数据太大/流式/无法一次装入内存 → 外部归并

【输出顺序】
- 目录树（本次新增）
- 逐文件完整内容
- 不要生成任何工程配置文件

---










## S4.prompt.md（前端实战：表格排序 & 搜索结果排序 + 自测清单）

你现在是「前端工程 + 算法应用」导师。

【本次任务】S4：补齐"前端实战章节"与"示例应用"，让读者做到：
- 表格多列排序：稳定性、比较器设计、性能与可维护性
- 搜索结果排序：TopK、分页、增量更新
- 自测清单：检验学习成果

【必须新增的文件】
```
algorithm/排序/
├── 文档/
│   ├── 05-表格排序实战.md
│   ├── 06-搜索结果与TopK.md
│   └── 07-自测清单.md
│
└── 示例应用/
    ├── 表格排序/
    │   ├── README.md
    │   ├── src/
    │   │   ├── 数据模型.ts
    │   │   ├── 多列稳定排序.ts
    │   │   ├── 比较器组合器.ts
    │   │   └── demo.ts
    │   └── test/index.test.ts
    │
    └── 搜索结果排序/
        ├── README.md
        ├── src/
        │   ├── 数据模型.ts
        │   ├── TopK小顶堆.ts
        │   ├── 增量更新排序.ts
        │   ├── 分页与游标.ts
        │   └── demo.ts
        └── test/index.test.ts
```

【05-表格排序实战.md 要求】

1) 必须讲清"稳定性"的真实含义：
   - 方式A：稳定排序 + 从次关键字到主关键字依次排序
   - 方式B：组合比较器一次排序（但要保证 comparator 合法）
   - 对比两种方式的可读性/可维护性/性能

2) 必须提供"稳定排序辅助"的实际使用（调用公共库）

3) Mermaid：
   - 多列排序流程图
   - comparator 组合逻辑图

【06-搜索结果与TopK.md 要求】

1) 必须覆盖 TopK 的工程动机：避免全量排序

2) 给出 3 种方案对比：
   - 全量排序 O(n log n)
   - TopK 堆 O(n log k)
   - 快速选择 O(n) 平均

3) 增量更新：新结果持续到来时如何维护"有序窗口"

4) Mermaid：
   - TopK 流程图（堆维护）
   - 分页/游标稳定性说明图

【07-自测清单.md 要求】

1) 分模块自测问题：
   - 基础概念（复杂度、稳定性、原地）
   - 比较排序（冒泡到TimSort）
   - 非比较排序
   - 前端实战

2) 每个问题给出：
   - 问题
   - 参考答案（折叠）
   - 关联章节

【示例应用 test 要求】
- 表格多列排序结果正确 + 稳定性
- TopK 输出正确（与全量排序对比）
- 增量更新不会破坏排序不变量

【输出顺序】
- 目录树（本次新增）
- 逐文件完整内容
- 不要生成任何工程配置文件

---


















## 📊 六次任务总览

| 步骤 | 内容 | 预估文件数 |
|:---:|------|:---------:|
| S0 | 骨架 + 公共库 + 基准测试框架 | ~15 |
| S1a | 冒泡/选择/插入/希尔 | ~16 |
| S1b | 归并/快排/堆排/快速选择 | ~16 |
| S2 | 三路快排/Introsort/TimSort | ~12 |
| S3 | 计数/桶/基数/外部归并 | ~16 |
| S4 | 表格排序 + 搜索结果 + 自测清单 | ~15 |

## 📁 最终目录结构预览

```
algorithm/排序/
├── README.md
│
├── 文档/
│   ├── 00-总览.md
│   ├── 01-选型决策树.md
│   ├── 02-复杂度对比表.md
│   ├── 03-JS原生sort陷阱.md
│   ├── 04-测试与基准指南.md
│   ├── 05-表格排序实战.md
│   ├── 06-搜索结果与TopK.md
│   ├── 07-自测清单.md
│   │
│   └── 算法详解/
│       ├── 比较类排序/
│       │   ├── 01-冒泡排序.md
│       │   ├── 02-选择排序.md
│       │   ├── 03-插入排序.md
│       │   ├── 04-希尔排序.md
│       │   ├── 05-归并排序.md
│       │   ├── 06-快速排序.md
│       │   ├── 07-堆排序.md
│       │   ├── 08-快速选择.md
│       │   ├── 09-三路快排.md
│       │   ├── 10-Introsort.md
│       │   └── 11-TimSort.md
│       ├── 非比较排序/
│       │   ├── 01-计数排序.md
│       │   ├── 02-桶排序.md
│       │   └── 03-基数排序.md
│       └── 外部排序/
│           └── 01-外部归并排序.md
│
├── 算法包/
│   ├── 公共库/
│   ├── 冒泡排序/
│   ├── 选择排序/
│   ├── 插入排序/
│   ├── 希尔排序/
│   ├── 归并排序/
│   ├── 快速排序/
│   ├── 堆排序/
│   ├── 快速选择/
│   ├── 三路快排/
│   ├── Introsort/
│   ├── TimSort/
│   ├── 计数排序/
│   ├── 桶排序/
│   ├── 基数排序/
│   └── 外部归并排序/
│
├── 示例应用/
│   ├── 表格排序/
│   └── 搜索结果排序/
│
└── 基准测试/
```
