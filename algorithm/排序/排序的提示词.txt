# 排序算法教程生成提示词（共 6 次对话）

> 目标目录：`algorithm/排序/`
> 分 6 步完成：S0（骨架）→ S1a（基础4种）→ S1b（高级3种）→ S2（工业级）→ S3（非比较）→ S4（实战）

---






## S0.prompt.md（骨架 + 公共库 + 基准测试框架）

你现在是「算法与工程化写作专家（JS/TS）」。

【本次任务】S0：在 `algorithm/排序/` 目录下搭建"教程 + 可复用代码公共库 + 基准测试框架"的骨架。
后续 S1a–S4 会继续往里补充具体算法文件。

【必须生成的目录结构】
```
algorithm/排序/
├── README.md                          # 项目总览
│
├── 文档/
│   ├── 00-总览.md
│   ├── 01-选型决策树.md
│   ├── 02-复杂度对比表.md
│   ├── 03-JS原生sort陷阱.md
│   ├── 04-测试与基准指南.md
│   └── 算法详解/
│       ├── 比较类排序/               # 占位，S1a/S1b 补充
│       ├── 非比较排序/               # 占位，S3 补充
│       └── 外部排序/                 # 占位，S3 补充
│
├── 算法包/
│   └── 公共库/
│       ├── README.md
│       └── src/
│           ├── 比较器.ts
│           ├── 数据生成器.ts
│           ├── 正确性校验.ts
│           ├── 稳定排序辅助.ts
│           └── 性能计时.ts
│
└── 基准测试/
    ├── README.md
    └── src/
        ├── 测试用例集.ts
        └── 运行基准.ts
```

【内容要求】

1) **文档要求**：
   - 图解直觉为主，辅以少量不变式/正确性说明
   - 大量使用 Mermaid 图表

2) **00-总览.md 必须包含**：
   - 学习路线图（Mermaid flowchart）
   - 各算法适用场景速查表
   - 文件索引

3) **01-选型决策树.md 必须包含**：
   - 场景 → 算法的 Mermaid 决策树（看到场景就能选算法）
   - 稳定性/原地/额外内存的判定流程图

4) **02-复杂度对比表.md 必须包含**：
   - 比较排序 vs 非比较排序分类
   - 时间复杂度（最好/平均/最坏）+ 空间复杂度 + 是否稳定 + 是否原地
   - 表头先写好，具体算法行标注"S1a/S1b/S2/S3 补充"

5) **03-JS原生sort陷阱.md 必须覆盖**：
   - comparator 必须满足自反/传递/一致性
   - 字符串 localeCompare 成本、数字排序坑（"10" vs "2"）
   - 稳定性：现代 JS sort 要求稳定，但不能依赖历史实现细节
   - 给出"显式稳定排序"的做法（引用 公共库/稳定排序辅助.ts）

6) **公共库代码要求**：
   - 仅用 TS/JS 标准能力（不引入第三方库）
   - 测试用纯手写断言（不依赖 Jest/Vitest）
   - 提供：
     - 比较器规范（数字、字符串、对象字段）
     - 数据生成器（随机/近乎有序/重复多/逆序/已排序）
     - 正确性校验（有序性、置换性、稳定性）
     - 性能计时（比较次数/交换次数/耗时）
   - 稳定排序辅助：Schwartzian transform / decorate-sort-undecorate

7) **基准测试框架**：
   - 运行基准.ts：能对"已存在的算法包"做统一跑分
   - 测试用例集.ts：定义多种数据规模与分布（含表格数据、搜索结果数据）

【输出顺序】
- 先输出完整目录树
- 再按文件路径顺序，逐文件输出完整内容
- 不要生成任何工程配置文件（package.json、tsconfig.json 等）

---









## S1a.prompt.md（基础排序：冒泡/选择/插入/希尔）

你现在是「排序算法讲师 + TS 实现工程师」。

【本次任务】S1a：在 `algorithm/排序/` 内补齐"基础比较排序"的文档与代码。
严格在既有目录内新增文件，不要改动 S0 已生成文件内容。

【需要补齐的算法】
- 冒泡排序、选择排序、插入排序、希尔排序

【必须生成的目录结构】
```
algorithm/排序/
├── 文档/算法详解/比较类排序/
│   ├── 01-冒泡排序.md
│   ├── 02-选择排序.md
│   ├── 03-插入排序.md
│   └── 04-希尔排序.md
│
└── 算法包/
    ├── 冒泡排序/
    │   ├── README.md           # 快速使用指南
    │   ├── src/index.ts        # 算法实现
    │   ├── src/demo.ts         # 使用示例
    │   └── test/index.test.ts  # 测试用例
    ├── 选择排序/（同结构）
    ├── 插入排序/（同结构）
    └── 希尔排序/（同结构）
```

【统一接口规范（所有算法包都必须遵守）】
```typescript
// src/index.ts 必须导出：

// 不修改原数组，返回新数组
export function sort<T>(arr: readonly T[], cmp: (a: T, b: T) => number): T[];

// 原地排序（可选但推荐）
export function sortInPlace<T>(arr: T[], cmp: (a: T, b: T) => number): T[];

// 元信息
export const meta = {
  name: '冒泡排序',
  stable: true,           // 是否稳定
  inPlace: true,          // 是否原地
  timeComplexity: {
    best: 'O(n)',
    average: 'O(n²)',
    worst: 'O(n²)'
  },
  spaceComplexity: 'O(1)',
  适用场景: ['教学演示', '小规模数据'],
  不适用场景: ['大规模数据', '性能敏感场景']
};
```

【demo.ts 要求】
- 演示对"表格行对象"的排序（按分数降序、同分按姓名升序）
- 演示对"搜索结果对象"的排序（按 relevance 降序、同分按时间降序）

【test 要求】
- 使用 `算法包/公共库/src/正确性校验.ts` 做校验
- 用纯手写断言（不依赖 Jest/Vitest）
- 覆盖：空数组、单元素、重复多、已排序、逆序、随机
- 对于稳定排序，必须额外测试"稳定性"

【文档要求（每篇算法文档都必须包含）】
1) **核心思想**（图解直觉）
2) **适用场景**：什么时候用、什么时候别用（"看到场景就能选"）
3) **优缺点**（含工程点：常数因子、缓存友好）
4) **变种/优化点**（如冒泡的提前终止优化）
5) **复杂度分析**：时间（最好/平均/最坏）、空间、稳定性、是否原地
6) **Mermaid 图**：至少 1 张流程图或过程示意图
7) **正确性说明**：2-5 行不变式解释"为什么对"
8) **前端场景**：表格排序稳定性、搜索结果场景

【README.md（算法包）分工说明】
- README.md：快速使用（API、示例调用）
- 文档/算法详解/：详细原理讲解

【输出顺序】
- 先输出本次新增的目录树
- 再逐文件输出完整内容
- 不要生成任何工程配置文件

---










## S1b.prompt.md（高级比较排序：归并/快排/堆排 + 快速选择）

你现在是「排序算法讲师 + TS 实现工程师」。

【本次任务】S1b：在 `algorithm/排序/` 内补齐"高级比较排序"的文档与代码。

【需要补齐的算法】
- 归并排序、快速排序、堆排序
- 快速选择（quickSelect，用于 TopK 问题）

【必须生成的目录结构】
```
algorithm/排序/
├── 文档/算法详解/比较类排序/
│   ├── 05-归并排序.md
│   ├── 06-快速排序.md
│   ├── 07-堆排序.md
│   └── 08-快速选择.md
│
└── 算法包/
    ├── 归并排序/（标准结构）
    ├── 快速排序/（标准结构）
    ├── 堆排序/（标准结构）
    └── 快速选择/
        ├── README.md
        ├── src/index.ts        # quickSelect 实现
        ├── src/demo.ts         # TopK 使用示例
        └── test/index.test.ts
```

【快速选择接口规范】
```typescript
// 找到第 k 小的元素（k 从 0 开始）
export function quickSelect<T>(
  arr: readonly T[],
  k: number,
  cmp: (a: T, b: T) => number
): T;

// TopK：返回最小的 k 个元素（无序）
export function topK<T>(
  arr: readonly T[],
  k: number,
  cmp: (a: T, b: T) => number
): T[];

export const meta = {
  name: '快速选择',
  timeComplexity: { average: 'O(n)', worst: 'O(n²)' },
  spaceComplexity: 'O(1)',
  适用场景: ['第K大/小元素', 'TopK问题', '中位数']
};
```

【文档额外要求】
1) **归并排序**：必须包含递归版和迭代版（自底向上）
2) **快速排序**：
   - 必须讲解 pivot 选择策略（首元素/随机/三数取中）
   - 必须讲解尾递归优化
   - 必须警告最坏情况风险
3) **堆排序**：
   - 必须讲解 heapify 的两种方式（自顶向下/自底向上建堆）
   - 必须说明为何不稳定
4) **快速选择**：
   - 必须讲解与快排的关系
   - 必须讲解 TopK 问题的多种解法对比（全排序 vs 堆 vs 快选）

【Mermaid 图要求】
- 归并：分治合并过程图
- 快排：partition 分区过程图
- 堆排：堆化过程图
- 快选：与快排的对比决策图

【输出顺序】
- 先输出本次新增的目录树
- 再逐文件输出完整内容
- 不要生成任何工程配置文件

---











## S2.prompt.md（工业级变种：三路快排/Introsort/TimSort）

你现在是「排序算法讲师 + 工程实践派」。

【本次任务】S2：在 `algorithm/排序/` 内新增"工业级/变种排序"的文档与代码。
重点强调：看到数据特征（重复多/近乎有序/最坏情况风险）就知道该选哪种变体。

【需要新增的算法】
- 三路快速排序（大量重复元素时）
- Introsort（避免快排最坏情况）
- TimSort（近乎有序、稳定，适合表格/业务数据）

【必须生成的目录结构】
```
algorithm/排序/
├── 文档/算法详解/比较类排序/
│   ├── 09-三路快排.md
│   ├── 10-Introsort.md
│   └── 11-TimSort.md
│
└── 算法包/
    ├── 三路快排/（标准结构）
    ├── Introsort/（标准结构）
    └── TimSort/（标准结构）
```

【实现要求】

1) **三路快排**：
   - 必须是经典 Dijkstra 3-way partition（< pivot / = pivot / > pivot）
   - 解释为何对重复多数据更快

2) **Introsort**：
   - 递归深度阈值：2 * floor(log2(n))
   - 超过阈值切换到堆排序
   - 小数组使用插入排序优化（阈值 <= 16）
   - 可复用 S1b 的堆排序逻辑

3) **TimSort**：
   - 实现"教学版简化实现"，但必须具备：
     - run 检测（上升/下降 run，下降需要反转）
     - 最小 run（minrun）策略
     - 稳定合并（merge）
     - galloping 模式（可选，讲清楚即可）
   - 重点保证：稳定性 + 近乎有序数据表现好

4) **demo.ts 必须包含**：
   - "表格多列稳定排序"的例子
   - 明确指出 TimSort 的优势

【文档要求】
- 每篇必须有 Mermaid：
  - 三路快排：分区过程图
  - Introsort：决策流程图（快排→深度阈值→堆排兜底→小数组插入）
  - TimSort：run 检测与合并栈流程图

- 每篇必须给出"场景识别信号"：
  - 重复多 → 三路快排
  - 担心最坏情况/对抗输入 → Introsort
  - 近乎有序/业务表格多列/稳定强需求 → TimSort

- 每篇必须给出 2-5 行不变式/正确性解释

【输出顺序】
- 目录树（本次新增）
- 逐文件完整内容
- 不要生成任何工程配置文件

---













## S3.prompt.md（非比较排序 + 外部归并）

你现在是「排序算法讲师（强调适用边界）」。

【本次任务】S3：在 `algorithm/排序/` 内新增"非比较排序 + 外部排序"的文档与代码。
重点：让读者一眼看出"什么时候能用非比较排序（整数键/范围小/定长）"。

【需要新增的算法】

**非比较排序**：
- 计数排序
- 桶排序
- 基数排序（LSD 优先，支持非负整数）

**外部排序**：
- 外部归并排序（分块排序 + k 路归并；前端可类比分片处理大数组）

【必须生成的目录结构】
```
algorithm/排序/
├── 文档/算法详解/
│   ├── 非比较排序/
│   │   ├── 01-计数排序.md
│   │   ├── 02-桶排序.md
│   │   └── 03-基数排序.md
│   └── 外部排序/
│       └── 01-外部归并排序.md
│
└── 算法包/
    ├── 计数排序/（标准结构）
    ├── 桶排序/（标准结构）
    ├── 基数排序/（标准结构）
    └── 外部归并排序/（标准结构）
```

【实现要求】

1) **非比较排序必须明确输入限制**，代码层做 runtime 校验：
   - 计数：整数且范围可控（需要 min/max）
   - 桶：可映射到 [0,1) 或区间；给出 bucketIndex 函数
   - 基数：非负整数（默认），解释位数/基数选择

2) **稳定性实现**：
   - 计数排序（稳定版实现）
   - 基数排序（基于稳定子排序）
   - 桶排序稳定性取决于桶内排序（说明并实现稳定版本）

3) **外部归并**：
   - 用 chunkSize 把数组分块
   - 每块用内部排序（可调用 TimSort 或归并）
   - 再做 k 路归并
   - 提供可插拔的 sortChunk 和 mergeK 设计

4) **demo.ts 必须包含**：
   - 表格场景：按整数列排序（如 score）
   - 搜索结果场景：按整数/时间戳字段排序
   - 讨论"是否值得用非比较排序"

5) **test 要求**：
   - 覆盖边界（空/重复/极值/非法输入）
   - 对稳定算法验证稳定性

【文档要求】
- 每篇至少 1 张 Mermaid：
  - 计数：计数→前缀和→回填
  - 基数：按位多轮稳定排序流程
  - 外部归并：分块→排序→多路归并流程图

- 每篇必须明确"什么时候别用"

- 给出"看到场景就选"的信号：
  - 小范围整数 → 计数
  - 均匀分布、可映射桶 → 桶
  - 固定位数/整数键、需要稳定 → 基数
  - 数据太大/流式/无法一次装入内存 → 外部归并

【输出顺序】
- 目录树（本次新增）
- 逐文件完整内容
- 不要生成任何工程配置文件

---










## S4.prompt.md（前端实战：表格排序 & 搜索结果排序 + 自测清单）

你现在是「前端工程 + 算法应用」导师。

【本次任务】S4：补齐"前端实战章节"与"示例应用"，让读者做到：
- 表格多列排序：稳定性、比较器设计、性能与可维护性
- 搜索结果排序：TopK、分页、增量更新
- 自测清单：检验学习成果

【必须新增的文件】
```
algorithm/排序/
├── 文档/
│   ├── 05-表格排序实战.md
│   ├── 06-搜索结果与TopK.md
│   └── 07-自测清单.md
│
└── 示例应用/
    ├── 表格排序/
    │   ├── README.md
    │   ├── src/
    │   │   ├── 数据模型.ts
    │   │   ├── 多列稳定排序.ts
    │   │   ├── 比较器组合器.ts
    │   │   └── demo.ts
    │   └── test/index.test.ts
    │
    └── 搜索结果排序/
        ├── README.md
        ├── src/
        │   ├── 数据模型.ts
        │   ├── TopK小顶堆.ts
        │   ├── 增量更新排序.ts
        │   ├── 分页与游标.ts
        │   └── demo.ts
        └── test/index.test.ts
```

【05-表格排序实战.md 要求】

1) 必须讲清"稳定性"的真实含义：
   - 方式A：稳定排序 + 从次关键字到主关键字依次排序
   - 方式B：组合比较器一次排序（但要保证 comparator 合法）
   - 对比两种方式的可读性/可维护性/性能

2) 必须提供"稳定排序辅助"的实际使用（调用公共库）

3) Mermaid：
   - 多列排序流程图
   - comparator 组合逻辑图

【06-搜索结果与TopK.md 要求】

1) 必须覆盖 TopK 的工程动机：避免全量排序

2) 给出 3 种方案对比：
   - 全量排序 O(n log n)
   - TopK 堆 O(n log k)
   - 快速选择 O(n) 平均

3) 增量更新：新结果持续到来时如何维护"有序窗口"

4) Mermaid：
   - TopK 流程图（堆维护）
   - 分页/游标稳定性说明图

【07-自测清单.md 要求】

1) 分模块自测问题：
   - 基础概念（复杂度、稳定性、原地）
   - 比较排序（冒泡到TimSort）
   - 非比较排序
   - 前端实战

2) 每个问题给出：
   - 问题
   - 参考答案（折叠）
   - 关联章节

【示例应用 test 要求】
- 表格多列排序结果正确 + 稳定性
- TopK 输出正确（与全量排序对比）
- 增量更新不会破坏排序不变量

【输出顺序】
- 目录树（本次新增）
- 逐文件完整内容
- 不要生成任何工程配置文件

---


















## 📊 六次任务总览

| 步骤 | 内容 | 预估文件数 |
|:---:|------|:---------:|
| S0 | 骨架 + 公共库 + 基准测试框架 | ~15 |
| S1a | 冒泡/选择/插入/希尔 | ~16 |
| S1b | 归并/快排/堆排/快速选择 | ~16 |
| S2 | 三路快排/Introsort/TimSort | ~12 |
| S3 | 计数/桶/基数/外部归并 | ~16 |
| S4 | 表格排序 + 搜索结果 + 自测清单 | ~15 |

## 📁 最终目录结构预览

```
algorithm/排序/
├── README.md
│
├── 文档/
│   ├── 00-总览.md
│   ├── 01-选型决策树.md
│   ├── 02-复杂度对比表.md
│   ├── 03-JS原生sort陷阱.md
│   ├── 04-测试与基准指南.md
│   ├── 05-表格排序实战.md
│   ├── 06-搜索结果与TopK.md
│   ├── 07-自测清单.md
│   │
│   └── 算法详解/
│       ├── 比较类排序/
│       │   ├── 01-冒泡排序.md
│       │   ├── 02-选择排序.md
│       │   ├── 03-插入排序.md
│       │   ├── 04-希尔排序.md
│       │   ├── 05-归并排序.md
│       │   ├── 06-快速排序.md
│       │   ├── 07-堆排序.md
│       │   ├── 08-快速选择.md
│       │   ├── 09-三路快排.md
│       │   ├── 10-Introsort.md
│       │   └── 11-TimSort.md
│       ├── 非比较排序/
│       │   ├── 01-计数排序.md
│       │   ├── 02-桶排序.md
│       │   └── 03-基数排序.md
│       └── 外部排序/
│           └── 01-外部归并排序.md
│
├── 算法包/
│   ├── 公共库/
│   ├── 冒泡排序/
│   ├── 选择排序/
│   ├── 插入排序/
│   ├── 希尔排序/
│   ├── 归并排序/
│   ├── 快速排序/
│   ├── 堆排序/
│   ├── 快速选择/
│   ├── 三路快排/
│   ├── Introsort/
│   ├── TimSort/
│   ├── 计数排序/
│   ├── 桶排序/
│   ├── 基数排序/
│   └── 外部归并排序/
│
├── 示例应用/
│   ├── 表格排序/
│   └── 搜索结果排序/
│
└── 基准测试/
```



===============================================================================
## 补充阶段：深度拓展（S5-S7）
===============================================================================

> 以下为在 S0-S4 基础上的深度补充，适合追求深入理解的学习者。



---




## S5.prompt.md（底层实现 + LeetCode 题目映射）

你现在是「排序算法深度研究员 + 算法面试辅导专家」。

【本次任务】S5：补充"底层实现分析"与"LeetCode 题目映射"，让读者：
- 理解 V8/Python/Java 等语言的排序实现细节
- 将排序知识与算法面试题目关联起来

【必须新增的文件】
```
algorithm/排序/
├── 文档/
│   ├── 08-底层实现深度剖析.md
│   └── 09-LeetCode题目映射.md
│
└── 算法包/
    └── 公共库/src/
        └── 链表排序.ts          # 链表场景的排序实现
```

【08-底层实现深度剖析.md 要求】

1) **V8 TimSort 源码分析**（重点）
   - 源码位置：v8/src/third_party/v8/builtins/array-sort.tq
   - run 检测的具体实现
   - minrun 的计算公式（32-64 之间，目标是让 run 数接近 2 的幂）
   - galloping 模式触发条件（MIN_GALLOP = 7）
   - 合并栈的不变式（timsort invariant）
   - 与 Python 原版 TimSort 的差异

2) **各语言标准库对比**
   | 语言 | 算法 | 稳定性 | 特点 |
   |------|------|--------|------|
   | JavaScript (V8) | TimSort | ✅ | ES2019 后规范要求稳定 |
   | Python | TimSort | ✅ | TimSort 的发源地 |
   | Java | 双轴快排(primitive) / TimSort(Object) | ❌/✅ | 区分基本类型和对象 |
   | C++ STL | Introsort | ❌ | 快排+堆排+插入 |
   | Rust | 改进的归并 | ✅ | 稳定版本是默认 |
   | Go | pdqsort | ❌ | 模式检测快排 |

3) **为什么 TimSort 成为主流**
   - 现实数据的特点：部分有序、存在 run
   - 稳定性在业务场景的重要性
   - 对近乎有序数据的性能优势

4) **Mermaid 图**
   - TimSort 合并栈的维护流程
   - Introsort 的深度切换决策图
   - galloping 模式的触发与退出

【09-LeetCode题目映射.md 要求】

1) **按算法分类的题目表**

   | 算法 | 题目 | 难度 | 核心考点 |
   |------|------|------|---------|
   | 快速排序 | 912. 排序数组 | M | 基础实现 |
   | 快速选择 | 215. 第K大元素 | M | TopK 问题 |
   | 归并排序 | 148. 排序链表 | M | 链表 + 分治 |
   | 归并排序 | 剑指51. 逆序对 | H | 归并计数 |
   | 堆排序 | 347. 前K高频元素 | M | 堆 + 哈希 |
   | 计数排序 | 274. H指数 | M | 计数技巧 |
   | 桶排序 | 164. 最大间距 | H | 桶 + 鸽巢原理 |
   | 基数排序 | 179. 最大数 | M | 自定义比较 |
   | 拓扑排序 | 207. 课程表 | M | 图 + 排序 |

2) **按题型分类**
   - TopK 系列：215, 347, 692, 973
   - 排序变形：56(合并区间), 57(插入区间)
   - 自定义比较：179, 406, 452
   - 排序 + 双指针：15(三数之和), 18(四数之和)
   - 排序 + 贪心：435, 452, 646

3) **每道题给出**
   - 链接
   - 推荐解法
   - 关键技巧
   - 关联章节

4) **链表排序专题**
   - 为什么链表适合归并排序（不需要随机访问）
   - 为什么链表不适合快排（partition 困难）
   - 148. 排序链表 的详细解析

【链表排序.ts 要求】
```typescript
// 链表节点定义
interface ListNode<T> {
  value: T;
  next: ListNode<T> | null;
}

// 归并排序（适合链表）
export function mergeSortLinkedList<T>(
  head: ListNode<T> | null,
  cmp: (a: T, b: T) => number
): ListNode<T> | null;

// 插入排序（适合近乎有序的小链表）
export function insertionSortLinkedList<T>(
  head: ListNode<T> | null,
  cmp: (a: T, b: T) => number
): ListNode<T> | null;
```

【输出顺序】
- 目录树（本次新增）
- 逐文件完整内容
- 不要生成任何工程配置文件

---




## S6.prompt.md（可视化动画 + React 最佳实践）

你现在是「前端可视化工程师 + React 性能优化专家」。

【本次任务】S6：创建"排序可视化"和"React 排序最佳实践"模块。

【必须新增的文件】
```
algorithm/排序/
├── 文档/
│   ├── 10-React排序最佳实践.md
│   └── 11-可视化资源汇总.md
│
├── 可视化/
│   ├── README.md
│   ├── index.html                 # 入口页面
│   ├── src/
│   │   ├── visualizer.ts          # 核心可视化引擎
│   │   ├── algorithms/            # 各算法的可视化版本
│   │   │   ├── bubble.ts
│   │   │   ├── quick.ts
│   │   │   ├── merge.ts
│   │   │   └── heap.ts
│   │   ├── renderer.ts            # Canvas/SVG 渲染器
│   │   └── controls.ts            # 控制面板（速度、暂停、步进）
│   └── styles.css
│
└── 示例应用/
    └── React排序组件/
        ├── README.md
        ├── src/
        │   ├── hooks/
        │   │   ├── useSortedData.ts      # 排序数据 Hook
        │   │   └── useVirtualList.ts     # 虚拟列表 Hook
        │   ├── components/
        │   │   ├── SortableTable.tsx     # 可排序表格组件
        │   │   └── VirtualSortedList.tsx # 虚拟滚动排序列表
        │   ├── utils/
        │   │   ├── webWorkerSort.ts      # Web Worker 排序
        │   │   └── comparators.ts        # 比较器工具
        │   └── demo.tsx
        └── test/index.test.ts
```

【10-React排序最佳实践.md 要求】

1) **useMemo 缓存排序结果**
   ```typescript
   const sortedData = useMemo(() => {
     return [...data].sort(comparator);
   }, [data, comparator]);
   ```
   - 何时用 useMemo
   - 依赖数组的正确写法
   - 避免每次渲染都排序

2) **大数据量优化策略**
   - 虚拟滚动 + 排序：只渲染可见区域
   - Web Worker 排序：避免阻塞主线程
   - 分页 vs 虚拟滚动的选择

3) **Web Worker 排序实现**
   - Worker 文件结构
   - 主线程与 Worker 的通信
   - Transferable Objects 优化大数组传输
   - 示例代码

4) **表格组件的排序状态管理**
   - 单列排序 vs 多列排序
   - 排序状态的数据结构设计
   - 点击表头切换排序的 UX

5) **Mermaid 图**
   - Web Worker 排序流程图
   - 虚拟滚动 + 排序的数据流

6) **性能对比表**
   | 数据量 | 直接排序 | useMemo | Web Worker |
   |--------|---------|---------|------------|
   | 1,000 | 即时 | 即时 | 不值得 |
   | 10,000 | ~50ms | 缓存后即时 | 可选 |
   | 100,000 | ~500ms | 缓存后即时 | 推荐 |
   | 1,000,000 | 卡顿 | 首次慢 | 必须 |

【11-可视化资源汇总.md 要求】

1) **推荐的在线可视化网站**
   | 网站 | 链接 | 特点 |
   |------|------|------|
   | VisuAlgo | https://visualgo.net/sorting | 最全面，支持步进 |
   | Sorting.at | https://sorting.at/ | 美观，对比多算法 |
   | Algorithm Visualizer | https://algorithm-visualizer.org/ | 支持代码编辑 |
   | USF | https://www.cs.usfca.edu/~galles/visualization/ | 经典教学 |

2) **本项目可视化使用说明**
   - 如何运行本地可视化
   - 支持的算法列表
   - 控制面板使用

【可视化模块要求】

1) **visualizer.ts 核心设计**
   ```typescript
   interface SortStep {
     type: 'compare' | 'swap' | 'highlight' | 'sorted';
     indices: number[];
     values?: number[];
   }

   // 生成排序步骤的生成器
   function* bubbleSortSteps(arr: number[]): Generator<SortStep>;
   ```

2) **渲染器要求**
   - 使用 Canvas 绘制柱状图
   - 支持：比较高亮（黄色）、交换（红色）、已排序（绿色）
   - 支持速度调节（1x/2x/4x/慢动作）
   - 支持暂停、继续、步进

3) **index.html 功能**
   - 算法选择下拉框
   - 数据规模滑块（10-200）
   - 数据分布选择（随机/近乎有序/逆序/重复多）
   - 播放控制按钮
   - 当前算法信息展示

【React 排序组件要求】

1) **useSortedData Hook**
   ```typescript
   function useSortedData<T>(
     data: T[],
     sortConfig: SortConfig<T> | null,
     options?: { useWorker?: boolean }
   ): {
     sortedData: T[];
     isLoading: boolean;
   };
   ```

2) **SortableTable 组件**
   - 点击表头排序
   - 显示排序方向指示器
   - 支持多列排序（Shift+点击）
   - 加载状态显示

【输出顺序】
- 目录树（本次新增）
- 逐文件完整内容
- 不要生成任何工程配置文件

---




## S7.prompt.md（进阶话题：并行排序 + 流式排序）

你现在是「高性能计算 + 实时系统」算法专家。

【本次任务】S7：补充进阶话题，覆盖特殊场景下的排序需求。

【必须新增的文件】
```
algorithm/排序/
├── 文档/
│   ├── 12-并行排序.md
│   └── 13-流式与增量排序.md
│
└── 算法包/
    ├── 并行归并排序/
    │   ├── README.md
    │   ├── src/
    │   │   ├── index.ts           # 主线程调度
    │   │   └── worker.ts          # Worker 文件
    │   └── test/index.test.ts
    │
    └── 流式排序/
        ├── README.md
        ├── src/
        │   ├── index.ts           # 流式排序接口
        │   ├── sortedWindow.ts    # 维护有序窗口
        │   └── onlineMedian.ts    # 在线中位数
        └── test/index.test.ts
```

【12-并行排序.md 要求】

1) **Web Worker 并行排序原理**
   - 分块 → 并行排序 → 多路归并
   - 通信开销 vs 并行收益
   - 何时值得使用并行排序（数据量阈值）

2) **实现方案**
   ```
   主线程                 Worker 1              Worker 2
      │                      │                     │
      ├──── chunk1 ─────────►│                     │
      ├──── chunk2 ──────────┼────────────────────►│
      │                      │                     │
      │◄──── sorted1 ────────┤                     │
      │◄──── sorted2 ────────┼─────────────────────┤
      │                      │                     │
      ├── k-way merge ───────┴─────────────────────┘
      │
      ▼
   final sorted array
   ```

3) **性能测试结果**
   - 单线程 vs 2 Worker vs 4 Worker
   - 不同数据规模的加速比
   - 通信开销占比分析

4) **Mermaid 图**
   - 并行排序数据流图
   - Worker 生命周期管理

【13-流式与增量排序.md 要求】

1) **流式数据场景**
   - 日志实时排序
   - 搜索结果增量更新
   - 股票行情排序

2) **维护有序窗口**
   - 问题：数据持续到来，维护最新 K 条有序数据
   - 方案：插入排序 + 二分查找插入位置
   - 复杂度：O(K) 插入，O(1) 访问

3) **在线中位数（经典问题）**
   - 双堆方案（最大堆 + 最小堆）
   - 与 LeetCode 295 的关联
   - 代码实现

4) **增量更新排序**
   - 新增元素：二分插入
   - 删除元素：标记删除 + 惰性清理
   - 修改元素：删除 + 插入

5) **Mermaid 图**
   - 双堆维护中位数流程图
   - 有序窗口更新流程

【并行归并排序实现要求】

```typescript
// index.ts
export interface ParallelSortOptions {
  workerCount?: number;      // 默认 navigator.hardwareConcurrency
  chunkSize?: number;        // 每块大小，默认自动计算
}

export async function parallelMergeSort<T>(
  arr: readonly T[],
  cmp: (a: T, b: T) => number,
  options?: ParallelSortOptions
): Promise<T[]>;

// 判断是否值得并行
export function shouldUseParallel(dataSize: number): boolean;
```

【流式排序实现要求】

```typescript
// sortedWindow.ts
export class SortedWindow<T> {
  constructor(
    capacity: number,
    cmp: (a: T, b: T) => number
  );

  // 插入新元素，超出容量时淘汰
  add(item: T): void;

  // 获取有序数组
  toArray(): T[];

  // 获取第 k 个元素
  get(k: number): T | undefined;
}

// onlineMedian.ts
export class OnlineMedian {
  add(value: number): void;
  getMedian(): number;
}
```

【输出顺序】
- 目录树（本次新增）
- 逐文件完整内容
- 不要生成任何工程配置文件

---




## 📊 补充阶段总览

| 步骤 | 内容 | 预估文件数 | 难度 |
|:---:|------|:---------:|:----:|
| S5 | 底层实现 + LeetCode 映射 | ~5 | ⭐⭐⭐ |
| S6 | 可视化 + React 最佳实践 | ~15 | ⭐⭐⭐⭐ |
| S7 | 并行排序 + 流式排序 | ~10 | ⭐⭐⭐⭐ |

## 📁 补充后的完整目录结构

```
algorithm/排序/
├── README.md
│
├── 文档/
│   ├── 00-总览.md
│   ├── 01-选型决策树.md
│   ├── 02-复杂度对比表.md
│   ├── 03-JS原生sort陷阱.md
│   ├── 04-测试与基准指南.md
│   ├── 05-表格排序实战.md
│   ├── 06-搜索结果与TopK.md
│   ├── 07-自测清单.md
│   ├── 08-底层实现深度剖析.md      ← S5 新增
│   ├── 09-LeetCode题目映射.md      ← S5 新增
│   ├── 10-React排序最佳实践.md     ← S6 新增
│   ├── 11-可视化资源汇总.md        ← S6 新增
│   ├── 12-并行排序.md              ← S7 新增
│   ├── 13-流式与增量排序.md        ← S7 新增
│   │
│   └── 算法详解/
│       ├── 比较类排序/（11 个算法）
│       ├── 非比较排序/（3 个算法）
│       └── 外部排序/（1 个算法）
│
├── 算法包/
│   ├── 公共库/
│   │   └── src/
│   │       ├── ...（原有文件）
│   │       └── 链表排序.ts         ← S5 新增
│   ├── 冒泡排序/ ~ 外部归并排序/（原有 15 个）
│   ├── 并行归并排序/               ← S7 新增
│   └── 流式排序/                   ← S7 新增
│
├── 示例应用/
│   ├── 表格排序/
│   ├── 搜索结果排序/
│   └── React排序组件/              ← S6 新增
│
├── 可视化/                          ← S6 新增
│   ├── README.md
│   ├── index.html
│   ├── src/
│   │   ├── visualizer.ts
│   │   ├── algorithms/
│   │   ├── renderer.ts
│   │   └── controls.ts
│   └── styles.css
│
└── 基准测试/
```

## 🎯 执行建议

1. **S5 底层实现**：适合想深入理解"为什么这么设计"的读者
2. **S6 可视化**：对初学者帮助最大，建议优先
3. **S7 进阶话题**：适合有实际需求的工程场景

推荐执行顺序：**S6 → S5 → S7**
