/**
 * ============================================================
 * 📚 复杂度分析 - 算法效率评估基础
 * ============================================================
 *
 * 复杂度分析是算法面试的必备知识，面试官必问。
 * 掌握后能够：
 * 1. 快速评估算法效率
 * 2. 判断算法是否能通过数据规模
 * 3. 对比不同解法的优劣
 */

// ============================================================
// 1. 大 O 表示法
// ============================================================

/**
 * 【什么是大 O 表示法】
 *
 * 大 O 表示法描述算法的渐进时间复杂度：
 * - 忽略常数因子
 * - 只保留最高阶项
 * - 描述的是"增长趋势"而非精确时间
 *
 * 例如：
 * - 3n² + 2n + 1 → O(n²)
 * - 100n + 1000 → O(n)
 * - 2^n + n³ → O(2^n)
 *
 * 【为什么要忽略常数和低阶项】
 *
 * 当 n 足够大时：
 * - n² 远大于 n，所以忽略 n
 * - 2n² 和 n² 的增长趋势相同，所以忽略常数 2
 *
 * ┌────────────────────────────────────────────────────────┐
 * │  n = 1000 时：                                         │
 * │  n² = 1,000,000                                       │
 * │  n  = 1,000                                           │
 * │  n 相比 n² 可以忽略不计                                │
 * └────────────────────────────────────────────────────────┘
 */

// ============================================================
// 2. 常见复杂度对比
// ============================================================

/**
 * 【复杂度从低到高排序】
 *
 * O(1) < O(log n) < O(n) < O(n log n) < O(n²) < O(n³) < O(2^n) < O(n!)
 *
 * 【直观理解】n = 1000 时的操作数
 *
 * ┌────────────┬──────────────┬────────────────────────────────┐
 * │  复杂度     │  操作数       │  典型算法                       │
 * ├────────────┼──────────────┼────────────────────────────────┤
 * │  O(1)      │  1           │  数组访问、哈希表查找            │
 * │  O(log n)  │  10          │  二分查找                       │
 * │  O(n)      │  1,000       │  线性遍历                       │
 * │  O(n log n)│  10,000      │  排序（归并、快排）              │
 * │  O(n²)     │  1,000,000   │  冒泡排序、双重循环              │
 * │  O(n³)     │  10^9        │  三重循环、矩阵乘法              │
 * │  O(2^n)    │  10^301      │  子集枚举、回溯（无剪枝）        │
 * │  O(n!)     │  天文数字     │  全排列枚举                     │
 * └────────────┴──────────────┴────────────────────────────────┘
 *
 * 【复杂度增长图】
 *
 * ```
 *  操作数
 *    ↑
 *    │                                    n!
 *    │                               /
 *    │                          2^n /
 *    │                         /
 *    │                    n³ /
 *    │                   /
 *    │              n² /
 *    │             /
 *    │        n log n
 *    │       /
 *    │      n
 *    │    /
 *    │  log n
 *    │ ___________  1
 *    └──────────────────────────────────────► n
 * ```
 */

// ============================================================
// 3. 数据规模与复杂度对应
// ============================================================

/**
 * 【重要！根据数据规模判断可接受的复杂度】
 *
 * 一般 OJ 每秒处理 10^7 ~ 10^8 次操作
 *
 * ┌────────────────┬─────────────────────────────────────────┐
 * │  数据规模 n     │  可接受的复杂度                         │
 * ├────────────────┼─────────────────────────────────────────┤
 * │  n ≤ 10        │  O(n!) 可以                             │
 * │  n ≤ 20        │  O(2^n) 可以                            │
 * │  n ≤ 100       │  O(n³) 可以                             │
 * │  n ≤ 1,000     │  O(n²) 可以                             │
 * │  n ≤ 10^5      │  O(n log n) 或 O(n) 推荐                │
 * │  n ≤ 10^6      │  O(n) 或 O(n log n) 必须                │
 * │  n ≤ 10^7      │  O(n) 必须                              │
 * │  n > 10^7      │  O(log n) 或 O(1) 必须                  │
 * └────────────────┴─────────────────────────────────────────┘
 *
 * 【实际应用】
 *
 * 看到题目说 n ≤ 10^5：
 * - 暴力 O(n²) 会超时！
 * - 需要找 O(n log n) 或 O(n) 的解法
 *
 * 看到题目说 n ≤ 20：
 * - 可以考虑回溯、状态压缩 DP
 * - O(2^n) 是可以接受的
 */

// ============================================================
// 4. 如何分析时间复杂度
// ============================================================

/**
 * 【规则一：循环分析】
 *
 * 单层循环 → O(n)
 * for (let i = 0; i < n; i++) { ... }
 *
 * 嵌套循环 → O(n²)
 * for (let i = 0; i < n; i++) {
 *   for (let j = 0; j < n; j++) { ... }
 * }
 *
 * 三层循环 → O(n³)
 * for (let i = 0; i < n; i++) {
 *   for (let j = 0; j < n; j++) {
 *     for (let k = 0; k < n; k++) { ... }
 *   }
 * }
 *
 * 【规则二：对数循环】
 *
 * 每次减半 → O(log n)
 * while (n > 0) { n = Math.floor(n / 2); }
 *
 * 每次翻倍 → O(log n)
 * for (let i = 1; i < n; i *= 2) { ... }
 *
 * 【规则三：不规则循环】
 */

// 例1：内层依赖外层
function example1(n: number): number {
  let count = 0;
  for (let i = 0; i < n; i++) {
    for (let j = 0; j < i; j++) {
      // 总次数：0 + 1 + 2 + ... + (n-1) = n(n-1)/2 = O(n²)
      count++;
    }
  }
  return count;
}

// 例2：两层循环但不是 O(n²)
function example2(n: number): number {
  let count = 0;
  for (let i = 1; i < n; i *= 2) {
    // 外层：log n 次
    for (let j = 0; j < n; j++) {
      // 内层：n 次
      count++; // 总计：O(n log n)
    }
  }
  return count;
}

// 例3：滑动窗口 - 看起来两层但是 O(n)
function example3(arr: number[]): number {
  let left = 0;
  let count = 0;
  for (let right = 0; right < arr.length; right++) {
    // left 和 right 各最多移动 n 次
    // 总计 O(2n) = O(n)
    while (left < right && arr[left] < arr[right]) {
      left++;
      count++;
    }
  }
  return count;
}

// ============================================================
// 5. 递归复杂度分析
// ============================================================

/**
 * 【方法一：递归树法】
 *
 * 画出递归调用树，计算总节点数
 *
 * 例：斐波那契（无记忆化）
 * fib(n) 调用 fib(n-1) 和 fib(n-2)
 *
 *                    fib(5)
 *                   /      \
 *              fib(4)      fib(3)
 *             /     \       /    \
 *         fib(3)  fib(2) fib(2) fib(1)
 *          / \
 *       fib(2) fib(1)
 *
 * 每层节点数翻倍，共 n 层 → O(2^n)
 *
 * 【方法二：主定理（Master Theorem）】
 *
 * 对于形如 T(n) = aT(n/b) + O(n^d) 的递归：
 *
 * ┌────────────────────┬─────────────────────────────────────┐
 * │  条件               │  复杂度                             │
 * ├────────────────────┼─────────────────────────────────────┤
 * │  d > log_b(a)      │  O(n^d)                             │
 * │  d = log_b(a)      │  O(n^d * log n)                     │
 * │  d < log_b(a)      │  O(n^(log_b(a)))                    │
 * └────────────────────┴─────────────────────────────────────┘
 *
 * 例：归并排序 T(n) = 2T(n/2) + O(n)
 * a=2, b=2, d=1
 * log_2(2) = 1 = d → O(n log n)
 *
 * 例：二分查找 T(n) = T(n/2) + O(1)
 * a=1, b=2, d=0
 * log_2(1) = 0 = d → O(log n)
 */

// ============================================================
// 6. 常见算法的复杂度速查
// ============================================================

/**
 * 【排序算法】
 *
 * ┌─────────────────┬───────────┬───────────┬───────────┬─────────┐
 * │  算法            │  最好     │  平均      │  最坏      │  空间   │
 * ├─────────────────┼───────────┼───────────┼───────────┼─────────┤
 * │  冒泡排序        │  O(n)     │  O(n²)    │  O(n²)    │  O(1)   │
 * │  选择排序        │  O(n²)    │  O(n²)    │  O(n²)    │  O(1)   │
 * │  插入排序        │  O(n)     │  O(n²)    │  O(n²)    │  O(1)   │
 * │  归并排序        │  O(nlogn) │  O(nlogn) │  O(nlogn) │  O(n)   │
 * │  快速排序        │  O(nlogn) │  O(nlogn) │  O(n²)    │  O(logn)│
 * │  堆排序          │  O(nlogn) │  O(nlogn) │  O(nlogn) │  O(1)   │
 * │  计数排序        │  O(n+k)   │  O(n+k)   │  O(n+k)   │  O(k)   │
 * └─────────────────┴───────────┴───────────┴───────────┴─────────┘
 *
 * 【数据结构操作】
 *
 * ┌─────────────────┬───────────┬───────────┬───────────┐
 * │  数据结构        │  查找      │  插入      │  删除     │
 * ├─────────────────┼───────────┼───────────┼───────────┤
 * │  数组            │  O(n)     │  O(n)     │  O(n)     │
 * │  有序数组        │  O(log n) │  O(n)     │  O(n)     │
 * │  链表            │  O(n)     │  O(1)     │  O(1)     │
 * │  哈希表          │  O(1)     │  O(1)     │  O(1)     │
 * │  二叉搜索树      │  O(log n) │  O(log n) │  O(log n) │
 * │  堆              │  O(n)     │  O(log n) │  O(log n) │
 * └─────────────────┴───────────┴───────────┴───────────┘
 */

// ============================================================
// 7. 空间复杂度
// ============================================================

/**
 * 【空间复杂度的组成】
 *
 * 1. 输入数据空间（通常不计）
 * 2. 辅助空间（额外申请的）
 * 3. 递归栈空间
 *
 * 【常见空间复杂度】
 *
 * O(1)：原地操作，常数个变量
 * O(n)：一维数组、哈希表
 * O(n²)：二维数组
 * O(log n)：递归深度（如二分）
 *
 * 【递归的空间复杂度】
 */

// O(n) 空间 - 递归深度 n
function factorial(n: number): number {
  if (n <= 1) return 1;
  return n * factorial(n - 1);
}

// O(log n) 空间 - 递归深度 log n
function binarySearchRecursive(
  arr: number[],
  target: number,
  left: number,
  right: number
): number {
  if (left > right) return -1;
  const mid = Math.floor((left + right) / 2);
  if (arr[mid] === target) return mid;
  if (arr[mid] < target) {
    return binarySearchRecursive(arr, target, mid + 1, right);
  }
  return binarySearchRecursive(arr, target, left, mid - 1);
}

// ============================================================
// 8. 均摊复杂度
// ============================================================

/**
 * 【什么是均摊复杂度】
 *
 * 某些操作偶尔很慢，但平均下来很快。
 *
 * 例：动态数组（ArrayList/Vector）的 push
 * - 通常 O(1)
 * - 扩容时 O(n)
 * - 均摊下来：O(1)
 *
 * 例：栈实现的队列
 * - pop 操作偶尔需要倒腾 O(n)
 * - 但每个元素最多被倒腾一次
 * - 均摊下来：O(1)
 */

// 动态数组示例
class DynamicArray {
  private data: number[] = [];
  private capacity = 2;
  private size = 0;

  push(value: number): void {
    if (this.size === this.capacity) {
      // 扩容：O(n)，但发生频率低
      this.capacity *= 2;
      const newData = new Array(this.capacity);
      for (let i = 0; i < this.size; i++) {
        newData[i] = this.data[i];
      }
      this.data = newData;
    }
    this.data[this.size++] = value;
    // 均摊复杂度：O(1)
  }
}

// ============================================================
// 9. 面试常见问题
// ============================================================

/**
 * 【Q1: 时间复杂度和空间复杂度哪个更重要？】
 *
 * A: 通常时间复杂度更重要，但要看具体场景：
 * - 对时间敏感（实时系统）→ 优先时间
 * - 内存受限（嵌入式）→ 优先空间
 * - 能说出 trade-off 是加分项
 *
 * 【Q2: 如何快速估算复杂度？】
 *
 * A: 看循环嵌套层数：
 * - 1 层循环 → O(n)
 * - 2 层循环 → O(n²)
 * - 带二分 → O(log n)
 * - 循环+二分 → O(n log n)
 *
 * 【Q3: O(n) 和 O(2n) 有区别吗？】
 *
 * A: 大 O 表示法中没有区别，O(2n) = O(n)。
 * 但实际运行时，常数因子会影响性能。
 * 面试中可以提及"虽然复杂度相同，但常数因子更小"。
 */

export {
  example1,
  example2,
  example3,
  factorial,
  binarySearchRecursive,
  DynamicArray,
};

