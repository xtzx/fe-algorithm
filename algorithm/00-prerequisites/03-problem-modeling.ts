/**
 * ============================================================
 * 📚 问题建模思维 - 核心能力
 * ============================================================
 *
 * 这是算法学习中最核心的能力：
 * 看到一个新题，能快速识别问题类型，归约到熟悉的模型。
 *
 * 本文件覆盖：
 * 1. 问题识别四问
 * 2. 信号词速查表
 * 3. 问题归约思维
 * 4. 变形题识别
 * 5. 算法选择决策树
 */

// ============================================================
// 1. 问题识别四问
// ============================================================

/**
 * 拿到一道新题，首先问自己四个问题：
 *
 * ┌─────────────────────────────────────────────────────────────┐
 * │                     问题识别四问                            │
 * ├─────────────────────────────────────────────────────────────┤
 * │                                                             │
 * │  Q1: 输入是什么？                                           │
 * │      → 数组、字符串、链表、树、图？                          │
 * │      → 有序还是无序？                                       │
 * │                                                             │
 * │  Q2: 输出是什么？                                           │
 * │      → 一个值（最大/最小/数量）？                           │
 * │      → 一个布尔值（是否可能）？                             │
 * │      → 所有方案？                                           │
 * │                                                             │
 * │  Q3: 约束是什么？                                           │
 * │      → 连续子数组还是子序列？                               │
 * │      → 可以重复使用还是只能用一次？                         │
 * │      → 有顺序要求吗？                                       │
 * │                                                             │
 * │  Q4: 数据规模是多少？                                       │
 * │      → n ≤ 20：可以用 O(2^n)，回溯暴力                      │
 * │      → n ≤ 1000：可以用 O(n²)                               │
 * │      → n ≤ 10^5：需要 O(n log n) 或 O(n)                   │
 * │                                                             │
 * └─────────────────────────────────────────────────────────────┘
 *
 * 【实例分析】
 *
 * 题目：给定一个整数数组 nums，找到其中最长递增子序列的长度。
 *
 * Q1: 输入是什么？→ 整数数组
 * Q2: 输出是什么？→ 一个值（长度）
 * Q3: 约束是什么？→ 子序列（不要求连续），递增
 * Q4: 数据规模？  → n ≤ 2500，O(n²) 可以，O(n log n) 更好
 *
 * 分析结果：→ 线性 DP + 二分优化
 */

// ============================================================
// 2. 信号词速查表 ⭐⭐⭐
// ============================================================

/**
 * 【信号词 → 算法映射总表】
 *
 * 这是最重要的速查表！看到关键词立刻联想到对应算法。
 *
 * ┌─────────────────────────────────────────────────────────────────────────┐
 * │                          信号词速查表                                    │
 * ├────────────────────────┬────────────────────┬───────────────────────────┤
 * │ 关键词/特征             │ 可能的算法          │ 典型题目                   │
 * ├────────────────────────┼────────────────────┼───────────────────────────┤
 * │                        │                    │                           │
 * │ 【数组/字符串】          │                    │                           │
 * │ 连续子数组/子串          │ 滑动窗口           │ 无重复最长子串              │
 * │ 有序 + 找两个数         │ 双指针（对撞）      │ 两数之和 II               │
 * │ 原地去重/移动           │ 快慢指针           │ 移动零、删除重复            │
 * │ 区间合并               │ 排序 + 扫描线       │ 合并区间                   │
 * │ 和为 K / 前缀相关       │ 前缀和 + 哈希       │ 和为K的子数组              │
 * │                        │                    │                           │
 * │ 【链表】                │                    │                           │
 * │ 反转                   │ 迭代/递归          │ 反转链表、K组反转           │
 * │ 环/中点/倒数第N        │ 快慢指针           │ 环形链表、链表中点          │
 * │ 合并                   │ 归并思想           │ 合并有序链表               │
 * │                        │                    │                           │
 * │ 【栈/队列】             │                    │                           │
 * │ 下一个更大/更小元素     │ 单调栈            │ 每日温度                   │
 * │ 括号匹配               │ 栈                │ 有效的括号                  │
 * │ 滑动窗口最值           │ 单调队列          │ 滑动窗口最大值              │
 * │                        │                    │                           │
 * │ 【树】                  │                    │                           │
 * │ 路径/深度/节点统计      │ DFS 递归          │ 最大深度、路径总和          │
 * │ 层序相关               │ BFS              │ 层序遍历、右视图            │
 * │ 验证/搜索树            │ 中序遍历          │ 验证BST、第K小             │
 * │                        │                    │                           │
 * │ 【二分】                │                    │                           │
 * │ 有序 + 查找            │ 标准二分          │ 搜索插入位置               │
 * │ 最大化最小/最小化最大   │ 答案二分          │ 分割数组最大值             │
 * │ 旋转数组               │ 二分变体          │ 搜索旋转数组               │
 * │                        │                    │                           │
 * │ 【回溯】                │                    │                           │
 * │ 所有可能/所有方案       │ 回溯             │ 全排列、子集               │
 * │ 排列（顺序有关）        │ used 数组        │ 全排列                    │
 * │ 组合/子集              │ start 参数       │ 组合、子集                 │
 * │                        │                    │                           │
 * │ 【动态规划】            │                    │                           │
 * │ 最长/最短/最大/最小     │ DP               │ LIS、最大子数组和           │
 * │ 多少种方法/方案数       │ DP               │ 爬楼梯、零钱兑换II         │
 * │ 是否可能/能否达到       │ DP / BFS         │ 单词拆分、分割等和          │
 * │ 选或不选/容量限制       │ 背包 DP          │ 0-1背包、完全背包           │
 * │                        │                    │                           │
 * │ 【图论】                │                    │                           │
 * │ 连通性/岛屿             │ DFS/BFS/并查集    │ 岛屿数量                   │
 * │ 依赖关系/顺序          │ 拓扑排序          │ 课程表                    │
 * │ 最短路径               │ BFS / Dijkstra   │ 单词接龙                   │
 * │                        │                    │                           │
 * │ 【其他】                │                    │                           │
 * │ 第 K 大/小             │ 堆 / 快速选择     │ 数组中第K大元素             │
 * │ 前缀匹配/自动补全       │ 字典树           │ 实现Trie                  │
 * │ 位操作/状态压缩         │ 位运算           │ 只出现一次的数字            │
 * │                        │                    │                           │
 * └────────────────────────┴────────────────────┴───────────────────────────┘
 */

// ============================================================
// 3. 问题归约思维
// ============================================================

/**
 * 【什么是问题归约】
 *
 * 归约 = 把新问题变形为熟悉的问题
 *
 * 不是「我做过这道题」
 * 而是「我能把这道题变形为我见过的那类问题」
 *
 * 【归约思维训练】
 *
 * ┌─────────────────────────────────────────────────────────────┐
 * │                                                             │
 * │  新题目                    归约过程                最终模型  │
 * │  ───────                   ────────                ────────  │
 * │                                                             │
 * │  分割等和子集       →    能否选出和为sum/2   →    0-1背包    │
 * │                          的子集                             │
 * │                                                             │
 * │  零钱兑换          →    凑出目标金额的       →    完全背包    │
 * │                          最少硬币数                         │
 * │                                                             │
 * │  课程表            →    有依赖关系的顺序     →    拓扑排序    │
 * │                                                             │
 * │  岛屿数量          →    统计连通区域数       →    DFS/并查集  │
 * │                                                             │
 * │  接雨水            →    每个位置能接多少     →    单调栈/双指针│
 * │                                                             │
 * │  单词接龙          →    最短转换序列         →    BFS        │
 * │                                                             │
 * └─────────────────────────────────────────────────────────────┘
 *
 * 【归约的步骤】
 *
 * Step 1: 识别问题的本质
 *         - 忽略题目的"包装"，看实际要解决什么
 *
 * Step 2: 联想已知模型
 *         - 这像不像某类经典问题？
 *         - 输入输出结构类似什么？
 *
 * Step 3: 验证归约是否正确
 *         - 约束条件是否匹配？
 *         - 能否直接套用模板？
 */

// ============================================================
// 4. 变形题识别
// ============================================================

/**
 * 【常见的变形模式】
 *
 * 模式一：增加维度
 * ┌─────────────────────────────────────────────────────────────┐
 * │ 一维 → 二维                                                 │
 * │ 两数之和 → 三数之和 → 四数之和                               │
 * │ 最大子数组和 → 最大矩形/正方形                               │
 * └─────────────────────────────────────────────────────────────┘
 *
 * 模式二：增加约束
 * ┌─────────────────────────────────────────────────────────────┐
 * │ 无约束 → 有约束                                             │
 * │ 子集 → 子集 II（有重复元素）                                │
 * │ 买卖股票 → 买卖股票含冷冻期/手续费                           │
 * │ 爬楼梯 → 使用最小花费爬楼梯                                  │
 * └─────────────────────────────────────────────────────────────┘
 *
 * 模式三：改变目标
 * ┌─────────────────────────────────────────────────────────────┐
 * │ 求最优 → 求方案数 → 求所有方案                               │
 * │ 零钱兑换（最少硬币）→ 零钱兑换II（方案数）                   │
 * │ 最长递增子序列（长度）→ 输出具体子序列                       │
 * └─────────────────────────────────────────────────────────────┘
 *
 * 模式四：特殊结构
 * ┌─────────────────────────────────────────────────────────────┐
 * │ 线性 → 环形                                                 │
 * │ 打家劫舍 → 打家劫舍 II（环形）                               │
 * │ 数组 → 树                                                   │
 * │ 打家劫舍 → 打家劫舍 III（树形）                              │
 * └─────────────────────────────────────────────────────────────┘
 *
 * 【识别变形题的关键】
 *
 * 1. 问自己：这和什么题很像？
 * 2. 找出区别：多了什么约束？少了什么条件？
 * 3. 调整模板：针对区别修改标准解法
 */

// ============================================================
// 5. 算法选择决策树
// ============================================================

/**
 * 🔄 算法选择决策树 (Mermaid):
 *
 * ```mermaid
 * flowchart TD
 *     A[拿到新题] --> B{数据结构?}
 *
 *     B -->|数组/字符串| C{问题类型?}
 *     C -->|连续子区间| C1[滑动窗口]
 *     C -->|有序+查找| C2[二分/双指针]
 *     C -->|最优解| C3[DP/贪心]
 *     C -->|所有方案| C4[回溯]
 *
 *     B -->|链表| D{操作类型?}
 *     D -->|反转| D1[迭代/递归]
 *     D -->|环/中点| D2[快慢指针]
 *     D -->|合并| D3[归并]
 *
 *     B -->|树| E{遍历需求?}
 *     E -->|路径/深度| E1[DFS]
 *     E -->|层序| E2[BFS]
 *     E -->|搜索树| E3[中序]
 *
 *     B -->|图| F{问题类型?}
 *     F -->|连通性| F1[DFS/并查集]
 *     F -->|最短路| F2[BFS/Dijkstra]
 *     F -->|依赖顺序| F3[拓扑排序]
 *
 *     B -->|最优解问题| G{能否贪心?}
 *     G -->|局部最优=全局最优| G1[贪心]
 *     G -->|需要全局考虑| G2[DP]
 *
 *     B -->|Top K| H[堆/快速选择]
 * ```
 */

/**
 * 【简化版决策流程】
 *
 * 问题一：需要"所有可能的解"吗？
 *         → 是 → 回溯
 *
 * 问题二：有"最优子结构"吗？（大问题的最优解包含小问题的最优解）
 *         → 是 → DP 或 贪心
 *
 * 问题三：是"搜索/遍历"问题吗？
 *         → 是 → BFS / DFS
 *
 * 问题四：可以"排序"后简化吗？
 *         → 是 → 排序 + 双指针/二分/贪心
 *
 * 问题五：需要"快速查找"吗？
 *         → 是 → 哈希表 / 二分 / 字典树
 */

// ============================================================
// 6. 实战演练：问题归约示例
// ============================================================

/**
 * 【示例一：分割等和子集】
 *
 * 题目：给定一个只包含正整数的非空数组，判断是否可以分割成两个子集，
 *       使得两个子集的元素和相等。
 *
 * 归约过程：
 * 1. 两个子集和相等 → 每个子集和 = sum / 2
 * 2. sum 必须是偶数
 * 3. 问题变成：能否从数组中选出若干元素，使得和恰好等于 sum / 2
 * 4. 这就是 0-1 背包问题！
 *
 * 归约结果：0-1 背包，target = sum / 2，求是否可达
 */

/**
 * 【示例二：课程表】
 *
 * 题目：有 n 门课程，有些课有先修课要求。判断是否可能完成所有课程。
 *
 * 归约过程：
 * 1. 先修关系 = 有向边
 * 2. 课程 = 节点
 * 3. 能否完成所有课程 = 有向图是否存在拓扑排序 = 有向图是否无环
 *
 * 归约结果：拓扑排序，判断 DAG
 */

/**
 * 【示例三：接雨水】
 *
 * 题目：给定 n 个非负整数表示柱子高度，计算能接多少雨水。
 *
 * 归约过程：
 * 1. 每个位置能接的水 = min(左边最高, 右边最高) - 当前高度
 * 2. 方法一：预处理左右最高 → O(n) 空间
 * 3. 方法二：双指针 → O(1) 空间
 * 4. 方法三：单调栈 → 按"水坑"计算
 *
 * 归约结果：双指针 / 单调栈
 */

// ============================================================
// 7. 问题建模练习题
// ============================================================

/**
 * 尝试对以下题目进行归约，想想它们的本质是什么：
 *
 * 练习 1：目标和
 * - 题意：给数组每个数添加 + 或 -，使得和等于 target
 * - 归约：？
 * - 答案：0-1 背包（选择一组数使得 sum = (target + total) / 2）
 *
 * 练习 2：单词接龙
 * - 题意：从 beginWord 变换到 endWord，每次只能改一个字母
 * - 归约：？
 * - 答案：图的最短路径 → BFS
 *
 * 练习 3：完全平方数
 * - 题意：找到若干个完全平方数，使得它们的和等于 n，求最少个数
 * - 归约：？
 * - 答案：完全背包 / BFS
 *
 * 练习 4：下一个更大元素
 * - 题意：对于数组中每个元素，找到右边第一个比它大的
 * - 归约：？
 * - 答案：单调栈
 *
 * 练习 5：最小覆盖子串
 * - 题意：找到包含目标字符串所有字符的最小子串
 * - 归约：？
 * - 答案：滑动窗口 + 哈希表
 */

// ============================================================
// 8. 建立问题模型库
// ============================================================

/**
 * 建议建立自己的"问题模型库"，按以下结构整理：
 *
 * ┌─────────────────────────────────────────────────────────────┐
 * │                      问题模型库结构                         │
 * ├─────────────────────────────────────────────────────────────┤
 * │                                                             │
 * │  模型名称：0-1 背包                                          │
 * │  ─────────────────                                          │
 * │  问题特征：从 n 个物品中选若干个，有容量限制，每个只能选一次  │
 * │  状态定义：dp[i][j] = 前 i 个物品，容量 j 的最优值           │
 * │  转移方程：dp[i][j] = max(不选, 选)                         │
 * │  典型题目：分割等和子集、目标和、一和零                      │
 * │  变形：完全背包（可重复选）、多重背包（有数量限制）           │
 * │                                                             │
 * │  模型名称：滑动窗口                                          │
 * │  ─────────────────                                          │
 * │  问题特征：连续子数组/子串，满足某种条件的最长/最短           │
 * │  模板：while (right < n) { 扩大窗口; 满足条件时收缩 }        │
 * │  典型题目：无重复最长子串、最小覆盖子串、长度最小的子数组     │
 * │  变形：固定窗口大小、多指针                                  │
 * │                                                             │
 * │  ...                                                        │
 * │                                                             │
 * └─────────────────────────────────────────────────────────────┘
 */

export {};

