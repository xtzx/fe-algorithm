/**
 * ============================================================
 * 📚 解题方法论 - 从暴力到优化的系统方法
 * ============================================================
 *
 * 本文件覆盖：
 * 1. 通用解题框架
 * 2. 从暴力到优化的思路
 * 3. 边界情况清单
 * 4. 调试技巧
 * 5. 代码风格建议
 */

// ============================================================
// 1. 通用解题框架
// ============================================================

/**
 * 【五步解题法】
 *
 * ┌─────────────────────────────────────────────────────────────┐
 * │                                                             │
 * │  Step 1: 理解题意 (2-3 分钟)                                │
 * │  ─────────────────────────                                  │
 * │  • 复述题目，确保理解正确                                    │
 * │  • 确认输入输出格式                                          │
 * │  • 问清楚边界情况（空数组？负数？）                           │
 * │  • 看数据规模，估计可接受的复杂度                            │
 * │                                                             │
 * │  Step 2: 想暴力解法 (2-3 分钟)                               │
 * │  ─────────────────────────                                  │
 * │  • 不管效率，先想出一个能解决问题的方法                       │
 * │  • 说出暴力解法的复杂度                                      │
 * │  • 面试官可能就满意了                                        │
 * │                                                             │
 * │  Step 3: 寻找优化 (3-5 分钟)                                 │
 * │  ─────────────────────────                                  │
 * │  • 暴力解法哪里可以优化？                                    │
 * │  • 有没有重复计算？→ 记忆化/DP                               │
 * │  • 有没有无效搜索？→ 剪枝                                    │
 * │  • 能不能用更好的数据结构？→ 哈希表/堆                       │
 * │                                                             │
 * │  Step 4: 编写代码 (10-15 分钟)                               │
 * │  ─────────────────────────                                  │
 * │  • 先写框架，再填细节                                        │
 * │  • 边写边解释思路                                            │
 * │  • 注意变量命名和代码风格                                    │
 * │                                                             │
 * │  Step 5: 测试验证 (3-5 分钟)                                 │
 * │  ─────────────────────────                                  │
 * │  • 用简单例子走一遍                                          │
 * │  • 检查边界情况                                              │
 * │  • 分析复杂度，确认符合要求                                  │
 * │                                                             │
 * └─────────────────────────────────────────────────────────────┘
 */

// ============================================================
// 2. 从暴力到优化的思路
// ============================================================

/**
 * 【优化思路清单】
 *
 * 当暴力解法太慢时，按以下顺序思考优化：
 *
 * ┌─────────────────────────────────────────────────────────────┐
 * │                                                             │
 * │  1. 能排序吗？                                               │
 * │     → 排序后可以用双指针、二分                               │
 * │     → 例：三数之和、合并区间                                 │
 * │                                                             │
 * │  2. 能用哈希表吗？                                           │
 * │     → O(n) 查找变 O(1)                                      │
 * │     → 例：两数之和、和为K的子数组                            │
 * │                                                             │
 * │  3. 有重复计算吗？                                           │
 * │     → 记忆化 / DP                                           │
 * │     → 例：斐波那契、背包问题                                 │
 * │                                                             │
 * │  4. 能用更好的数据结构吗？                                   │
 * │     → 堆：动态维护极值                                      │
 * │     → 单调栈/队列：维护单调性                               │
 * │     → 字典树：前缀查找                                      │
 * │                                                             │
 * │  5. 能双指针吗？                                             │
 * │     → 对撞指针：有序数组两端                                 │
 * │     → 快慢指针：链表、原地修改                               │
 * │     → 滑动窗口：连续子区间                                   │
 * │                                                             │
 * │  6. 能二分吗？                                               │
 * │     → 答案的范围是单调的                                    │
 * │     → 例：分割数组最大值                                    │
 * │                                                             │
 * │  7. 能贪心吗？                                               │
 * │     → 局部最优 = 全局最优                                   │
 * │     → 例：跳跃游戏、区间调度                                │
 * │                                                             │
 * └─────────────────────────────────────────────────────────────┘
 *
 * 【复杂度优化路径】
 *
 * O(n²) → O(n log n)：排序 + 双指针，或排序 + 二分
 * O(n²) → O(n)：哈希表、双指针、滑动窗口
 * O(2^n) → O(n×target)：记忆化 / DP（背包）
 * O(n log n) → O(n)：线性时间算法（计数排序、桶排序）
 */

// ============================================================
// 3. 边界情况清单
// ============================================================

/**
 * 【通用边界情况】
 *
 * ┌─────────────────────────────────────────────────────────────┐
 * │                                                             │
 * │  数组/字符串：                                               │
 * │  • 空数组/空字符串                                           │
 * │  • 只有一个元素                                              │
 * │  • 所有元素相同                                              │
 * │  • 有重复元素                                                │
 * │  • 负数、零                                                  │
 * │  • 极大值（溢出）                                            │
 * │                                                             │
 * │  链表：                                                      │
 * │  • 空链表                                                    │
 * │  • 只有一个节点                                              │
 * │  • 两个节点                                                  │
 * │  • 有环                                                      │
 * │                                                             │
 * │  树：                                                        │
 * │  • 空树                                                      │
 * │  • 只有根节点                                                │
 * │  • 只有左子树 / 只有右子树（退化成链表）                     │
 * │                                                             │
 * │  数值：                                                      │
 * │  • 0                                                        │
 * │  • 负数                                                      │
 * │  • 最大/最小整数                                             │
 * │  • 溢出                                                      │
 * │                                                             │
 * └─────────────────────────────────────────────────────────────┘
 *
 * 【特定算法的边界】
 *
 * 二分查找：
 * • 空数组
 * • 目标在最左/最右
 * • 目标不存在
 * • 所有元素相同
 *
 * 双指针：
 * • 两指针相遇的处理
 * • 边界溢出
 *
 * 滑动窗口：
 * • 窗口大小 > 数组长度
 * • 窗口大小为 0 或 1
 *
 * DP：
 * • 初始状态是否正确
 * • 下标是否越界
 * • dp[0] 的特殊处理
 *
 * 递归：
 * • 终止条件是否完备
 * • 是否会栈溢出
 */

// ============================================================
// 4. 调试技巧
// ============================================================

/**
 * 【调试三板斧】
 *
 * 1. 打印中间状态
 *    console.log(arr, left, right, result);
 *
 * 2. 用最小用例手算
 *    n = 3 的情况先手算一遍，对比代码输出
 *
 * 3. 检查边界条件
 *    把边界情况单独拿出来测试
 *
 * 【常见 Bug 类型】
 *
 * ┌─────────────────────────────────────────────────────────────┐
 * │                                                             │
 * │  类型一：下标越界                                            │
 * │  ─────────────────                                          │
 * │  • i-1 或 i+1 是否合法？                                    │
 * │  • 循环条件是 < 还是 <=？                                   │
 * │  • 数组长度是 n 还是 n+1？                                  │
 * │                                                             │
 * │  类型二：循环不终止                                          │
 * │  ─────────────────                                          │
 * │  • 循环变量是否正确更新？                                    │
 * │  • while 循环的退出条件？                                   │
 * │  • 二分的 left = mid + 1 还是 left = mid？                 │
 * │                                                             │
 * │  类型三：初始化错误                                          │
 * │  ─────────────────                                          │
 * │  • 最大值问题：初始化为 -Infinity                           │
 * │  • 最小值问题：初始化为 Infinity                            │
 * │  • 计数问题：初始化为 0 还是 1？                            │
 * │                                                             │
 * │  类型四：返回值错误                                          │
 * │  ─────────────────                                          │
 * │  • 返回的是下标还是值？                                      │
 * │  • 无解时返回什么？-1？空数组？                              │
 * │  • "以 i 结尾"的问题要返回 max(dp)                          │
 * │                                                             │
 * │  类型五：引用问题（JavaScript）                              │
 * │  ─────────────────                                          │
 * │  • result.push([...path])，不是 push(path)                 │
 * │  • 需要深拷贝还是浅拷贝？                                    │
 * │                                                             │
 * └─────────────────────────────────────────────────────────────┘
 */

// ============================================================
// 5. 代码风格建议
// ============================================================

/**
 * 【命名规范】
 *
 * 好的命名：
 * • left, right, mid（双指针/二分）
 * • slow, fast（快慢指针）
 * • start, end（区间）
 * • prev, curr, next（链表）
 * • dp[i], dp[i][j]（动态规划）
 *
 * 避免：
 * • a, b, c, x, y
 * • temp1, temp2（除非真的只是临时变量）
 *
 * 【代码结构】
 *
 * 1. 先处理边界情况
 * 2. 初始化变量
 * 3. 主逻辑
 * 4. 返回结果
 *
 * 【示例：良好的代码结构】
 */

function goodCodeExample(nums: number[], target: number): number {
  // 1. 边界处理
  if (nums.length === 0) return -1;

  // 2. 初始化
  let left = 0;
  let right = nums.length - 1;

  // 3. 主逻辑
  while (left <= right) {
    const mid = left + Math.floor((right - left) / 2);

    if (nums[mid] === target) {
      return mid;
    } else if (nums[mid] < target) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }

  // 4. 返回结果
  return -1;
}

/**
 * 【注释建议】
 *
 * 关键位置加注释：
 * • 复杂的条件判断
 * • 不直观的操作
 * • 为什么要这么做
 *
 * 不需要的注释：
 * • i++; // i 加 1（废话）
 * • 显而易见的代码
 */

// ============================================================
// 6. 复杂度分析模板
// ============================================================

/**
 * 【分析复杂度的标准表达】
 *
 * 面试时这样说：
 *
 * "时间复杂度是 O(n)，因为我们遍历了一次数组。"
 *
 * "空间复杂度是 O(n)，因为我们使用了一个哈希表来存储元素。"
 *
 * "如果考虑递归栈的话，空间复杂度是 O(log n)。"
 *
 * 【常见表达模板】
 *
 * ┌─────────────────────────────────────────────────────────────┐
 * │                                                             │
 * │  "时间复杂度是 O(n log n)，主要来自排序。"                   │
 * │                                                             │
 * │  "时间复杂度是 O(n)，每个元素最多被访问两次。"               │
 * │                                                             │
 * │  "空间复杂度是 O(1)，只使用了常数个变量。"                   │
 * │                                                             │
 * │  "空间复杂度是 O(n)，最坏情况下栈的深度是 n。"               │
 * │                                                             │
 * │  "如果要优化的话，可以用 X 方法将时间复杂度降到 O(n)。"      │
 * │                                                             │
 * └─────────────────────────────────────────────────────────────┘
 */

// ============================================================
// 7. 解题检查清单
// ============================================================

/**
 * 写完代码后，检查以下几点：
 *
 * ┌─────────────────────────────────────────────────────────────┐
 * │                      解题检查清单                            │
 * ├─────────────────────────────────────────────────────────────┤
 * │                                                             │
 * │  ☐ 边界情况处理了吗？（空、单元素、极值）                    │
 * │  ☐ 循环条件正确吗？（< 还是 <=）                            │
 * │  ☐ 下标会越界吗？（i-1, i+1）                               │
 * │  ☐ 初始化正确吗？（最大取 -∞，最小取 ∞）                    │
 * │  ☐ 返回值正确吗？（下标还是值，无解返回什么）                │
 * │  ☐ 变量更新正确吗？（循环变量、指针移动）                    │
 * │  ☐ 需要拷贝吗？（[...arr] vs arr）                         │
 * │  ☐ 时间复杂度符合要求吗？                                    │
 * │  ☐ 有没有更优的解法？（可以提一下）                          │
 * │                                                             │
 * └─────────────────────────────────────────────────────────────┘
 */

export { goodCodeExample };

