/**
 * 📝 题目：寻找峰值
 * 🔗 链接：https://leetcode.cn/problems/find-peak-element/
 * 🏷️ 难度：Medium
 * 🏷️ 标签：数组、二分查找
 *
 * 📋 题目描述：
 * 峰值元素是指其值严格大于左右相邻值的元素。
 *
 * 给你一个整数数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，
 * 在这种情况下，返回 任何一个峰值 所在位置即可。
 *
 * 你可以假设 nums[-1] = nums[n] = -∞。
 *
 * 你必须实现时间复杂度为 O(log n) 的算法来解决此问题。
 *
 * 示例：
 * 输入：nums = [1,2,3,1]
 * 输出：2
 * 解释：3 是峰值元素，你的函数应该返回其索引 2
 *
 * 输入：nums = [1,2,1,3,5,6,4]
 * 输出：5
 * 解释：你的函数可以返回索引 1（峰值元素为 2）或索引 5（峰值元素为 6）
 */

// ============================================================
// 💡 思路分析：这道题的解法是怎么想出来的？
// ============================================================
//
// 关键洞察：题目保证 nums[-1] = nums[n] = -∞
// 这意味着：
// - 数组一定存在至少一个峰值
// - 如果往上坡走，一定能走到峰值
//
// 二分策略：
// - 如果 nums[mid] < nums[mid+1]，峰值在右边
// - 如果 nums[mid] > nums[mid+1]，峰值在左边（包括 mid）
//
// 为什么这样能保证找到峰值？
// - 往"上坡"方向走，最终一定能到达峰值

// ============================================================
// 解法：二分查找
// ============================================================
// ⏱️ 时间复杂度：O(log n) | 空间复杂度：O(1)

/**
 * 📊 执行过程图解：
 *
 * nums = [1, 2, 1, 3, 5, 6, 4]
 *         0  1  2  3  4  5  6
 *
 * 可视化：
 *           6
 *        5
 *     3
 *  2     4
 * 1  1
 *
 * 初始: left=0, right=6
 *
 * Step 1: mid = 3
 *         nums[3]=3 < nums[4]=5
 *         往右是上坡，峰值在右边
 *         left = 4
 *
 * Step 2: mid = 5
 *         nums[5]=6 > nums[6]=4
 *         往右是下坡，峰值在左边（包括 mid）
 *         right = 5
 *
 * Step 3: mid = 4
 *         nums[4]=5 < nums[5]=6
 *         left = 5
 *
 * left == right == 5
 * 返回 5
 */
function findPeakElement(nums: number[]): number {
  let left = 0;
  let right = nums.length - 1;

  while (left < right) {
    const mid = left + ((right - left) >> 1);

    if (nums[mid] < nums[mid + 1]) {
      // 往右是上坡，峰值在右边
      left = mid + 1;
    } else {
      // 往右是下坡，峰值在左边（包括 mid）
      right = mid;
    }
  }

  return left;
}

// ============================================================
// ⚠️ 易错点
// ============================================================
/**
 * 1. 比较的是 nums[mid] 和 nums[mid+1]：
 *    - 不是和 nums[left] 或 nums[right]
 *    - 这是判断"上坡"还是"下坡"
 *
 * 2. right = mid，不是 mid - 1：
 *    - 因为 mid 可能就是峰值
 *
 * 3. 循环条件 left < right：
 *    - 最终 left == right 就是峰值位置
 *
 * 4. mid+1 不会越界：
 *    - 因为 left < right，所以 mid < right
 *    - 所以 mid+1 <= right < n
 */

// ============================================================
// 🔗 举一反三：相似题目
// ============================================================
/**
 * - 山脉数组中查找目标值 → 先找峰值，再两边二分
 * - 山脉数组的峰顶索引 → 简化版
 */

// ============================================================
// 🏢 前端业务场景
// ============================================================
/**
 * 1. 音量曲线：找最大音量点
 * 2. 性能曲线：找性能峰值
 * 3. 股票图表：找局部最高点
 */

export { findPeakElement };
export default findPeakElement;

