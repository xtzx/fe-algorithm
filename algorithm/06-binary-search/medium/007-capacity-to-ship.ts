/**
 * 📝 题目：在 D 天内送达包裹的能力
 * 🔗 链接：https://leetcode.cn/problems/capacity-to-ship-packages-within-d-days/
 * 🏷️ 难度：Medium
 * 🏷️ 标签：数组、二分查找
 *
 * 📋 题目描述：
 * 传送带上的包裹必须在 days 天内从一个港口运送到另一个港口。
 * 传送带上的第 i 个包裹的重量为 weights[i]。
 * 每一天，我们都会按给出重量的顺序往传送带上装载包裹。
 * 我们装载的重量不会超过船的最大运载能力。
 *
 * 返回能在 days 天内将所有包裹送达的船的最低运载能力。
 *
 * 示例：
 * 输入：weights = [1,2,3,4,5,6,7,8,9,10], days = 5
 * 输出：15
 * 解释：
 * 船舶最低载重 15 就能够在 5 天内送达所有包裹，如下所示：
 * 第 1 天：1, 2, 3, 4, 5
 * 第 2 天：6, 7
 * 第 3 天：8
 * 第 4 天：9
 * 第 5 天：10
 */

// ============================================================
// 💡 思路分析
// ============================================================
//
// 这是典型的"答案二分"题目！
//
// 信号词：最低运载能力 → 最小化
// 单调性：运载能力越大，需要的天数越少
//
// 思路：
// 1. 确定答案空间 [max(weights), sum(weights)]
// 2. 二分查找最小的可行运载能力
// 3. check(cap): 运载能力为 cap 时，能否在 days 天内完成

// ============================================================
// 解法一：答案二分（推荐）
// ============================================================
// ⏱️ 时间复杂度：O(n × log(sum)) | 空间复杂度：O(1)

/**
 * 📊 答案二分图解：
 *
 * weights = [1,2,3,4,5,6,7,8,9,10], days = 5
 *
 * 答案空间：[10, 55]
 * - 最小：最重的包裹（10），否则装不下
 * - 最大：所有包裹（55），一天全运完
 *
 * 二分过程：
 * mid = 32: 可以，尝试更小
 * mid = 21: 可以，尝试更小
 * mid = 15: 可以，尝试更小
 * mid = 12: 不行，需要更大
 * mid = 13: 不行
 * mid = 14: 不行
 * mid = 15: 最终答案
 *
 * check(15) 模拟：
 * 第 1 天：1+2+3+4+5 = 15 ✓
 * 第 2 天：6+7 = 13 ✓
 * 第 3 天：8 = 8 ✓
 * 第 4 天：9 = 9 ✓
 * 第 5 天：10 = 10 ✓
 * 需要 5 天 <= days，可行！
 */
function shipWithinDays(weights: number[], days: number): number {
  // 确定答案空间
  let left = Math.max(...weights); // 至少能装下最重的包裹
  let right = weights.reduce((a, b) => a + b, 0); // 一天全运完

  // 二分查找最小可行的运载能力
  while (left < right) {
    const mid = (left + right) >> 1;
    if (canShip(weights, days, mid)) {
      right = mid; // mid 可行，尝试更小
    } else {
      left = mid + 1; // mid 不可行，需要更大
    }
  }

  return left;
}

/**
 * 验证函数：运载能力为 cap 时，能否在 days 天内完成
 */
function canShip(weights: number[], days: number, cap: number): boolean {
  let daysNeeded = 1;
  let currentLoad = 0;

  for (const weight of weights) {
    // 当前包裹装不下，换新的一天
    if (currentLoad + weight > cap) {
      daysNeeded++;
      currentLoad = weight;
    } else {
      currentLoad += weight;
    }
  }

  return daysNeeded <= days;
}

// ============================================================
// 🔄 答案二分模板总结
// ============================================================
/**
 * 答案二分三步骤：
 *
 * 1. 确定答案空间 [left, right]
 *    - left: 可能的最小答案
 *    - right: 可能的最大答案
 *
 * 2. 写 check(x) 验证函数
 *    - 判断答案为 x 时是否可行
 *    - 通常用贪心策略
 *
 * 3. 二分查找
 *    - 可行则尝试更小/更大
 *    - 不可行则往反方向
 *
 * 时间复杂度：O(log(range) × check)
 */

// ============================================================
// ⚠️ 易错点
// ============================================================
/**
 * 1. 答案空间边界：
 *    - left 至少是 max(weights)，否则装不下某个包裹
 *    - 不是 0 或 1
 *
 * 2. check 函数的贪心策略：
 *    - 尽量装满当天的船
 *    - 装不下就换天
 *
 * 3. 天数计数：
 *    - 从 1 开始，不是从 0
 *    - 或者从 0 开始，用 < days 判断
 */

// ============================================================
// 🔗 举一反三：相似题目
// ============================================================
/**
 * 答案二分系列：
 *
 * - 爱吃香蕉的珂珂
 *   空间：[1, max(piles)]
 *   check：以速度 k 能否在 h 小时内吃完
 *
 * - 分割数组的最大值
 *   空间：[max(nums), sum(nums)]
 *   check：子数组最大和不超过 x 能否分成 m 份
 *
 * - 在 D 天内送达包裹（本题）
 *   空间：[max(weights), sum(weights)]
 *   check：运载能力 x 能否在 D 天内送完
 *
 * 共同模式：
 * 1. 问最小化/最大化某个值
 * 2. 答案具有单调性
 * 3. 给定答案可以验证可行性
 */

// ============================================================
// 🏢 前端业务场景
// ============================================================
/**
 * 类似场景：
 *
 * 1. CDN 分发优化：
 *    - 将资源分配到不同服务器
 *    - 最小化单服务器最大负载
 *
 * 2. 并行任务调度：
 *    - 将任务分配给 n 个 worker
 *    - 最小化完成时间
 *
 * 3. 分页加载优化：
 *    - 将内容分成 n 页
 *    - 最小化单页最大加载量
 */

export { shipWithinDays, canShip };
export default shipWithinDays;

