/**
 * 📝 题目：分割数组的最大值
 * 🔗 链接：https://leetcode.cn/problems/split-array-largest-sum/
 * 🏷️ 难度：Hard
 * 🏷️ 标签：数组、二分查找、动态规划、贪心
 *
 * 📋 题目描述：
 * 给定一个非负整数数组 nums 和一个整数 k，你需要将这个数组分成 k 个非空的连续子数组。
 *
 * 设计一个算法使得这 k 个子数组各自和的最大值最小。
 *
 * 示例：
 * 输入：nums = [7,2,5,10,8], k = 2
 * 输出：18
 * 解释：
 * 一共有四种方法将 nums 分割为 2 个子数组。
 * 其中最好的方式是将其分为 [7,2,5] 和 [10,8]。
 * 因为此时这两个子数组各自的和的最大值为 18，在所有情况中最小。
 */

// ============================================================
// 💡 思路分析：这道题的解法是怎么想出来的？
// ============================================================
//
// "最大值最小" → 典型的答案二分！
//
// 问题转化：
// - 如果子数组和的最大值不超过 x，最少需要几个子数组？
// - 找最小的 x，使得分成 k 个子数组时每个子数组和都 <= x
//
// 二分的单调性：
// - x 越大，需要的子数组越少
// - x 越小，需要的子数组越多
//
// 搜索空间：
// - 最小值：max(nums)（至少要能装下最大元素）
// - 最大值：sum(nums)（所有元素放一个子数组）

// ============================================================
// 解法：答案二分
// ============================================================
// ⏱️ 时间复杂度：O(n log(sum)) | 空间复杂度：O(1)

/**
 * 📊 执行过程图解：
 *
 * nums = [7, 2, 5, 10, 8], k = 2
 *
 * 搜索空间: [max(nums)=10, sum(nums)=32]
 *
 * 验证函数：子数组和不超过 x 时，最少需要几个子数组
 *
 * x=10: [7,2] [5] [10] [8] → 需要 4 个 > 2 ✗
 * x=18: [7,2,5] [10,8] → 需要 2 个 <= 2 ✓
 * x=14: [7,2,5] [10] [8] → 需要 3 个 > 2 ✗
 * x=15: [7,2,5] [10] [8] → 需要 3 个 > 2 ✗
 * x=17: [7,2,5] [10] [8] → 需要 3 个 > 2 ✗
 * x=18: [7,2,5] [10,8] → 需要 2 个 <= 2 ✓ → 找到！
 *
 * ```mermaid
 * flowchart TD
 *     A[left = max, right = sum] --> B{left < right?}
 *     B -->|Yes| C[mid = left + right / 2]
 *     C --> D[count = canSplit nums, k, mid]
 *     D --> E{count <= k?}
 *     E -->|Yes| F[right = mid]
 *     E -->|No| G[left = mid + 1]
 *     F --> B
 *     G --> B
 *     B -->|No| H[返回 left]
 * ```
 */
function splitArray(nums: number[], k: number): number {
  let left = Math.max(...nums); // 最小可能的最大和
  let right = nums.reduce((a, b) => a + b, 0); // 最大可能的最大和

  while (left < right) {
    const mid = left + Math.floor((right - left) / 2);
    const count = getMinSplits(nums, mid);

    if (count <= k) {
      // mid 作为最大和时，可以分成 <= k 组
      // 尝试更小的最大和
      right = mid;
    } else {
      // mid 太小，需要分更多组
      // 需要更大的最大和
      left = mid + 1;
    }
  }

  return left;
}

// 当子数组和不超过 maxSum 时，最少需要几个子数组
function getMinSplits(nums: number[], maxSum: number): number {
  let count = 1;
  let currentSum = 0;

  for (const num of nums) {
    if (currentSum + num > maxSum) {
      // 当前子数组放不下了，开新的一组
      count++;
      currentSum = num;
    } else {
      currentSum += num;
    }
  }

  return count;
}

// ============================================================
// 解法二：动态规划
// ============================================================
// ⏱️ 时间复杂度：O(n² × k) | 空间复杂度：O(n × k)

/**
 * dp[i][j] = 将前 i 个数分成 j 组，各组和的最大值的最小值
 */
function splitArray_dp(nums: number[], k: number): number {
  const n = nums.length;

  // 前缀和
  const prefixSum = [0];
  for (const num of nums) {
    prefixSum.push(prefixSum[prefixSum.length - 1] + num);
  }

  // dp[i][j] = 前 i 个数分成 j 组的最小最大和
  const dp: number[][] = Array.from({ length: n + 1 }, () =>
    Array(k + 1).fill(Infinity)
  );

  dp[0][0] = 0;

  for (let i = 1; i <= n; i++) {
    for (let j = 1; j <= Math.min(i, k); j++) {
      // 尝试最后一组是 [m+1, i]
      for (let m = j - 1; m < i; m++) {
        const lastGroupSum = prefixSum[i] - prefixSum[m];
        dp[i][j] = Math.min(dp[i][j], Math.max(dp[m][j - 1], lastGroupSum));
      }
    }
  }

  return dp[n][k];
}

// ============================================================
// 🔄 解法对比
// ============================================================
/**
 * | 解法       | 时间         | 空间    | 特点                |
 * |-----------|--------------|---------|---------------------|
 * | 答案二分   | O(n log sum) | O(1)    | 推荐，效率最高       |
 * | 动态规划   | O(n² × k)    | O(n × k)| 直观但效率较低       |
 */

// ============================================================
// ⚠️ 易错点
// ============================================================
/**
 * 1. 搜索空间的确定：
 *    - 最小值是 max(nums)，不是 0
 *    - 因为至少要能装下最大的元素
 *
 * 2. 贪心策略的正确性：
 *    - 尽量往当前组塞，塞不下就开新组
 *    - 这样得到的是最少分组数
 *
 * 3. 二分条件：
 *    - count <= k 时，right = mid（mid 可行，尝试更小）
 *    - 不是 count == k
 */

// ============================================================
// 🔗 举一反三：相似题目
// ============================================================
/**
 * - 爱吃香蕉的珂珂 → 同样是答案二分
 * - 在 D 天内送达包裹的能力 → 几乎一样
 * - 制作 m 束花所需的最少天数 → 答案二分
 */

// ============================================================
// 🏢 前端业务场景
// ============================================================
/**
 * 1. 任务分配：将任务分给多个线程，使最大负载最小
 * 2. 分页优化：将内容分页，使最长页面最短
 * 3. 资源调度：将资源分配给多个服务器
 */

export { splitArray, splitArray_dp };
export default splitArray;

