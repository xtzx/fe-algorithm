/**
 * ============================================================
 * 📚 二分查找 - 面试高频问答
 * ============================================================
 *
 * 本文件包含二分查找相关的面试高频问题，每个问题包含：
 * 1. 问题本身
 * 2. 标准答案
 * 3. 加分回答（展示深度理解）
 * 4. 追问方向
 */

// ============================================================
// Q1: 二分查找的本质是什么？
// ============================================================

/**
 * 📝 问题：二分查找的本质是什么？什么时候可以用二分？
 *
 * ✅ 标准答案：
 * 二分查找的本质是：在具有单调性的搜索空间中，通过一次判断排除一半。
 *
 * 使用条件：
 * 1. 搜索空间具有单调性（或二段性）
 * 2. 可以通过判断条件排除一半
 * 3. 有明确的边界条件
 *
 * ⭐ 加分回答：
 * 「二分查找不只是在有序数组中查找元素！
 *
 * 更本质的理解是：
 * - 有一个判断条件，把搜索空间分成两部分
 * - 左边全部满足/不满足，右边全部不满足/满足
 * - 找这个分界点
 *
 *   F  F  F  F  T  T  T  T  T
 *   ← 不满足 → ← 满足 ────→
 *            ↑
 *          分界点
 *
 * 只要满足"二段性"，都可以用二分：
 * - 有序数组找元素（最基础）
 * - 找第一个错误版本（git bisect）
 * - 找能完成任务的最小速度（答案二分）
 * - 旋转数组中搜索（部分有序）
 *
 * 前端常见场景：虚拟列表定位、图表数据点查找、版本二分定位bug。」
 *
 * 🔄 可能的追问：
 * - 什么是答案二分？
 * - 旋转数组怎么二分？
 */

// ============================================================
// Q2: left <= right 和 left < right 有什么区别？
// ============================================================

/**
 * 📝 问题：二分查找中 left <= right 和 left < right 有什么区别？
 *
 * ✅ 标准答案：
 *
 * left <= right：
 * - 搜索区间是 [left, right]（闭区间）
 * - 用于查找确切值
 * - 找到就返回，left > right 时退出
 *
 * left < right：
 * - 搜索区间是 [left, right)（左闭右开）
 * - 用于找边界
 * - 最终 left == right，退出后返回 left
 *
 * ⭐ 加分回答：
 * 「核心区别在于"什么时候停止搜索"。
 *
 * left <= right 适合找确切值：
 * - 每次判断 mid 是不是答案
 * - 是就直接返回
 * - 不是就排除 mid（mid ± 1）
 *
 * left < right 适合找边界：
 * - mid 可能是答案，但不确定
 * - 继续缩小范围直到 left == right
 * - 最后 left（或 right）就是答案
 *
 * 关键记忆：
 * - 找确切值：<= 配合 mid ± 1
 * - 找边界：< 配合 right = mid
 *
 * 易错点：left < right 时不能用 left = mid，否则死循环！
 * 因为 left == right - 1 时，mid = left，如果 left = mid 就永远不变了。」
 *
 * 🔄 可能的追问：
 * - 什么情况下会死循环？
 * - right 初始值为 n 还是 n-1？
 */

// ============================================================
// Q3: 如何避免二分查找的死循环？
// ============================================================

/**
 * 📝 问题：二分查找容易死循环，如何避免？
 *
 * ✅ 标准答案：
 * 死循环的原因是搜索空间没有缩小。
 *
 * 避免方法：
 * 1. left < right 时，避免 left = mid
 * 2. 确保每次迭代至少排除一个元素
 * 3. 使用统一的模板
 *
 * ⭐ 加分回答：
 * 「死循环场景分析：
 *
 * 当 left = right - 1 时：
 * - mid = left + (right - left) / 2 = left
 * - 如果执行 left = mid，那 left 不变！
 *
 * 解决方案：
 * 1. 用 left = mid + 1 而不是 left = mid
 * 2. 或者用 mid = left + (right - left + 1) / 2（向上取整）
 *
 * 我的习惯是使用统一模板：
 *
 * 找边界时：
 * - right = mid（mid 可能是答案）
 * - left = mid + 1（mid 不是答案）
 * - 循环条件 left < right
 *
 * 这样就不会死循环，因为：
 * - right = mid 至少减少 1（因为 right > mid 或 right = mid < 原 right）
 * - left = mid + 1 肯定增加 1
 *
 * 调试技巧：如果不确定，打印 left, right, mid 观察变化。」
 *
 * 🔄 可能的追问：
 * - 什么时候需要向上取整？
 * - 你用什么模板？
 */

// ============================================================
// Q4: 什么是答案二分？
// ============================================================

/**
 * 📝 问题：什么是答案二分？怎么识别和使用？
 *
 * ✅ 标准答案：
 * 答案二分是：不在数组中二分，而是在答案空间中二分。
 *
 * 特点：
 * 1. 问题要求最大化最小或最小化最大
 * 2. 答案具有单调性（越大越容易/越难）
 * 3. 给定一个答案，可以验证是否可行
 *
 * ⭐ 加分回答：
 * 「识别答案二分的信号词：
 * - "最小化最大"
 * - "最大化最小"
 * - "能否完成"
 * - "最少/最多"
 * - "至少/至多"
 *
 * 解题步骤：
 * 1. 确定答案的搜索空间 [min, max]
 * 2. 写一个 check(x) 函数判断 x 是否可行
 * 3. 二分找第一个可行的 x
 *
 * 经典例题：
 *
 * 1. 爱吃香蕉的珂珂：
 *    - 答案空间：[1, max(piles)]
 *    - check(k)：以速度 k 能否在 h 小时内吃完
 *
 * 2. 分割数组的最大值：
 *    - 答案空间：[max(nums), sum(nums)]
 *    - check(maxSum)：子数组最大和不超过 maxSum 能否分成 m 份
 *
 * 3. 在 D 天内送达包裹：
 *    - 答案空间：[max(weights), sum(weights)]
 *    - check(cap)：船容量为 cap 能否在 D 天内送完
 *
 * 这类问题的关键是写好 check 函数，通常是贪心策略。」
 *
 * 🔄 可能的追问：
 * - check 函数怎么写？
 * - 时间复杂度是多少？
 */

// ============================================================
// Q5: 旋转数组怎么二分？
// ============================================================

/**
 * 📝 问题：旋转排序数组怎么用二分查找？
 *
 * ✅ 标准答案：
 * 旋转数组分成两段有序的部分。
 *
 * 关键：判断 mid 在哪一段，然后确定 target 在哪一段。
 *
 * 判断方法：
 * - nums[left] <= nums[mid]：左边有序
 * - nums[mid] <= nums[right]：右边有序
 *
 * ⭐ 加分回答：
 * 「旋转数组的两种题型：
 *
 * 1. 搜索特定值：
 *    - 先判断哪边有序
 *    - 再判断 target 是否在有序那边
 *    - 在就往那边找，不在就往另一边找
 *
 * 2. 找最小值（旋转点）：
 *    - 比较 mid 和 right
 *    - nums[mid] > nums[right]：最小值在右边
 *    - nums[mid] < nums[right]：最小值在左边（包括 mid）
 *
 * 关键代码（搜索特定值）：
 *
 * if (nums[left] <= nums[mid]) {
 *   // 左边有序
 *   if (nums[left] <= target && target < nums[mid]) {
 *     right = mid - 1;  // target 在左边
 *   } else {
 *     left = mid + 1;   // target 在右边
 *   }
 * } else {
 *   // 右边有序
 *   if (nums[mid] < target && target <= nums[right]) {
 *     left = mid + 1;   // target 在右边
 *   } else {
 *     right = mid - 1;  // target 在左边
 *   }
 * }
 *
 * 注意 nums[left] <= nums[mid] 要有等号！
 * 因为 left == mid 时左边只有一个元素，也算有序。」
 *
 * 🔄 可能的追问：
 * - 如果有重复元素怎么办？
 * - 时间复杂度还是 O(log n) 吗？
 */

// ============================================================
// Q6: 左边界和右边界怎么找？
// ============================================================

/**
 * 📝 问题：如何找排序数组中元素的第一个和最后一个位置？
 *
 * ✅ 标准答案：
 * 分别用左边界二分和右边界二分。
 *
 * 左边界（第一个 >= target）：
 * - nums[mid] >= target 时，right = mid
 * - 否则 left = mid + 1
 *
 * 右边界（最后一个 <= target）：
 * - 找第一个 > target 的位置，然后 -1
 *
 * ⭐ 加分回答：
 * 「统一理解：都是找分界点
 *
 * 左边界：找第一个 >= target 的位置
 *   [1, 2, 2, 2, 3, 4]  target = 2
 *       ↑
 *      返回 1
 *
 * 右边界：找最后一个 <= target 的位置
 *   [1, 2, 2, 2, 3, 4]  target = 2
 *             ↑
 *            返回 3
 *
 * 技巧：右边界可以转化为找第一个 > target，然后 -1
 *
 * 判断是否存在：
 * - 找到左边界后，检查 nums[left] == target
 * - 如果不等，说明不存在
 *
 * 前端应用：
 * - 搜索建议：找前缀匹配的范围
 * - 日志查询：找时间范围内的记录」
 *
 * 🔄 可能的追问：
 * - 如果 target 不存在怎么处理？
 * - 如何统计 target 的出现次数？
 */

// ============================================================
// Q7: 二分查找的时间复杂度分析？
// ============================================================

/**
 * 📝 问题：二分查找的时间复杂度为什么是 O(log n)？
 *
 * ✅ 标准答案：
 * 每次迭代排除一半的搜索空间。
 *
 * 设搜索空间大小为 n：
 * - 第 1 次后：n/2
 * - 第 2 次后：n/4
 * - 第 k 次后：n/2^k
 *
 * 当 n/2^k = 1 时，k = log₂n
 *
 * 所以时间复杂度是 O(log n)。
 *
 * ⭐ 加分回答：
 * 「不同类型的复杂度分析：
 *
 * 1. 标准二分：O(log n)
 *    - 纯二分查找
 *
 * 2. 答案二分：O(log(range) × check)
 *    - range 是答案空间大小
 *    - check 是验证函数的复杂度
 *    - 例如：O(log n × n) = O(n log n)
 *
 * 3. 有重复元素的旋转数组：
 *    - 平均 O(log n)
 *    - 最坏 O(n)（全是重复元素）
 *
 * 空间复杂度：O(1)
 * - 只用了几个变量
 * - 递归实现是 O(log n)
 *
 * 对比线性搜索：
 * - n = 10^9 时
 * - 线性：10^9 次
 * - 二分：30 次（2^30 ≈ 10^9）
 *
 * 这就是为什么二分在大数据量时非常高效。」
 *
 * 🔄 可能的追问：
 * - 递归二分的空间复杂度？
 * - 什么情况下二分会退化？
 */

// ============================================================
// Q8: 寻找峰值怎么做？
// ============================================================

/**
 * 📝 问题：无序数组中如何找峰值？为什么可以二分？
 *
 * ✅ 标准答案：
 * 利用"局部比较"判断往哪边走。
 *
 * 峰值定义：比左右邻居都大的元素
 *
 * 二分思路：
 * - 如果 nums[mid] < nums[mid + 1]：在上坡，峰值在右边
 * - 如果 nums[mid] > nums[mid + 1]：在下坡或峰值，往左找
 *
 * ⭐ 加分回答：
 * 「为什么无序也能二分？
 *
 * 关键：边界条件 nums[-1] = nums[n] = -∞
 *
 * 这意味着两端都是"向上"的，所以中间一定有峰值。
 *
 * 上坡/下坡判断：
 * - nums[mid] < nums[mid + 1]：在上坡，峰值在右边
 * - nums[mid] > nums[mid + 1]：在下坡，峰值在左边（包括 mid）
 *
 * 代码：
 * while (left < right) {
 *   const mid = (left + right) >> 1;
 *   if (nums[mid] < nums[mid + 1]) {
 *     left = mid + 1;  // 上坡，峰值在右边
 *   } else {
 *     right = mid;     // 下坡，峰值在左边或就是 mid
 *   }
 * }
 * return left;
 *
 * 这道题展示了二分的本质：
 * 不需要全局有序，只需要能判断往哪边走。」
 *
 * 🔄 可能的追问：
 * - 如果有多个峰值，找的是哪个？
 * - 山脉数组怎么找峰值？
 */

// ============================================================
// Q9: 二维矩阵怎么二分？
// ============================================================

/**
 * 📝 问题：如何在二维有序矩阵中二分查找？
 *
 * ✅ 标准答案：
 * 两种方法：
 *
 * 1. 展开成一维：
 *    - 把矩阵看成一维数组
 *    - index → (index / cols, index % cols)
 *
 * 2. 从右上角或左下角开始：
 *    - 可以排除一行或一列
 *    - 类似二叉搜索树
 *
 * ⭐ 加分回答：
 * 「两种矩阵类型：
 *
 * 类型一：每行有序 + 下一行第一个 > 上一行最后一个
 * - 可以展开成一维二分
 * - O(log(m × n))
 *
 * 类型二：每行有序 + 每列有序（但不连续）
 * - 从右上角开始
 * - 大于 target 往左，小于 target 往下
 * - O(m + n)
 *
 * 坐标转换：
 * - 一维索引 idx → 行 = idx / cols, 列 = idx % cols
 * - 二维坐标 (row, col) → 一维 = row * cols + col
 *
 * 代码示例（类型一）：
 * let left = 0, right = rows * cols - 1;
 * while (left <= right) {
 *   const mid = (left + right) >> 1;
 *   const val = matrix[Math.floor(mid / cols)][mid % cols];
 *   if (val === target) return true;
 *   if (val < target) left = mid + 1;
 *   else right = mid - 1;
 * }
 * return false;
 * 」
 *
 * 🔄 可能的追问：
 * - 两种矩阵类型的区别？
 * - 有序矩阵中第 K 小怎么找？
 */

// ============================================================
// Q10: 前端有哪些二分的应用场景？
// ============================================================

/**
 * 📝 问题：前端开发中有哪些二分查找的应用场景？
 *
 * ✅ 标准答案：
 *
 * 1. 虚拟列表：根据滚动位置找起始索引
 * 2. 图表交互：找最近的数据点
 * 3. 时间选择器：在刻度上定位
 *
 * ⭐ 加分回答：
 * 「前端二分的典型场景：
 *
 * 【虚拟列表/虚拟滚动】
 * - 问题：列表有 10 万项，只渲染可视区域
 * - 二分：根据 scrollTop 找第一个可见项的索引
 * - 变体：变高虚拟列表需要累加高度后二分
 *
 * 【Git bisect】
 * - 问题：某个提交引入了 bug
 * - 二分：就是"第一个错误的版本"
 * - 完全一样的算法！
 *
 * 【图表交互】
 * - 问题：鼠标悬停时显示最近的数据点
 * - 二分：找 x 坐标最接近鼠标位置的点
 * - 类似：搜索插入位置 + 左右比较
 *
 * 【IP 地址定位】
 * - 问题：根据 IP 查归属地
 * - 二分：IP 转整数后在范围表中查找
 *
 * 【搜索建议】
 * - 问题：输入前缀，返回匹配的词
 * - 二分：找前缀的第一个和最后一个位置
 *
 * 【任务调度】
 * - 问题：最少几个并发能在时限内完成
 * - 二分：答案二分 + 模拟验证
 *
 * 了解这些场景有助于在面试中展示实战经验。」
 *
 * 🔄 可能的追问：
 * - 虚拟列表的二分怎么写？
 * - 变高虚拟列表有什么难点？
 */

// ============================================================
// 📋 面试问答速查表
// ============================================================

/**
 * ┌─────────────────────────────────────────────────────────────────────────┐
 * │                           面试问答速查表                                 │
 * ├────────────────────────────────────┬────────────────────────────────────┤
 * │           问题类型                 │              核心答案要点           │
 * ├────────────────────────────────────┼────────────────────────────────────┤
 * │ 二分本质                           │ 二段性，判断排除一半               │
 * │ <= vs <                           │ 找确切值用<=，找边界用<            │
 * │ 避免死循环                         │ 用 left=mid+1，不用 left=mid       │
 * │ 答案二分                           │ 确定空间+check函数+二分            │
 * │ 旋转数组                           │ 判断mid在哪段，target在哪段        │
 * │ 左右边界                           │ right=mid找左界，转化找右界        │
 * │ 时间复杂度                         │ O(log n)，答案二分是O(log×check)   │
 * │ 寻找峰值                           │ 上坡往右，下坡往左                 │
 * │ 二维矩阵                           │ 展开一维，或右上角遍历             │
 * │ 前端应用                           │ 虚拟列表、git bisect、图表交互     │
 * └────────────────────────────────────┴────────────────────────────────────┘
 */

// ============================================================
// 🎯 回答问题的技巧
// ============================================================

/**
 * 二分查找题目的回答模板：
 *
 * 1. 识别问题类型：
 *    「这道题是[标准二分/边界二分/答案二分/旋转数组]」
 *
 * 2. 确定搜索空间：
 *    「搜索空间是[数组索引/答案范围]，从 X 到 Y」
 *
 * 3. 选择模板：
 *    「因为是找[确切值/边界]，用[<=/< ]作为循环条件」
 *
 * 4. 说明判断逻辑：
 *    「当 xxx 时往左找，当 xxx 时往右找」
 *
 * 5. 复杂度分析：
 *    「时间 O(log n)，空间 O(1)」
 *
 * 示例回答（搜索插入位置）：
 * 「这道题是边界二分，找第一个 >= target 的位置。
 * 搜索空间是数组索引 [0, n]。
 * 用 left < right 作为循环条件。
 * 当 nums[mid] >= target 时，right = mid；否则 left = mid + 1。
 * 最后返回 left，它就是插入位置。
 * 时间 O(log n)，空间 O(1)。」
 */

export {};

