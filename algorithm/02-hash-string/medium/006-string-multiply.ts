/**
 * 📝 题目：字符串相乘
 * 🔗 链接：https://leetcode.cn/problems/multiply-strings/
 * 🏷️ 难度：Medium
 * 🏷️ 标签：数学、字符串、模拟
 *
 * 📋 题目描述：
 * 给定两个以字符串形式表示的非负整数 num1 和 num2，
 * 返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。
 *
 * 注意：不能使用任何内置的大整数库或直接将输入转换为整数。
 *
 * 示例：
 * 输入：num1 = "2", num2 = "3"
 * 输出："6"
 *
 * 输入：num1 = "123", num2 = "456"
 * 输出："56088"
 */

// ============================================================
// 💡 思路分析：这道题的解法是怎么想出来的？
// ============================================================
//
// 模拟手算乘法（竖式乘法）
//
// 关键观察：
// - num1[i] × num2[j] 的结果会影响 result[i+j] 和 result[i+j+1]
// - 两个 n 位数相乘，结果最多 2n 位
//
// 📊 竖式乘法图解：
//
//         1 2 3   (num1)
//       ×   4 5   (num2)
//     ─────────
//         6 1 5   (123 × 5)
//       4 9 2     (123 × 4)
//     ─────────
//       5 5 3 5   (结果)
//
// 优化：不需要单独计算每一行，直接累加到结果数组

// ============================================================
// 解法一：模拟竖式乘法（推荐）
// ============================================================
// ⏱️ 时间复杂度：O(m × n) | 空间复杂度：O(m + n)

/**
 * 📊 执行过程图解：
 *
 * num1 = "123", num2 = "45"
 * result 数组长度 = 3 + 2 = 5
 * result = [0, 0, 0, 0, 0]
 *
 * 从右往左遍历 num1 和 num2：
 *
 * i=2 (num1[2]='3'), j=1 (num2[1]='5'):
 *   3 × 5 = 15
 *   位置: i+j+1 = 4, i+j = 3
 *   result[4] += 15 % 10 = 5
 *   result[3] += 15 / 10 = 1
 *   result = [0, 0, 0, 1, 5]
 *
 * i=2, j=0 (num2[0]='4'):
 *   3 × 4 = 12
 *   result[3] += 12 % 10 = 2, result[3] = 3
 *   result[2] += 12 / 10 = 1
 *   result = [0, 0, 1, 3, 5]
 *
 * i=1 (num1[1]='2'), j=1:
 *   2 × 5 = 10
 *   result[3] += 10 % 10 = 0, result[3] = 3
 *   result[2] += 10 / 10 = 1, result[2] = 2
 *   result = [0, 0, 2, 3, 5]
 *
 * i=1, j=0:
 *   2 × 4 = 8
 *   result[2] += 8 % 10 = 8, result[2] = 10
 *   处理进位: result[1] += 1, result[2] = 0
 *   result[1] += 8 / 10 = 0
 *   result = [0, 1, 0, 3, 5]
 *
 * ... 继续处理 ...
 *
 * 最终处理进位后: result = [0, 5, 5, 3, 5]
 * 去除前导零: "5535"
 */
function multiply_v1(num1: string, num2: string): string {
  // 特殊情况：任一为 "0"
  if (num1 === '0' || num2 === '0') return '0';

  const m = num1.length;
  const n = num2.length;

  // 结果最多 m+n 位
  const result = new Array(m + n).fill(0);

  // 从右往左遍历
  for (let i = m - 1; i >= 0; i--) {
    for (let j = n - 1; j >= 0; j--) {
      const mul = (num1.charCodeAt(i) - 48) * (num2.charCodeAt(j) - 48);

      // num1[i] × num2[j] 的结果影响 result[i+j] 和 result[i+j+1]
      const p1 = i + j; // 高位
      const p2 = i + j + 1; // 低位

      const sum = mul + result[p2];

      result[p2] = sum % 10;
      result[p1] += Math.floor(sum / 10);
    }
  }

  // 转换为字符串，去除前导零
  let str = '';
  let leadingZero = true;

  for (const digit of result) {
    if (digit === 0 && leadingZero) continue;
    leadingZero = false;
    str += digit;
  }

  return str || '0';
}

// ============================================================
// 解法二：逐位相乘后统一处理进位
// ============================================================
// ⏱️ 时间复杂度：O(m × n) | 空间复杂度：O(m + n)
// 📝 思路相同，但进位统一在最后处理
function multiply_v2(num1: string, num2: string): string {
  if (num1 === '0' || num2 === '0') return '0';

  const m = num1.length;
  const n = num2.length;
  const result = new Array(m + n).fill(0);

  // 先不处理进位，直接累加
  for (let i = m - 1; i >= 0; i--) {
    for (let j = n - 1; j >= 0; j--) {
      const mul = (num1.charCodeAt(i) - 48) * (num2.charCodeAt(j) - 48);
      result[i + j + 1] += mul;
    }
  }

  // 统一处理进位
  let carry = 0;
  for (let i = result.length - 1; i >= 0; i--) {
    const sum = result[i] + carry;
    result[i] = sum % 10;
    carry = Math.floor(sum / 10);
  }

  // 转换为字符串
  let str = result.join('');
  // 去除前导零
  str = str.replace(/^0+/, '');

  return str || '0';
}

// ============================================================
// 🔄 解法对比
// ============================================================
/**
 * | 解法             | 时间      | 空间     | 特点                    |
 * |-----------------|-----------|----------|------------------------|
 * | 逐位乘+即时进位  | O(m × n)  | O(m + n) | 推荐，边乘边进位         |
 * | 逐位乘+统一进位  | O(m × n)  | O(m + n) | 思路清晰，代码简洁       |
 *
 * 两种方法本质相同，只是进位处理的时机不同
 */

// ============================================================
// ⚠️ 易错点
// ============================================================
/**
 * 1. 特殊情况 "0"：
 *    - 任一为 "0" 直接返回 "0"
 *
 * 2. 字符转数字：
 *    - charCodeAt(i) - 48 或 parseInt(str[i])
 *
 * 3. 位置计算：
 *    - num1[i] × num2[j] 影响 result[i+j] 和 result[i+j+1]
 *
 * 4. 前导零：
 *    - 结果可能有前导零，需要去除
 *    - 但结果为 0 时要保留一个 "0"
 */

// ============================================================
// 🔗 举一反三：相似题目
// ============================================================
/**
 * - 字符串相加 → 同样的大数加法
 * - 二进制求和 → 二进制版本
 * - 两数相加（链表）→ 链表形式的大数加法
 *
 * 共同模式：模拟手算，处理进位
 */

// ============================================================
// 🏢 前端业务场景
// ============================================================
/**
 * 1. 大数计算：金融系统中的精确计算
 * 2. 加密算法：RSA 等需要大整数运算
 * 3. 数据统计：统计数据可能超出 Number 范围
 * 4. 区块链：处理大数值的 token 数量
 */

// 导出主解法
export { multiply_v1, multiply_v2 };
export default multiply_v1;

