/**
 * 📝 题目：最长连续序列
 * 🔗 链接：https://leetcode.cn/problems/longest-consecutive-sequence/
 * 🏷️ 难度：Medium
 * 🏷️ 标签：并查集、数组、哈希表
 *
 * 📋 题目描述：
 * 给定一个未排序的整数数组 nums，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。
 *
 * 要求：时间复杂度 O(n)
 *
 * 示例：
 * 输入：nums = [100, 4, 200, 1, 3, 2]
 * 输出：4
 * 解释：最长连续序列是 [1, 2, 3, 4]，长度为 4
 *
 * 输入：nums = [0,3,7,2,5,8,4,6,0,1]
 * 输出：9
 * 解释：最长连续序列是 [0,1,2,3,4,5,6,7,8]
 */

// ============================================================
// 💡 思路分析：这道题的解法是怎么想出来的？
// ============================================================
//
// 要求 O(n) 时间，不能排序！
//
// 1. 排序思路：排序后遍历 → O(n log n)，不满足要求
//
// 2. 哈希表思路：
//    - 先把所有数放入 Set
//    - 对于每个数 x，只有当 x-1 不存在时，才从 x 开始数
//    - 这样保证每个连续序列只会被数一次
//
// 关键优化：
//    - 如果 x-1 存在，说明 x 不是序列的起点，跳过
//    - 只从序列的起点开始计数，避免重复

// ============================================================
// 解法一：哈希表（推荐）
// ============================================================
// ⏱️ 时间复杂度：O(n) | 空间复杂度：O(n)

/**
 * 📊 执行过程图解：
 *
 * nums = [100, 4, 200, 1, 3, 2]
 * set = {100, 4, 200, 1, 3, 2}
 *
 * 遍历每个数：
 *
 *   100: 99 不在 set 中 → 100 是起点
 *        100 存在, 101 不存在 → 长度 1
 *
 *   4:   3 在 set 中 → 4 不是起点，跳过
 *
 *   200: 199 不在 set 中 → 200 是起点
 *        200 存在, 201 不存在 → 长度 1
 *
 *   1:   0 不在 set 中 → 1 是起点
 *        1,2,3,4 都存在, 5 不存在 → 长度 4 ✓
 *
 *   3:   2 在 set 中 → 3 不是起点，跳过
 *
 *   2:   1 在 set 中 → 2 不是起点，跳过
 *
 * 最长连续序列长度 = 4
 *
 * 🔄 为什么是 O(n)？
 *    虽然有两层循环，但每个数最多被访问两次：
 *    - 外层遍历一次
 *    - 内层（作为某个起点的连续序列的一部分）一次
 */
function longestConsecutive_v1(nums: number[]): number {
  if (nums.length === 0) return 0;

  const set = new Set(nums);
  let maxLen = 0;

  for (const num of set) {
    // 只有当 num-1 不存在时，num 才是序列的起点
    if (!set.has(num - 1)) {
      let currentNum = num;
      let currentLen = 1;

      // 从起点开始，数连续的数
      while (set.has(currentNum + 1)) {
        currentNum++;
        currentLen++;
      }

      maxLen = Math.max(maxLen, currentLen);
    }
  }

  return maxLen;
}

// ============================================================
// 解法二：排序（不满足 O(n) 要求）
// ============================================================
// ⏱️ 时间复杂度：O(n log n) | 空间复杂度：O(log n)
// ❌ 不满足题目要求，但思路简单，面试时可以先说这个
function longestConsecutive_v2(nums: number[]): number {
  if (nums.length === 0) return 0;

  // 排序并去重
  const sorted = [...new Set(nums)].sort((a, b) => a - b);

  let maxLen = 1;
  let currentLen = 1;

  for (let i = 1; i < sorted.length; i++) {
    if (sorted[i] === sorted[i - 1] + 1) {
      currentLen++;
      maxLen = Math.max(maxLen, currentLen);
    } else {
      currentLen = 1;
    }
  }

  return maxLen;
}

// ============================================================
// 解法三：哈希表记录序列长度
// ============================================================
// ⏱️ 时间复杂度：O(n) | 空间复杂度：O(n)
// 📝 另一种思路：记录以每个数为端点的序列长度

function longestConsecutive_v3(nums: number[]): number {
  if (nums.length === 0) return 0;

  // map[num] 表示以 num 为端点的序列长度
  const map = new Map<number, number>();
  let maxLen = 0;

  for (const num of nums) {
    // 如果这个数已经处理过，跳过（去重）
    if (map.has(num)) continue;

    // 获取左右邻居的序列长度
    const leftLen = map.get(num - 1) || 0;
    const rightLen = map.get(num + 1) || 0;

    // 当前序列的总长度
    const currentLen = leftLen + 1 + rightLen;

    // 更新当前数的序列长度
    map.set(num, currentLen);

    // 更新左右端点的序列长度（关键！）
    if (leftLen > 0) {
      map.set(num - leftLen, currentLen);
    }
    if (rightLen > 0) {
      map.set(num + rightLen, currentLen);
    }

    maxLen = Math.max(maxLen, currentLen);
  }

  return maxLen;
}

// ============================================================
// 🔄 解法对比
// ============================================================
/**
 * | 解法           | 时间       | 空间  | 特点                     |
 * |---------------|------------|-------|-------------------------|
 * | 哈希表起点法   | O(n)       | O(n)  | 推荐，思路清晰            |
 * | 排序          | O(n log n) | O(n)  | 简单，不满足 O(n) 要求    |
 * | 哈希表端点法   | O(n)       | O(n)  | 动态维护，思路巧妙        |
 *
 * 面试推荐：先说排序思路，再优化到哈希表
 */

// ============================================================
// ⚠️ 易错点
// ============================================================
/**
 * 1. 去重：
 *    - 数组可能有重复元素
 *    - 放入 Set 自动去重
 *
 * 2. 起点判断：
 *    - num-1 不在集合中 → num 是起点
 *    - 这个判断是 O(n) 的关键
 *
 * 3. 空数组：返回 0
 *
 * 4. 遍历 Set 而不是原数组：
 *    - 原数组可能有重复，会重复计算
 */

// ============================================================
// 🔗 举一反三：相似题目
// ============================================================
/**
 * - 缺失的第一个正数 → 原地哈希
 * - 数组中重复的数据 → 原地标记
 * - 找到所有数组中消失的数字 → 原地标记
 *
 * 共同模式：哈希表实现 O(1) 查找
 */

// ============================================================
// 🏢 前端业务场景
// ============================================================
/**
 * 1. 日期处理：找出最长的连续日期范围
 * 2. 版本管理：找出最长的连续版本号
 * 3. 日志分析：找出最长的连续时间段
 * 4. 数据清洗：识别连续的数据块
 */

// 导出主解法
export { longestConsecutive_v1, longestConsecutive_v2, longestConsecutive_v3 };
export default longestConsecutive_v1;

