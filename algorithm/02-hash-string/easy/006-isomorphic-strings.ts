/**
 * 📝 题目：同构字符串
 * 🔗 链接：https://leetcode.cn/problems/isomorphic-strings/
 * 🏷️ 难度：Easy
 * 🏷️ 标签：哈希表、字符串
 *
 * 📋 题目描述：
 * 给定两个字符串 s 和 t，判断它们是否是同构的。
 *
 * 如果 s 中的字符可以按某种映射关系替换得到 t，那么这两个字符串是同构的。
 * 每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。
 * 不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，
 * 字符可以映射到自己本身。
 *
 * 示例：
 * 输入：s = "egg", t = "add"
 * 输出：true
 *
 * 输入：s = "foo", t = "bar"
 * 输出：false
 *
 * 输入：s = "paper", t = "title"
 * 输出：true
 */

// ============================================================
// 💡 思路分析
// ============================================================
//
// 关键：一一映射关系
// - s 中的每个字符只能映射到 t 中的一个字符
// - t 中的每个字符只能被 s 中的一个字符映射
//
// 需要双向检查，否则会漏掉"多对一"的情况：
// s = "ab", t = "aa"
// - a -> a ✓
// - b -> a ✓ (如果只检查 s -> t)
// - 但实际上 a 被两个字符映射，不是一一对应

// ============================================================
// 解法一：双哈希表（推荐）
// ============================================================
// ⏱️ 时间复杂度：O(n) | 空间复杂度：O(k)，k 为字符集大小

/**
 * 📊 执行过程图解：
 *
 * s = "egg", t = "add"
 *
 * i=0: s[0]='e', t[0]='a'
 *      s2t 没有 'e'，t2s 没有 'a'
 *      s2t = {e: a}, t2s = {a: e}
 *
 * i=1: s[1]='g', t[1]='d'
 *      s2t 没有 'g'，t2s 没有 'd'
 *      s2t = {e: a, g: d}, t2s = {a: e, d: g}
 *
 * i=2: s[2]='g', t[2]='d'
 *      s2t 有 'g' -> 'd' ✓
 *      t2s 有 'd' -> 'g' ✓
 *
 * 返回 true
 *
 * ---
 *
 * s = "foo", t = "bar"
 *
 * i=0: s[0]='f', t[0]='b'
 *      s2t = {f: b}, t2s = {b: f}
 *
 * i=1: s[1]='o', t[1]='a'
 *      s2t = {f: b, o: a}, t2s = {b: f, a: o}
 *
 * i=2: s[2]='o', t[2]='r'
 *      s2t 有 'o' -> 'a'，但 t[2]='r' ≠ 'a'
 *      返回 false ✗
 */
function isIsomorphic_v1(s: string, t: string): boolean {
  if (s.length !== t.length) return false;

  const s2t = new Map<string, string>(); // s -> t 的映射
  const t2s = new Map<string, string>(); // t -> s 的映射

  for (let i = 0; i < s.length; i++) {
    const cs = s[i];
    const ct = t[i];

    // 检查 s -> t 映射是否一致
    if (s2t.has(cs) && s2t.get(cs) !== ct) {
      return false;
    }

    // 检查 t -> s 映射是否一致（防止多对一）
    if (t2s.has(ct) && t2s.get(ct) !== cs) {
      return false;
    }

    s2t.set(cs, ct);
    t2s.set(ct, cs);
  }

  return true;
}

// ============================================================
// 解法二：记录首次出现位置
// ============================================================
// ⏱️ 时间复杂度：O(n) | 空间复杂度：O(k)
// 📝 思路：两个字符串中，相同位置的字符首次出现的位置应该一致

/**
 * 📊 思路图解：
 *
 * s = "egg" -> 首次出现位置 [0, 1, 1] (e在0, g在1, g在1)
 * t = "add" -> 首次出现位置 [0, 1, 1] (a在0, d在1, d在1)
 * 相同，是同构
 *
 * s = "foo" -> 首次出现位置 [0, 1, 1]
 * t = "bar" -> 首次出现位置 [0, 1, 2]
 * 不同，不是同构
 */
function isIsomorphic_v2(s: string, t: string): boolean {
  if (s.length !== t.length) return false;

  const sFirstIndex = new Map<string, number>();
  const tFirstIndex = new Map<string, number>();

  for (let i = 0; i < s.length; i++) {
    const cs = s[i];
    const ct = t[i];

    // 记录首次出现位置
    if (!sFirstIndex.has(cs)) {
      sFirstIndex.set(cs, i);
    }
    if (!tFirstIndex.has(ct)) {
      tFirstIndex.set(ct, i);
    }

    // 比较首次出现位置是否一致
    if (sFirstIndex.get(cs) !== tFirstIndex.get(ct)) {
      return false;
    }
  }

  return true;
}

// ============================================================
// 解法三：使用 indexOf（简洁但效率低）
// ============================================================
// ⏱️ 时间复杂度：O(n²) | 空间复杂度：O(1)
// ❌ 不推荐，但代码最简洁

function isIsomorphic_v3(s: string, t: string): boolean {
  if (s.length !== t.length) return false;

  for (let i = 0; i < s.length; i++) {
    // 比较两个字符串中，当前字符首次出现的位置
    if (s.indexOf(s[i]) !== t.indexOf(t[i])) {
      return false;
    }
  }

  return true;
}

// ============================================================
// 🔄 解法对比
// ============================================================
/**
 * | 解法        | 时间   | 空间  | 特点                      |
 * |------------|--------|-------|--------------------------|
 * | 双哈希表    | O(n)   | O(k)  | 推荐，逻辑清晰             |
 * | 首次位置    | O(n)   | O(k)  | 思路巧妙                   |
 * | indexOf    | O(n²)  | O(1)  | 代码简洁，效率低           |
 */

// ============================================================
// ⚠️ 易错点
// ============================================================
/**
 * 1. 必须双向检查：
 *    只检查 s->t 会漏掉 "ab" vs "aa" 这种情况
 *
 * 2. 长度必须相等：
 *    长度不等一定不是同构
 *
 * 3. 字符可以映射到自己：
 *    "abc" vs "abc" 是同构的
 */

// ============================================================
// 🔗 举一反三：相似题目
// ============================================================
/**
 * - 单词规律 → 单词到模式的映射（类似，但是单词级别）
 * - 无重复字符的最长子串 → 字符映射检查
 * - 同构子串 → 更复杂的变体
 *
 * 共同模式：双向映射检查
 */

// ============================================================
// 🏢 前端业务场景
// ============================================================
/**
 * 1. 数据映射验证：验证两个数据源的字段是否一一对应
 * 2. 编码转换验证：验证编码规则是否可逆
 * 3. 用户匹配：验证两组用户的匹配关系是否合理
 * 4. 配置映射：验证配置项的映射关系是否正确
 */

export { isIsomorphic_v1, isIsomorphic_v2, isIsomorphic_v3 };
export default isIsomorphic_v1;

