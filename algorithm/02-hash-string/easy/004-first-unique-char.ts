/**
 * 📝 题目：字符串中的第一个唯一字符
 * 🔗 链接：https://leetcode.cn/problems/first-unique-character-in-a-string/
 * 🏷️ 难度：Easy
 * 🏷️ 标签：队列、哈希表、字符串、计数
 *
 * 📋 题目描述：
 * 给定一个字符串 s，找到它的第一个不重复的字符，并返回它的索引。
 * 如果不存在，则返回 -1。
 *
 * 示例：
 * 输入：s = "leetcode"
 * 输出：0
 * 解释：'l' 是第一个只出现一次的字符，下标是 0
 *
 * 输入：s = "loveleetcode"
 * 输出：2
 * 解释：'v' 是第一个只出现一次的字符，下标是 2
 *
 * 输入：s = "aabb"
 * 输出：-1
 */

// ============================================================
// 💡 思路分析：这道题的解法是怎么想出来的？
// ============================================================
//
// 「第一个」+「唯一」→ 需要统计频率，然后按顺序查找
//
// 1. 暴力思路：对每个字符，检查是否在后面出现 → O(n²)
//
// 2. 哈希计数（推荐）：
//    - 第一遍：统计每个字符的出现次数
//    - 第二遍：找第一个次数为 1 的字符
//    - 时间 O(n)，空间 O(k)
//
// 3. 优化：用数组代替 Map（仅限小写字母）
//    - 26 个字母对应长度 26 的数组
//    - 空间 O(1)

// ============================================================
// 解法一：哈希表计数（推荐）
// ============================================================
// ⏱️ 时间复杂度：O(n) | 空间复杂度：O(k)

/**
 * 📊 执行过程图解：
 *
 * s = "leetcode"
 *
 * Step 1: 统计频率
 *         count = {l:1, e:3, t:1, c:1, o:1, d:1}
 *
 * Step 2: 按顺序查找第一个频率为 1 的字符
 *         s[0]='l', count['l']=1 ✓
 *
 * 返回 0
 */
function firstUniqChar_v1(s: string): number {
  // 第一遍：统计每个字符的出现次数
  const count = new Map<string, number>();

  for (const char of s) {
    count.set(char, (count.get(char) || 0) + 1);
  }

  // 第二遍：找第一个次数为 1 的字符
  for (let i = 0; i < s.length; i++) {
    if (count.get(s[i]) === 1) {
      return i;
    }
  }

  return -1;
}

// ============================================================
// 解法二：数组计数（仅限小写字母）
// ============================================================
// ⏱️ 时间复杂度：O(n) | 空间复杂度：O(26) = O(1)
function firstUniqChar_v2(s: string): number {
  const count = new Array(26).fill(0);
  const aCode = 'a'.charCodeAt(0);

  // 统计频率
  for (const char of s) {
    count[char.charCodeAt(0) - aCode]++;
  }

  // 找第一个频率为 1 的
  for (let i = 0; i < s.length; i++) {
    if (count[s.charCodeAt(i) - aCode] === 1) {
      return i;
    }
  }

  return -1;
}

// ============================================================
// 解法三：记录首次和末次出现位置
// ============================================================
// ⏱️ 时间复杂度：O(n) | 空间复杂度：O(k)
// 📝 思路：如果首次出现位置 = 末次出现位置，说明只出现一次
function firstUniqChar_v3(s: string): number {
  let minIndex = s.length;

  // 遍历 26 个字母
  for (let i = 0; i < 26; i++) {
    const char = String.fromCharCode('a'.charCodeAt(0) + i);
    const first = s.indexOf(char);
    const last = s.lastIndexOf(char);

    // 如果存在且只出现一次
    if (first !== -1 && first === last) {
      minIndex = Math.min(minIndex, first);
    }
  }

  return minIndex === s.length ? -1 : minIndex;
}

// ============================================================
// 解法四：indexOf + lastIndexOf（简洁但效率低）
// ============================================================
// ⏱️ 时间复杂度：O(n²) | 空间复杂度：O(1)
// ❌ 不推荐：每个字符都要调用 indexOf 和 lastIndexOf
function firstUniqChar_v4(s: string): number {
  for (let i = 0; i < s.length; i++) {
    // 如果首次出现和末次出现的位置相同，说明只出现一次
    if (s.indexOf(s[i]) === s.lastIndexOf(s[i])) {
      return i;
    }
  }

  return -1;
}

// ============================================================
// 🔄 解法对比
// ============================================================
/**
 * | 解法                    | 时间  | 空间  | 特点                |
 * |------------------------|-------|-------|---------------------|
 * | 哈希表计数              | O(n)  | O(k)  | 通用，推荐           |
 * | 数组计数               | O(n)  | O(1)  | 仅限小写字母，最优    |
 * | 首末位置比较            | O(n)  | O(k)  | 思路新颖             |
 * | indexOf+lastIndexOf    | O(n²) | O(1)  | 简洁但慢             |
 */

// ============================================================
// ⚠️ 易错点
// ============================================================
/**
 * 1. 返回的是下标，不是字符
 *
 * 2. 不存在时返回 -1
 *
 * 3. 「第一个」要求按原字符串顺序查找
 *    - 不能按哈希表的顺序
 *
 * 4. 空字符串：返回 -1
 */

// ============================================================
// 🔗 举一反三：相似题目
// ============================================================
/**
 * - 只出现一次的数字 → 位运算（异或）
 * - 前 K 个高频元素 → 哈希计数 + 堆/桶排序
 * - 重复的 DNA 序列 → 哈希表 + 滑动窗口
 *
 * 共同模式：哈希表统计频率
 */

// ============================================================
// 🏢 前端业务场景
// ============================================================
/**
 * 1. 日志分析：找出第一个只出现一次的错误类型
 * 2. 用户行为：找出第一个独特的用户操作
 * 3. 数据去重：找出第一个不重复的数据项
 * 4. 搜索优化：找出第一个独特的搜索词
 */

// 导出主解法
export { firstUniqChar_v1, firstUniqChar_v2, firstUniqChar_v3, firstUniqChar_v4 };
export default firstUniqChar_v1;

