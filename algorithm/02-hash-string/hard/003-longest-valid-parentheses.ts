/**
 * 📝 题目：最长有效括号
 * 🔗 链接：https://leetcode.cn/problems/longest-valid-parentheses/
 * 🏷️ 难度：Hard
 * 🏷️ 标签：栈、字符串、动态规划
 *
 * 📋 题目描述：
 * 给你一个只包含 '(' 和 ')' 的字符串，找出最长有效（格式正确且连续）括号子串的长度。
 *
 * 示例：
 * 输入：s = "(()"
 * 输出：2
 * 解释：最长有效括号子串是 "()"
 *
 * 输入：s = ")()())"
 * 输出：4
 * 解释：最长有效括号子串是 "()()"
 *
 * 输入：s = ""
 * 输出：0
 */

// ============================================================
// 💡 思路分析
// ============================================================
//
// 这道题有三种经典解法：
// 1. 栈：利用栈记录无法匹配的括号位置
// 2. 动态规划：dp[i] 表示以 i 结尾的最长有效括号
// 3. 左右计数：从左到右扫描，再从右到左扫描
//
// 难点在于理解"连续"的含义：
// "()(())" 的答案是 6，不是 2+4
// 需要处理多个有效子串相连的情况

// ============================================================
// 解法一：栈（推荐）
// ============================================================
// ⏱️ 时间复杂度：O(n) | 空间复杂度：O(n)

/**
 * 📊 栈解法思路图解：
 *
 * 栈中存储"无法匹配的括号的下标"
 * - 遇到 '('：入栈
 * - 遇到 ')'：
 *   - 如果栈顶是 '('，弹出匹配
 *   - 否则，')' 入栈
 *
 * 最后栈中剩余的是所有无法匹配的位置
 * 两个无法匹配位置之间就是有效括号
 *
 * 例：s = ")()())"
 * 下标：0 1 2 3 4 5
 *
 * 遍历后栈中剩余：[0, 5]（位置 0 和 5 无法匹配）
 *
 * 有效区间：(0, 5) = 5 - 0 - 1 = 4
 */
function longestValidParentheses_v1(s: string): number {
  const n = s.length;
  const stack: number[] = []; // 存储无法匹配的括号下标

  for (let i = 0; i < n; i++) {
    if (s[i] === '(') {
      stack.push(i);
    } else {
      // ')'
      if (stack.length > 0 && s[stack[stack.length - 1]] === '(') {
        stack.pop(); // 匹配成功，弹出
      } else {
        stack.push(i); // 无法匹配，入栈
      }
    }
  }

  // 如果栈为空，整个字符串都是有效的
  if (stack.length === 0) {
    return n;
  }

  // 计算无法匹配位置之间的最大间隔
  let maxLen = 0;
  let right = n; // 右边界

  while (stack.length > 0) {
    const left = stack.pop()!;
    maxLen = Math.max(maxLen, right - left - 1);
    right = left;
  }

  // 别忘了最左边的区间
  maxLen = Math.max(maxLen, right);

  return maxLen;
}

// ============================================================
// 解法二：栈（另一种思路，更直观）
// ============================================================
// ⏱️ 时间复杂度：O(n) | 空间复杂度：O(n)

/**
 * 📊 思路：
 *
 * 栈底始终保持"最后一个没有被匹配的右括号的下标"
 * - 初始放入 -1
 * - 遇到 '('：入栈
 * - 遇到 ')'：弹出栈顶
 *   - 如果栈空了，说明当前 ')' 无法匹配，把它入栈
 *   - 如果栈非空，当前有效长度 = i - 栈顶
 */
function longestValidParentheses_v2(s: string): number {
  const stack: number[] = [-1]; // 栈底放 -1
  let maxLen = 0;

  for (let i = 0; i < s.length; i++) {
    if (s[i] === '(') {
      stack.push(i);
    } else {
      stack.pop();

      if (stack.length === 0) {
        // 栈空了，当前 ')' 无法匹配
        stack.push(i);
      } else {
        // 栈非空，计算有效长度
        maxLen = Math.max(maxLen, i - stack[stack.length - 1]);
      }
    }
  }

  return maxLen;
}

// ============================================================
// 解法三：动态规划
// ============================================================
// ⏱️ 时间复杂度：O(n) | 空间复杂度：O(n)

/**
 * 📊 动态规划思路：
 *
 * dp[i] = 以下标 i 结尾的最长有效括号长度
 *
 * 如果 s[i] = '('，dp[i] = 0（不可能以 '(' 结尾）
 *
 * 如果 s[i] = ')'：
 *   - 情况1：s[i-1] = '('，形成 "()"
 *     dp[i] = dp[i-2] + 2
 *
 *   - 情况2：s[i-1] = ')'，形成 "))"
 *     需要看 i - dp[i-1] - 1 位置是否是 '('
 *     如果是，dp[i] = dp[i-1] + 2 + dp[i - dp[i-1] - 2]
 *
 * 例：s = "(())"
 *
 * i=0: '(' → dp[0] = 0
 * i=1: '(' → dp[1] = 0
 * i=2: ')' s[1]='(' → dp[2] = dp[0] + 2 = 2
 * i=3: ')' s[2]=')' → 看 i-dp[2]-1=0，s[0]='(' → dp[3] = dp[2]+2+dp[-1] = 4
 */
function longestValidParentheses_v3(s: string): number {
  const n = s.length;
  if (n === 0) return 0;

  const dp = new Array(n).fill(0);
  let maxLen = 0;

  for (let i = 1; i < n; i++) {
    if (s[i] === ')') {
      if (s[i - 1] === '(') {
        // 情况1：...()
        dp[i] = (i >= 2 ? dp[i - 2] : 0) + 2;
      } else if (i - dp[i - 1] - 1 >= 0 && s[i - dp[i - 1] - 1] === '(') {
        // 情况2：...))，且对应位置是 (
        dp[i] = dp[i - 1] + 2 + (i - dp[i - 1] - 2 >= 0 ? dp[i - dp[i - 1] - 2] : 0);
      }
      maxLen = Math.max(maxLen, dp[i]);
    }
  }

  return maxLen;
}

// ============================================================
// 解法四：左右计数（O(1) 空间）
// ============================================================
// ⏱️ 时间复杂度：O(n) | 空间复杂度：O(1)

/**
 * 📊 左右计数思路：
 *
 * 从左到右扫描：
 * - left 记录 '(' 数量
 * - right 记录 ')' 数量
 * - left === right 时，记录有效长度
 * - right > left 时，重置（无法匹配）
 *
 * 问题：如果 '(' 一直多于 ')'，无法记录
 * 解决：再从右到左扫描一次
 */
function longestValidParentheses_v4(s: string): number {
  let left = 0;
  let right = 0;
  let maxLen = 0;

  // 从左到右
  for (const char of s) {
    if (char === '(') {
      left++;
    } else {
      right++;
    }

    if (left === right) {
      maxLen = Math.max(maxLen, 2 * right);
    } else if (right > left) {
      left = right = 0;
    }
  }

  left = right = 0;

  // 从右到左
  for (let i = s.length - 1; i >= 0; i--) {
    if (s[i] === '(') {
      left++;
    } else {
      right++;
    }

    if (left === right) {
      maxLen = Math.max(maxLen, 2 * left);
    } else if (left > right) {
      left = right = 0;
    }
  }

  return maxLen;
}

// ============================================================
// 🔄 解法对比
// ============================================================
/**
 * | 解法       | 时间  | 空间  | 特点                        |
 * |-----------|-------|-------|----------------------------|
 * | 栈(v1)    | O(n)  | O(n)  | 记录无法匹配的位置          |
 * | 栈(v2)    | O(n)  | O(n)  | 栈底保持边界，更直观         |
 * | 动态规划   | O(n)  | O(n)  | 经典 DP，需要理解状态转移    |
 * | 左右计数   | O(n)  | O(1)  | 最优空间，扫描两次           |
 *
 * 面试推荐：栈解法（v2），最直观且容易讲清楚
 */

// ============================================================
// ⚠️ 易错点
// ============================================================
/**
 * 1. 连续有效括号：
 *    "()(())" 的答案是 6，不是 2 和 4
 *    多个有效子串相连要合并
 *
 * 2. 栈解法的边界：
 *    初始放入 -1 是关键，或者最后处理左边界
 *
 * 3. 动态规划的两种情况：
 *    - ...()
 *    - ...))
 *    第二种需要额外加上 dp[i - dp[i-1] - 2]
 *
 * 4. 左右计数需要两次扫描：
 *    只从左到右会漏掉 "(()" 这种情况
 */

// ============================================================
// 🔗 举一反三：相似题目
// ============================================================
/**
 * - 有效的括号 → 栈匹配
 * - 括号生成 → 回溯
 * - 删除无效的括号 → BFS/回溯
 * - 使括号有效的最少添加 → 计数
 *
 * 共同模式：栈处理括号匹配
 */

// ============================================================
// 🏢 前端业务场景
// ============================================================
/**
 * 1. 代码编辑器：检测括号匹配
 * 2. 表达式解析：解析数学表达式
 * 3. 模板语法：检测模板标签配对
 * 4. JSON 验证：检测大括号匹配
 */

export {
  longestValidParentheses_v1,
  longestValidParentheses_v2,
  longestValidParentheses_v3,
  longestValidParentheses_v4,
};
export default longestValidParentheses_v2;

