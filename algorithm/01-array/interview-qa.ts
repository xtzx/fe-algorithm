/**
 * ============================================================
 * 📚 数组与双指针 - 面试高频问答
 * ============================================================
 *
 * 本文件包含数组与双指针相关的面试高频问题，每个问题包含：
 * 1. 问题本身
 * 2. 标准答案
 * 3. 加分回答（展示深度理解）
 * 4. 追问方向
 */

// ============================================================
// Q1: 什么是双指针？有哪些类型？
// ============================================================

/**
 * 📝 问题：什么是双指针？有哪些类型？
 *
 * ✅ 标准答案：
 * 双指针是一种使用两个指针遍历数组或字符串的技巧，通过控制两个指针的移动
 * 来减少时间复杂度，通常可以将 O(n²) 优化到 O(n)。
 *
 * 主要有三种类型：
 * 1. 对撞指针：两个指针从两端向中间移动（如两数之和II、盛水容器）
 * 2. 快慢指针：两个指针同向移动，速度不同（如移动零、删除重复项）
 * 3. 滑动窗口：维护一个可变大小的窗口（如无重复最长子串）
 *
 * ⭐ 加分回答：
 * 「双指针的本质是利用某种单调性或有序性来避免重复计算。
 *
 * 比如对撞指针，当数组有序时，如果 nums[left] + nums[right] < target，
 * 那么 nums[left] + nums[right-1] 一定更小，所以可以直接 left++，
 * 不需要枚举 right 的所有可能值。这就是为什么能从 O(n²) 优化到 O(n)。
 *
 * 滑动窗口也是类似的思想，当窗口满足条件时，left 只会向右移动，
 * 不会回退，所以总体是 O(n) 而不是 O(n²)。」
 *
 * 🔄 可能的追问：
 * - 什么时候用对撞指针，什么时候用滑动窗口？
 * - 快慢指针还能解决什么问题？（链表环检测）
 */

// ============================================================
// Q2: 滑动窗口的适用条件是什么？
// ============================================================

/**
 * 📝 问题：滑动窗口的适用条件是什么？什么时候不能用？
 *
 * ✅ 标准答案：
 * 滑动窗口适用于：
 * 1. 求连续子数组或子串的问题
 * 2. 需要求最长、最短、恰好满足某条件的子数组
 * 3. 窗口的状态可以通过增删元素高效维护
 *
 * 不适用的情况：
 * 1. 数组中有负数，且求子数组和相关问题 → 用前缀和
 * 2. 不要求连续 → 可能是动态规划
 * 3. 需要所有子数组而非最优 → 可能是回溯
 *
 * ⭐ 加分回答：
 * 「滑动窗口能用的本质条件是：窗口状态的变化具有单调性。
 *
 * 比如"长度最小的子数组（和>=target）"，当窗口和 >= target 时，
 * 我们收缩窗口（left++），窗口和会减小。这种单调性保证了
 * left 指针只会向右移动，不会回退。
 *
 * 但如果数组有负数，加一个数可能让和变小，减一个数可能让和变大，
 * 单调性被破坏了，滑动窗口就不适用了。这时候应该用前缀和 + 哈希表。」
 *
 * 🔄 可能的追问：
 * - 滑动窗口怎么处理"恰好等于K"的问题？
 * - 如果有负数，用什么方法？
 */

// ============================================================
// Q3: 前缀和解决什么问题？
// ============================================================

/**
 * 📝 问题：什么是前缀和？解决什么问题？
 *
 * ✅ 标准答案：
 * 前缀和是一种预处理技巧，prefix[i] 表示数组前 i 个元素的和。
 *
 * 主要解决：
 * 1. 快速求区间和：sum(i, j) = prefix[j+1] - prefix[i]，O(1) 时间
 * 2. 子数组和相关问题：找和为 K 的子数组、和可被 K 整除的子数组
 * 3. 可以处理负数（滑动窗口不行的场景）
 *
 * 常见公式：
 * prefix[0] = 0
 * prefix[i] = prefix[i-1] + nums[i-1]
 * sum[i..j] = prefix[j+1] - prefix[i]
 *
 * ⭐ 加分回答：
 * 「前缀和 + 哈希表是一个非常强大的组合。
 *
 * 比如"和为 K 的子数组"，我们要找所有 sum[i..j] = k 的区间数。
 * 转化一下：prefix[j+1] - prefix[i] = k，即 prefix[i] = prefix[j+1] - k。
 *
 * 所以我们用哈希表记录每个前缀和出现的次数，遍历时查找
 * prefix[j+1] - k 在哈希表中出现了多少次，就是以 j 结尾的答案数。
 *
 * 这个技巧可以扩展到"和可被 K 整除"（记录余数）、"01个数相等"
 * （0 变成 -1）等很多变形题。」
 *
 * 🔄 可能的追问：
 * - 二维前缀和怎么做？
 * - 前缀积呢？（除自身以外数组的乘积）
 */

// ============================================================
// Q4: 接雨水怎么做？有几种解法？
// ============================================================

/**
 * 📝 问题：接雨水这道题怎么做？有几种解法？
 *
 * ✅ 标准答案：
 * 核心思想：每个位置能接的水 = min(左边最高, 右边最高) - 当前高度
 *
 * 三种解法：
 * 1. 预处理（DP）：O(n) 时间，O(n) 空间
 *    - 预计算 leftMax[i] 和 rightMax[i]
 *    - 遍历求和
 *
 * 2. 双指针：O(n) 时间，O(1) 空间（最优）
 *    - 左右指针从两端向中间移动
 *    - 移动 max 值较小的一边
 *
 * 3. 单调栈：O(n) 时间，O(n) 空间
 *    - 维护递减栈，遇到更高的柱子时计算凹槽水量
 *    - 按行计算，思路不同
 *
 * ⭐ 加分回答：
 * 「双指针解法的关键是理解为什么可以只用两个变量。
 *
 * 假设当前 leftMax < rightMax：
 * - 对于 left 位置，它左边的最大值我们已经知道是 leftMax
 * - 它右边的最大值至少是 rightMax（可能更大）
 * - 所以 left 位置的水位由 leftMax 决定，可以安全计算
 *
 * 这就是为什么移动较小 max 对应的指针。
 *
 * 面试时我会先说预处理思路（最直观），然后优化到双指针（展示优化能力），
 * 最后如果时间充裕，可以提一下单调栈解法（展示知识广度）。」
 *
 * 🔄 可能的追问：
 * - 双指针和预处理的本质区别是什么？
 * - 单调栈解法的思路是什么？
 * - 柱状图中最大的矩形怎么做？（相关题）
 */

// ============================================================
// Q5: 三数之和怎么去重？
// ============================================================

/**
 * 📝 问题：三数之和怎么去重？为什么这么写？
 *
 * ✅ 标准答案：
 * 排序 + 三处去重：
 *
 * 1. 固定的第一个数 i：
 *    if (i > 0 && nums[i] === nums[i-1]) continue;
 *
 * 2. 左指针 left（找到解后）：
 *    while (left < right && nums[left] === nums[left+1]) left++;
 *
 * 3. 右指针 right（找到解后）：
 *    while (left < right && nums[right] === nums[right-1]) right--;
 *
 * ⭐ 加分回答：
 * 「去重的时机很关键：
 *
 * 对于 i：在开始双指针之前去重，跳过相同的第一个数。
 * 注意是 nums[i] === nums[i-1] 而不是 nums[i] === nums[i+1]，
 * 因为我们要保留第一个，跳过后面的重复。
 *
 * 对于 left 和 right：在找到一组解之后去重。
 * 因为如果在找解之前就跳过，可能会漏掉一些解。
 * 比如 [-2, 0, 0, 2, 2]，target=0，[-2, 0, 2] 是一个解，
 * 如果提前跳过 0，就会漏掉这个解。
 *
 * 这也是为什么用 nums[i-1] 而不是 nums[i+1] 的原因——
 * 我们要保证这个数是第一次被选中。」
 *
 * 🔄 可能的追问：
 * - 如果不排序能做吗？（哈希表，但去重很麻烦）
 * - 四数之和怎么做？
 */

// ============================================================
// Q6: 什么时候用滑动窗口，什么时候用前缀和？
// ============================================================

/**
 * 📝 问题：连续子数组问题，怎么判断用滑动窗口还是前缀和？
 *
 * ✅ 标准答案：
 *
 * 用滑动窗口：
 * - 数组元素都是正数（或都是非负）
 * - 求最长/最短满足条件的子数组
 * - 例子：长度最小的子数组（和>=target）、无重复最长子串
 *
 * 用前缀和：
 * - 数组中有负数
 * - 求子数组和等于某个值的个数
 * - 例子：和为K的子数组、和可被K整除的子数组
 *
 * ⭐ 加分回答：
 * 「判断标准其实是：当你扩大窗口时，某个指标是否单调变化。
 *
 * 正数数组的窗口和，扩大一定增加，收缩一定减少 → 可以用滑动窗口
 *
 * 有负数时，扩大可能增加也可能减少 → 单调性被破坏 → 用前缀和
 *
 * 还有一种情况：求"恰好等于K"的问题。即使是正数数组，
 * 滑动窗口也不太好处理。可以转化为">=K的个数 - >=K+1的个数"，
 * 或者直接用前缀和。」
 *
 * 🔄 可能的追问：
 * - 如果是乘积呢？（取对数转化为加法）
 * - 二维的情况怎么处理？
 */

// ============================================================
// Q7: 原地修改数组怎么做？
// ============================================================

/**
 * 📝 问题：原地修改数组类的题目怎么做？
 *
 * ✅ 标准答案：
 * 使用快慢指针：
 * - slow：指向已处理区域的末尾（下一个要写入的位置）
 * - fast：遍历数组，找需要保留的元素
 *
 * 模板：
 * let slow = 0;
 * for (let fast = 0; fast < n; fast++) {
 *   if (需要保留 nums[fast]) {
 *     nums[slow] = nums[fast];
 *     slow++;
 *   }
 * }
 * return slow; // 新数组长度
 *
 * ⭐ 加分回答：
 * 「快慢指针有两种理解方式：
 *
 * 1. 分区思想：slow 左边是已处理区域，slow 到 fast 是无用区域，
 *    fast 右边是待处理区域。
 *
 * 2. 覆盖思想：slow 记录"写入位置"，fast 负责"读取"，
 *    只有满足条件的元素才会被写入。
 *
 * 这个技巧可以用于：
 * - 移动零
 * - 移除元素
 * - 删除有序数组中的重复项
 * - 删除有序数组中的重复项II（保留两个）
 *
 * 变形技巧：如果要保留 k 个重复项，可以比较 nums[fast] 和 nums[slow-k]。」
 *
 * 🔄 可能的追问：
 * - 如果要求保留最多两个重复项呢？
 * - 如何原地反转数组？
 */

// ============================================================
// Q8: 数组题的常见优化思路有哪些？
// ============================================================

/**
 * 📝 问题：数组题从 O(n²) 优化到 O(n) 有哪些常见方法？
 *
 * ✅ 标准答案：
 *
 * 1. 排序 + 双指针
 *    - 适用：找满足条件的一对/多个数
 *    - 例子：两数之和II、三数之和
 *
 * 2. 哈希表
 *    - 适用：需要快速查找某个值是否存在
 *    - 例子：两数之和（无序）、和为K的子数组
 *
 * 3. 前缀和
 *    - 适用：区间求和、子数组和问题
 *    - 例子：和为K的子数组、除自身以外数组的乘积
 *
 * 4. 滑动窗口
 *    - 适用：连续子数组/子串的最值问题
 *    - 例子：无重复最长子串、最小覆盖子串
 *
 * ⭐ 加分回答：
 * 「优化的本质是避免重复计算：
 *
 * - 双指针利用有序性，避免枚举所有配对
 * - 哈希表用空间换时间，O(1) 查找替代 O(n) 遍历
 * - 前缀和把 O(n) 的区间求和变成 O(1) 的减法
 * - 滑动窗口利用单调性，避免重复计算子数组状态
 *
 * 面试时，我通常会先说暴力解法，分析瓶颈在哪里，
 * 然后针对性地选择优化方法。这样既展示思考过程，
 * 也说明为什么选择这种方法。」
 *
 * 🔄 可能的追问：
 * - 还有什么其他优化方法？（单调栈、分治等）
 * - 怎么判断应该用哪种方法？
 */

// ============================================================
// Q9: 滑动窗口求最长和求最短有什么区别？
// ============================================================

/**
 * 📝 问题：滑动窗口求最长和求最短的写法有什么区别？
 *
 * ✅ 标准答案：
 *
 * 求最长（如无重复字符的最长子串）：
 * - 尽量扩张，只在不满足条件时收缩
 * - 在扩张后更新答案
 *
 * 求最短（如长度最小的子数组）：
 * - 满足条件就尝试收缩
 * - 在收缩时更新答案
 *
 * 模板对比：
 *
 * // 求最长
 * for (right = 0; right < n; right++) {
 *   加入 right 元素
 *   while (不满足条件) {
 *     移除 left 元素, left++
 *   }
 *   maxLen = max(maxLen, right - left + 1)  // 扩张后更新
 * }
 *
 * // 求最短
 * for (right = 0; right < n; right++) {
 *   加入 right 元素
 *   while (满足条件) {
 *     minLen = min(minLen, right - left + 1)  // 收缩时更新
 *     移除 left 元素, left++
 *   }
 * }
 *
 * ⭐ 加分回答：
 * 「核心区别是"贪心策略"不同：
 *
 * 求最长时，我们贪心地想要更大的窗口，所以尽量扩张，
 * 只有违反条件时才不得不收缩。
 *
 * 求最短时，我们贪心地想要更小的窗口，所以一旦满足条件，
 * 就尝试收缩看能不能更短。
 *
 * 还有一个细节：求最短时，初始值设为 Infinity，
 * 最后要检查是否更新过（return minLen === Infinity ? 0 : minLen）。」
 *
 * 🔄 可能的追问：
 * - "恰好等于"怎么处理？
 * - 窗口内需要维护什么状态？
 */

// ============================================================
// Q10: 原地哈希是什么？什么时候用？
// ============================================================

/**
 * 📝 问题：什么是原地哈希？什么时候用？
 *
 * ✅ 标准答案：
 * 原地哈希是利用数组本身作为哈希表的技巧，适用于：
 * 1. 数字范围在 [1, n]（或 [0, n-1]）
 * 2. 要求 O(1) 空间
 * 3. 找缺失/重复的数字
 *
 * 核心思想：
 * - 把数字 x 放到下标 x-1 的位置
 * - 或者用正负号标记某个数是否出现
 *
 * 例子：缺失的第一个正数、找到所有消失的数字
 *
 * ⭐ 加分回答：
 * 「原地哈希有两种实现方式：
 *
 * 1. 交换法：把 nums[i] 放到 nums[nums[i]-1] 的位置
 *    while (nums[i] >= 1 && nums[i] <= n && nums[nums[i]-1] !== nums[i]) {
 *      swap(nums[i], nums[nums[i]-1])
 *    }
 *    然后遍历，如果 nums[i] !== i+1，说明 i+1 缺失
 *
 * 2. 标记法：用正负号标记
 *    遍历数组，把 |nums[i]| 对应位置的数变成负数
 *    然后遍历，正数位置的下标+1就是缺失的数
 *
 * 交换法更直观，标记法不改变数字本身（只改变符号）。
 * 根据题目要求选择。」
 *
 * 🔄 可能的追问：
 * - 如果数字范围不是 [1, n] 呢？（需要先处理或用其他方法）
 * - 找重复的数字怎么做？（快慢指针或原地哈希）
 */

// ============================================================
// 📋 面试问答速查表
// ============================================================

/**
 * ┌─────────────────────────────────────────────────────────────────────────┐
 * │                           面试问答速查表                                 │
 * ├────────────────────────────────┬────────────────────────────────────────┤
 * │           问题类型             │              核心答案要点               │
 * ├────────────────────────────────┼────────────────────────────────────────┤
 * │ 什么是双指针                   │ 三种类型：对撞、快慢、滑动窗口          │
 * │ 滑动窗口适用条件               │ 连续子数组 + 单调性（正数才能用）        │
 * │ 前缀和解决什么                 │ 区间和、子数组和（可处理负数）           │
 * │ 接雨水怎么做                   │ 核心公式 + 双指针 + 单调栈三解法         │
 * │ 三数之和去重                   │ 排序 + 三处去重（时机很重要）            │
 * │ 滑动窗口 vs 前缀和             │ 正数用窗口，负数用前缀和                 │
 * │ 原地修改                       │ 快慢指针：slow写入，fast读取             │
 * │ O(n²) 优化到 O(n)              │ 排序+双指针、哈希表、前缀和、滑动窗口    │
 * │ 求最长 vs 求最短               │ 最长在扩张时更新，最短在收缩时更新       │
 * │ 原地哈希                       │ 数字范围[1,n]，O(1)空间找缺失/重复       │
 * └────────────────────────────────┴────────────────────────────────────────┘
 */

// ============================================================
// 🎯 回答问题的技巧
// ============================================================

/**
 * 面试中回答算法问题的 STAR 框架：
 *
 * S (Situation/问题理解)：
 * - 「这道题是...问题，输入是...，输出是...」
 * - 确认边界条件和数据范围
 *
 * T (Thought/思路分析)：
 * - 「我首先想到的是暴力解法...时间复杂度是 O(n²)」
 * - 「观察到...特点，可以用...优化」
 *
 * A (Approach/具体方法)：
 * - 「我使用...方法，核心思想是...」
 * - 「代码实现上，主要有这几步...」
 *
 * R (Result/复杂度分析)：
 * - 「时间复杂度是 O(n)，因为...」
 * - 「空间复杂度是 O(1)」
 *
 * 示例回答：
 * 「三数之和这道题，我首先想到暴力三重循环 O(n³)，但数据规模是 10⁴，
 * 会超时。观察到我们需要找三个数和为 0，可以固定一个数，
 * 问题就变成了两数之和。如果先排序，两数之和可以用对撞指针 O(n)，
 * 总体就是 O(n²)。去重是这道题的关键，需要在三个地方处理...」
 */

export {};

