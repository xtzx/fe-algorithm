/**
 * 📝 题目：长度最小的子数组
 * 🔗 链接：https://leetcode.cn/problems/minimum-size-subarray-sum/
 * 🏷️ 难度：Medium
 * 🏷️ 标签：数组、二分查找、前缀和、滑动窗口
 *
 * 📋 题目描述：
 * 给定一个含有 n 个正整数的数组和一个正整数 target，
 * 找出该数组中满足其总和大于等于 target 的长度最小的 连续子数组，
 * 并返回其长度。如果不存在符合条件的子数组，返回 0。
 *
 * 示例：
 * 输入：target = 7, nums = [2,3,1,2,4,3]
 * 输出：2
 * 解释：子数组 [4,3] 是该条件下的长度最小的子数组
 */

// ============================================================
// 💡 思路分析：这道题的解法是怎么想出来的？
// ============================================================
//
// 关键词：「连续子数组」「最小长度」「和 >= target」→ 滑动窗口！
//
// 1. 暴力思路：枚举所有子数组，找和 >= target 的最短的 → O(n²)
//
// 2. 滑动窗口思路：
//    - 扩张：不断加入元素，直到和 >= target
//    - 收缩：尝试缩小窗口，看能否找到更短的
//    - 关键：因为都是正整数，窗口越大和越大（单调性）
//
// 3. 为什么能用滑动窗口？
//    - 元素都是正整数 → 窗口和具有单调性
//    - 扩张和一定增大，收缩和一定减小
//
// 📊 滑动窗口过程：
//
//    target = 7, nums = [2, 3, 1, 2, 4, 3]
//
//    [2] 3 1 2 4 3        sum=2 < 7, 扩张
//     ↑
//
//    [2  3] 1 2 4 3       sum=5 < 7, 扩张
//     ↑  ↑
//
//    [2  3  1] 2 4 3      sum=6 < 7, 扩张
//     ↑     ↑
//
//    [2  3  1  2] 4 3     sum=8 >= 7, 记录长度=4, 收缩
//     ↑        ↑
//
//     2 [3  1  2] 4 3     sum=6 < 7, 扩张
//        ↑     ↑
//
//     2 [3  1  2  4] 3    sum=10 >= 7, 记录长度=4, 收缩
//        ↑        ↑
//
//     2  3 [1  2  4] 3    sum=7 >= 7, 记录长度=3, 收缩
//           ↑     ↑
//
//     2  3  1 [2  4] 3    sum=6 < 7, 扩张
//              ↑  ↑
//
//     2  3  1 [2  4  3]   sum=9 >= 7, 记录长度=3, 收缩
//              ↑     ↑
//
//     2  3  1  2 [4  3]   sum=7 >= 7, 记录长度=2 ✓, 收缩
//                 ↑  ↑
//
//     2  3  1  2  4 [3]   sum=3 < 7, 扩张（结束）
//                    ↑
//
//    最小长度 = 2

// ============================================================
// 解法一：滑动窗口（推荐）
// ============================================================
// ⏱️ 时间复杂度：O(n) | 空间复杂度：O(1)

/**
 * 🔄 流程图 (Mermaid):
 * ```mermaid
 * flowchart TD
 *     A[left=0, sum=0, minLen=∞] --> B[遍历 right: 0 到 n-1]
 *     B --> C[sum += nums[right]]
 *     C --> D{sum >= target?}
 *     D -->|Yes| E[更新 minLen]
 *     E --> F[sum -= nums[left], left++]
 *     F --> D
 *     D -->|No| B
 *     B -->|遍历结束| G{minLen == ∞?}
 *     G -->|Yes| H[返回 0]
 *     G -->|No| I[返回 minLen]
 * ```
 */
function minSubArrayLen_v1(target: number, nums: number[]): number {
  let left = 0;
  let sum = 0;
  let minLen = Infinity;

  for (let right = 0; right < nums.length; right++) {
    // 1. 扩张窗口
    sum += nums[right];

    // 2. 收缩窗口：当和 >= target 时，尝试收缩
    while (sum >= target) {
      // 求最短，在收缩时更新
      minLen = Math.min(minLen, right - left + 1);
      sum -= nums[left];
      left++;
    }
  }

  return minLen === Infinity ? 0 : minLen;
}

// ============================================================
// 解法二：前缀和 + 二分查找
// ============================================================
// ⏱️ 时间复杂度：O(n log n) | 空间复杂度：O(n)
// 📝 思路：用前缀和把区间和问题转化为两点差值问题

/**
 * 📊 前缀和思路：
 *
 * nums = [2, 3, 1, 2, 4, 3]
 * prefix = [0, 2, 5, 6, 8, 12, 15]
 *
 * 区间 [i, j] 的和 = prefix[j+1] - prefix[i]
 *
 * 问题转化：找 prefix[j+1] - prefix[i] >= target
 *          即 prefix[j+1] >= prefix[i] + target
 *
 * 因为元素都是正整数，prefix 数组是递增的
 * 可以用二分查找找到满足条件的最小 j+1
 */
function minSubArrayLen_v2(target: number, nums: number[]): number {
  const n = nums.length;

  // 构建前缀和
  const prefix: number[] = new Array(n + 1).fill(0);
  for (let i = 0; i < n; i++) {
    prefix[i + 1] = prefix[i] + nums[i];
  }

  let minLen = Infinity;

  // 对每个起点 i，二分查找满足条件的最小终点
  for (let i = 0; i < n; i++) {
    // 需要找 prefix[j] >= prefix[i] + target 的最小 j
    const targetSum = prefix[i] + target;

    // 二分查找
    let left = i + 1;
    let right = n;
    while (left <= right) {
      const mid = Math.floor((left + right) / 2);
      if (prefix[mid] >= targetSum) {
        right = mid - 1;
      } else {
        left = mid + 1;
      }
    }

    // left 是满足条件的最小下标
    if (left <= n) {
      minLen = Math.min(minLen, left - i);
    }
  }

  return minLen === Infinity ? 0 : minLen;
}

// ============================================================
// 解法三：暴力枚举（不推荐）
// ============================================================
// ⏱️ 时间复杂度：O(n²) | 空间复杂度：O(1)
function minSubArrayLen_v3(target: number, nums: number[]): number {
  let minLen = Infinity;
  const n = nums.length;

  for (let i = 0; i < n; i++) {
    let sum = 0;
    for (let j = i; j < n; j++) {
      sum += nums[j];
      if (sum >= target) {
        minLen = Math.min(minLen, j - i + 1);
        break; // 找到了以 i 开头的最短子数组，跳出
      }
    }
  }

  return minLen === Infinity ? 0 : minLen;
}

// ============================================================
// 🔄 解法对比
// ============================================================
/**
 * | 解法           | 时间       | 空间  | 特点                     |
 * |---------------|------------|-------|-------------------------|
 * | 滑动窗口       | O(n)       | O(1)  | 最优，利用单调性          |
 * | 前缀和+二分    | O(n log n) | O(n)  | 通用，不依赖正整数条件     |
 * | 暴力          | O(n²)      | O(1)  | 简单但慢                  |
 *
 * 什么时候用哪个？
 * - 元素都是正整数 → 滑动窗口
 * - 元素有正有负 → 前缀和+哈希 或 其他方法
 */

// ============================================================
// ⚠️ 易错点
// ============================================================
/**
 * 1. 何时更新结果？
 *    - 求最短：在收缩时更新（while 循环内）
 *    - 求最长：在扩张时更新（while 循环外）
 *
 * 2. 窗口长度：right - left + 1
 *
 * 3. 不存在的情况：minLen 仍为 Infinity，返回 0
 *
 * 4. 滑动窗口的前提：
 *    - 元素都是正整数，保证了单调性
 *    - 如果有负数，滑动窗口不适用
 */

// ============================================================
// 🔗 举一反三：相似题目
// ============================================================
/**
 * - 和为K的子数组 → 前缀和 + 哈希（有负数）
 * - 乘积小于K的子数组 → 滑动窗口（正整数）
 * - 无重复字符的最长子串 → 滑动窗口
 * - 最小覆盖子串 → 滑动窗口
 */

// ============================================================
// 🏢 前端业务场景
// ============================================================
/**
 * 1. 数据加载：找出最少需要加载多少条数据才能满足展示需求
 * 2. 性能监控：找出最短的时间段内 CPU/内存 使用超过阈值
 * 3. 限流统计：找出最少多少次请求会触发限流
 * 4. 任务调度：找出最少多少个任务的总时间会超过截止日期
 */

// 导出主解法
export { minSubArrayLen_v1, minSubArrayLen_v2, minSubArrayLen_v3 };
export default minSubArrayLen_v1;

