/**
 * 📝 题目：两数之和 II - 输入有序数组
 * 🔗 链接：https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/
 * 🏷️ 难度：Easy
 * 🏷️ 标签：数组、双指针、二分查找
 *
 * 📋 题目描述：
 * 给你一个下标从 1 开始的整数数组 numbers，该数组已按 非递减顺序排列，
 * 请你从数组中找出满足相加之和等于目标数 target 的两个数。
 *
 * 示例：
 * 输入：numbers = [2,7,11,15], target = 9
 * 输出：[1,2]  // 下标从1开始
 * 解释：2 + 7 = 9
 */

// ============================================================
// 💡 思路分析：这道题的解法是怎么想出来的？
// ============================================================
//
// 关键信息：数组已排序！
//
// 1. 暴力解法：双重循环 O(n²) - 没有利用有序这个条件
//
// 2. 优化思考：有序数组有什么特点？
//    - 如果 nums[i] + nums[j] > target，说明 j 太大了
//    - 如果 nums[i] + nums[j] < target，说明 i 太小了
//    - 这正好符合「对撞指针」的使用场景！
//
// 3. 对撞指针思路：
//    - left 从最小值开始，right 从最大值开始
//    - sum > target：right-- (减小和)
//    - sum < target：left++ (增大和)
//    - sum == target：找到答案

// ============================================================
// 解法一：暴力枚举
// ============================================================
// ⏱️ 时间复杂度：O(n²) | 空间复杂度：O(1)
// ❌ 不推荐：没有利用数组有序的特点
function twoSum_v1(numbers: number[], target: number): number[] {
  const n = numbers.length;

  for (let i = 0; i < n; i++) {
    for (let j = i + 1; j < n; j++) {
      if (numbers[i] + numbers[j] === target) {
        return [i + 1, j + 1]; // 题目要求下标从1开始
      }
    }
  }

  return [];
}

// ============================================================
// 解法二：对撞指针（推荐）
// ============================================================
// ⏱️ 时间复杂度：O(n) | 空间复杂度：O(1)
// ✅ 推荐：充分利用有序特点

/**
 * 📊 执行过程图解：
 *
 * numbers = [2, 7, 11, 15], target = 9
 *
 * Step 1:  [2, 7, 11, 15]    sum = 2+15 = 17 > 9, right--
 *           ↑          ↑
 *          left      right
 *
 * Step 2:  [2, 7, 11, 15]    sum = 2+11 = 13 > 9, right--
 *           ↑      ↑
 *          left  right
 *
 * Step 3:  [2, 7, 11, 15]    sum = 2+7 = 9 = target ✓
 *           ↑  ↑
 *          left right
 *
 * 返回 [1, 2] (下标从1开始)
 */
function twoSum_v2(numbers: number[], target: number): number[] {
  let left = 0;
  let right = numbers.length - 1;

  while (left < right) {
    const sum = numbers[left] + numbers[right];

    if (sum === target) {
      return [left + 1, right + 1]; // 下标从1开始
    } else if (sum < target) {
      left++; // 和太小，左指针右移
    } else {
      right--; // 和太大，右指针左移
    }
  }

  return [];
}

// ============================================================
// 解法三：二分查找
// ============================================================
// ⏱️ 时间复杂度：O(n log n) | 空间复杂度：O(1)
// 📝 思路：固定一个数，二分查找另一个数
function twoSum_v3(numbers: number[], target: number): number[] {
  const n = numbers.length;

  for (let i = 0; i < n; i++) {
    const complement = target - numbers[i];
    // 在 [i+1, n-1] 范围内二分查找 complement
    let left = i + 1;
    let right = n - 1;

    while (left <= right) {
      const mid = Math.floor((left + right) / 2);
      if (numbers[mid] === complement) {
        return [i + 1, mid + 1];
      } else if (numbers[mid] < complement) {
        left = mid + 1;
      } else {
        right = mid - 1;
      }
    }
  }

  return [];
}

// ============================================================
// 🔄 解法对比
// ============================================================
/**
 * | 解法     | 时间       | 空间  | 适用场景                |
 * |---------|-----------|-------|------------------------|
 * | 暴力    | O(n²)     | O(1)  | 不推荐                  |
 * | 对撞指针 | O(n)      | O(1)  | 有序数组（推荐）         |
 * | 二分查找 | O(n log n)| O(1)  | 有序数组，练习二分用      |
 */

// ============================================================
// ⚠️ 易错点
// ============================================================
/**
 * 1. 下标从 1 开始：题目要求返回的下标是从1开始的，不是0
 * 2. 对撞指针条件：while (left < right)，不是 left <= right
 * 3. 移动指针的逻辑：
 *    - sum < target → left++（需要更大的数）
 *    - sum > target → right--（需要更小的数）
 */

// ============================================================
// 🔗 举一反三：相似题目
// ============================================================
/**
 * - 两数之和（无序数组）→ 哈希表 O(n)
 * - 三数之和 → 排序 + 对撞指针
 * - 四数之和 → 排序 + 双层循环 + 对撞指针
 * - 有效三角形的个数 → 排序 + 对撞指针
 */

// ============================================================
// 🏢 前端业务场景
// ============================================================
/**
 * 1. 购物车凑单：在有序价格列表中找两件商品刚好凑满减
 * 2. 配对系统：在有序评分列表中找两个用户，评分和为某个值
 * 3. 时间安排：在有序时长列表中找两个任务，总时长刚好为某值
 */

// 导出主解法
export { twoSum_v1, twoSum_v2, twoSum_v3 };
export default twoSum_v2;

