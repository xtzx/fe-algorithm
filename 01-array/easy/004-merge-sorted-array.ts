/**
 * 📝 题目：合并两个有序数组
 * 🔗 链接：https://leetcode.cn/problems/merge-sorted-array/
 * 🏷️ 难度：Easy
 * 🏷️ 标签：数组、双指针、排序
 *
 * 📋 题目描述：
 * 给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，
 * 另有两个整数 m 和 n，分别表示 nums1 和 nums2 中的元素数目。
 * 请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。
 *
 * 注意：最终结果存储在 nums1 中，nums1 的长度为 m + n
 *
 * 示例：
 * 输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
 * 输出：[1,2,2,3,5,6]
 */

// ============================================================
// 💡 思路分析：这道题的解法是怎么想出来的？
// ============================================================
//
// 关键信息：「两个有序数组」「原地合并到 nums1」「nums1 有足够空间」
//
// 1. 正向双指针：从头开始比较，但需要额外空间存储 nums1 的元素
//
// 2. 逆向双指针（巧妙！）：
//    - nums1 后面有空位
//    - 从后往前填充，大的先放
//    - 这样不会覆盖 nums1 中还未处理的元素
//
//    nums1 = [1, 2, 3, _, _, _]    nums2 = [2, 5, 6]
//                   ↑        ↑              ↑
//                   p1      p (填充位置)    p2
//
// 3. 为什么从后往前？
//    - 从前往后：可能覆盖 nums1 中还没比较的元素
//    - 从后往前：利用 nums1 后面的空位，不会覆盖

// ============================================================
// 解法一：逆向双指针（推荐）
// ============================================================
// ⏱️ 时间复杂度：O(m+n) | 空间复杂度：O(1)

/**
 * 📊 执行过程图解：
 *
 * nums1 = [1, 2, 3, 0, 0, 0], m = 3
 * nums2 = [2, 5, 6], n = 3
 *
 *   初始:    nums1 = [1, 2, 3, _, _, _]
 *                        ↑           ↑
 *                       p1           p
 *            nums2 = [2, 5, 6]
 *                           ↑
 *                          p2
 *
 *   Step 1: 比较 3 和 6, 6 > 3, 放入 p 位置
 *           nums1 = [1, 2, 3, _, _, 6]
 *                        ↑        ↑
 *                       p1        p
 *           p2--, p--
 *
 *   Step 2: 比较 3 和 5, 5 > 3, 放入 p 位置
 *           nums1 = [1, 2, 3, _, 5, 6]
 *                        ↑     ↑
 *                       p1     p
 *           p2--, p--
 *
 *   Step 3: 比较 3 和 2, 3 > 2, 放入 p 位置
 *           nums1 = [1, 2, 3, 3, 5, 6]
 *                     ↑     ↑
 *                    p1     p
 *           p1--, p--
 *
 *   Step 4: 比较 2 和 2, 2 >= 2, 放入 p 位置（取 nums1 的）
 *           nums1 = [1, 2, 2, 3, 5, 6]
 *                     ↑  ↑
 *                    p1  p
 *           p1--, p--
 *
 *   Step 5: 比较 1 和 2, 2 > 1, 放入 p 位置
 *           nums1 = [1, 2, 2, 3, 5, 6]
 *                     ↑  ↑
 *                     p  p1
 *           p2--, p--
 *
 *   p2 < 0, 结束
 *
 * 最终：[1, 2, 2, 3, 5, 6]
 */
function merge_v1(
  nums1: number[],
  m: number,
  nums2: number[],
  n: number
): void {
  let p1 = m - 1; // nums1 的指针（指向最后一个有效元素）
  let p2 = n - 1; // nums2 的指针
  let p = m + n - 1; // 填充位置（从后往前）

  // 从后往前填充
  while (p1 >= 0 && p2 >= 0) {
    if (nums1[p1] > nums2[p2]) {
      nums1[p] = nums1[p1];
      p1--;
    } else {
      nums1[p] = nums2[p2];
      p2--;
    }
    p--;
  }

  // 如果 nums2 还有剩余，需要复制过来
  // 注意：如果 nums1 还有剩余，不需要处理（已经在正确位置）
  while (p2 >= 0) {
    nums1[p] = nums2[p2];
    p2--;
    p--;
  }
}

// ============================================================
// 解法二：正向双指针 + 额外空间
// ============================================================
// ⏱️ 时间复杂度：O(m+n) | 空间复杂度：O(m)
// 📝 思路直观，但需要额外空间
function merge_v2(
  nums1: number[],
  m: number,
  nums2: number[],
  n: number
): void {
  // 复制 nums1 的有效部分
  const nums1Copy = nums1.slice(0, m);

  let p1 = 0;
  let p2 = 0;
  let p = 0;

  while (p1 < m && p2 < n) {
    if (nums1Copy[p1] <= nums2[p2]) {
      nums1[p] = nums1Copy[p1];
      p1++;
    } else {
      nums1[p] = nums2[p2];
      p2++;
    }
    p++;
  }

  // 复制剩余元素
  while (p1 < m) {
    nums1[p] = nums1Copy[p1];
    p1++;
    p++;
  }

  while (p2 < n) {
    nums1[p] = nums2[p2];
    p2++;
    p++;
  }
}

// ============================================================
// 解法三：直接合并后排序（简单但不推荐）
// ============================================================
// ⏱️ 时间复杂度：O((m+n)log(m+n)) | 空间复杂度：O(log(m+n))
// ❌ 不推荐：没有利用「已排序」的条件
function merge_v3(
  nums1: number[],
  m: number,
  nums2: number[],
  n: number
): void {
  // 把 nums2 复制到 nums1 的后半部分
  for (let i = 0; i < n; i++) {
    nums1[m + i] = nums2[i];
  }

  // 排序
  nums1.sort((a, b) => a - b);
}

// ============================================================
// 🔄 解法对比
// ============================================================
/**
 * | 解法         | 时间          | 空间     | 特点                    |
 * |-------------|---------------|----------|------------------------|
 * | 逆向双指针   | O(m+n)        | O(1)     | 最优解，原地操作         |
 * | 正向双指针   | O(m+n)        | O(m)     | 思路直观，需要额外空间    |
 * | 合并后排序   | O((m+n)log)   | O(log)   | 简单但没利用有序条件      |
 */

// ============================================================
// ⚠️ 易错点
// ============================================================
/**
 * 1. 指针初始位置：
 *    - p1 = m - 1（不是 nums1.length - 1）
 *    - p2 = n - 1
 *    - p = m + n - 1
 *
 * 2. 剩余元素处理：
 *    - nums2 剩余：需要复制
 *    - nums1 剩余：不需要处理（已在正确位置）
 *
 * 3. 边界条件：
 *    - m = 0：直接复制 nums2
 *    - n = 0：不需要任何操作
 */

// ============================================================
// 🔗 举一反三：相似题目
// ============================================================
/**
 * - 合并两个有序链表 → 双指针
 * - 合并K个有序数组 → 归并/优先队列
 * - 有序数组的平方 → 双指针
 */

// ============================================================
// 🏢 前端业务场景
// ============================================================
/**
 * 1. 日志合并：合并多个时间有序的日志流
 * 2. 数据同步：合并本地和服务器的有序数据
 * 3. 聊天记录：合并多个会话的消息（按时间排序）
 * 4. 搜索结果：合并多个数据源的有序搜索结果
 */

// 导出主解法
export { merge_v1, merge_v2, merge_v3 };
export default merge_v1;

