/**
 * 📝 题目：移动零
 * 🔗 链接：https://leetcode.cn/problems/move-zeroes/
 * 🏷️ 难度：Easy
 * 🏷️ 标签：数组、双指针
 *
 * 📋 题目描述：
 * 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，
 * 同时保持非零元素的相对顺序。
 *
 * 要求：必须在不复制数组的情况下原地对数组进行操作。
 *
 * 示例：
 * 输入：nums = [0,1,0,3,12]
 * 输出：[1,3,12,0,0]
 */

// ============================================================
// 💡 思路分析：这道题的解法是怎么想出来的？
// ============================================================
//
// 关键词：「原地」「保持相对顺序」「移动零到末尾」
//
// 1. 暴力思路：每遇到一个0，就把后面的元素往前移 → O(n²)
//
// 2. 优化思考：如何一次遍历解决？
//    - 把问题转化为：把所有非零元素移到前面
//    - 用快慢指针：
//      - slow：指向下一个非零元素应该放置的位置
//      - fast：遍历数组找非零元素
//
// 3. 核心技巧：快慢指针分区
//    ┌──────────────┬──────────────┬──────────────┐
//    │  已处理非零   │   待填充0    │   未处理     │
//    └──────────────┴──────────────┴──────────────┘
//                   ↑              ↑
//                  slow          fast

// ============================================================
// 解法一：两次遍历
// ============================================================
// ⏱️ 时间复杂度：O(n) | 空间复杂度：O(1)
// 📝 思路清晰，分两步：1.非零前移 2.末尾填0

/**
 * 📊 执行过程图解：
 *
 * 输入：[0, 1, 0, 3, 12]
 *
 * === 第一遍：非零元素前移 ===
 *
 *   初始:    [0, 1, 0, 3, 12]    slow=0
 *             ↑
 *            fast
 *
 *   fast=0:  [0, 1, 0, 3, 12]    nums[0]=0, 跳过
 *             ↑
 *
 *   fast=1:  [1, 1, 0, 3, 12]    nums[1]=1≠0, 写入slow位置, slow++
 *             ↑  ↑                slow=1
 *           slow fast
 *
 *   fast=2:  [1, 1, 0, 3, 12]    nums[2]=0, 跳过
 *                ↑  ↑
 *              slow fast
 *
 *   fast=3:  [1, 3, 0, 3, 12]    nums[3]=3≠0, 写入slow位置, slow++
 *                ↑     ↑          slow=2
 *              slow   fast
 *
 *   fast=4:  [1, 3, 12, 3, 12]   nums[4]=12≠0, 写入slow位置, slow++
 *                   ↑      ↑      slow=3
 *                 slow    fast
 *
 * === 第二遍：从slow开始填充0 ===
 *
 *   [1, 3, 12, 0, 0]
 *              ↑  ↑
 *             slow → 填充0
 */
function moveZeroes_v1(nums: number[]): void {
  let slow = 0;

  // 第一遍：把非零元素都移到前面
  for (let fast = 0; fast < nums.length; fast++) {
    if (nums[fast] !== 0) {
      nums[slow] = nums[fast];
      slow++;
    }
  }

  // 第二遍：从 slow 开始，后面全部填 0
  for (let i = slow; i < nums.length; i++) {
    nums[i] = 0;
  }
}

// ============================================================
// 解法二：一次遍历（交换法）
// ============================================================
// ⏱️ 时间复杂度：O(n) | 空间复杂度：O(1)
// ✅ 推荐：一次遍历，通过交换实现

/**
 * 📊 执行过程图解：
 *
 * 输入：[0, 1, 0, 3, 12]
 *
 *   初始:    [0, 1, 0, 3, 12]    slow=0
 *             ↑
 *            s,f
 *
 *   fast=0:  [0, 1, 0, 3, 12]    nums[0]=0, 跳过
 *
 *   fast=1:  [1, 0, 0, 3, 12]    nums[1]=1≠0, 交换, slow++
 *             ↑  ↑                交换 nums[0] 和 nums[1]
 *            slow fast
 *
 *   fast=2:  [1, 0, 0, 3, 12]    nums[2]=0, 跳过
 *                ↑  ↑
 *              slow fast
 *
 *   fast=3:  [1, 3, 0, 0, 12]    nums[3]=3≠0, 交换, slow++
 *                ↑     ↑          交换 nums[1] 和 nums[3]
 *              slow   fast
 *
 *   fast=4:  [1, 3, 12, 0, 0]    nums[4]=12≠0, 交换, slow++
 *                   ↑      ↑      交换 nums[2] 和 nums[4]
 *                 slow    fast
 *
 * 最终：[1, 3, 12, 0, 0]
 */
function moveZeroes_v2(nums: number[]): void {
  let slow = 0;

  for (let fast = 0; fast < nums.length; fast++) {
    if (nums[fast] !== 0) {
      // 交换 slow 和 fast 位置的元素
      [nums[slow], nums[fast]] = [nums[fast], nums[slow]];
      slow++;
    }
  }
}

// ============================================================
// 解法三：一次遍历（优化：避免自己和自己交换）
// ============================================================
// ⏱️ 时间复杂度：O(n) | 空间复杂度：O(1)
// ✅ 最优解：避免不必要的交换
function moveZeroes_v3(nums: number[]): void {
  let slow = 0;

  for (let fast = 0; fast < nums.length; fast++) {
    if (nums[fast] !== 0) {
      // 只有当 slow 和 fast 不同时才交换，避免自己和自己交换
      if (slow !== fast) {
        [nums[slow], nums[fast]] = [nums[fast], nums[slow]];
      }
      slow++;
    }
  }
}

// ============================================================
// 🔄 解法对比
// ============================================================
/**
 * | 解法       | 时间  | 空间  | 特点                      |
 * |-----------|-------|-------|--------------------------|
 * | 两次遍历   | O(n)  | O(1)  | 思路清晰，适合理解         |
 * | 一次交换   | O(n)  | O(1)  | 代码简洁                  |
 * | 优化交换   | O(n)  | O(1)  | 避免无效交换（推荐）       |
 */

// ============================================================
// ⚠️ 易错点
// ============================================================
/**
 * 1. 原地修改：不能创建新数组
 * 2. 保持顺序：非零元素的相对顺序不能变
 * 3. slow 的含义：下一个非零元素应该放置的位置
 * 4. 交换 vs 覆盖：
 *    - 交换法：一次遍历
 *    - 覆盖法：需要第二遍填0
 */

// ============================================================
// 🔗 举一反三：相似题目
// ============================================================
/**
 * - 删除有序数组中的重复项 → 快慢指针
 * - 移除元素 → 快慢指针
 * - 删除排序链表中的重复元素 → 快慢指针思想
 *
 * 共同特点：原地修改 + 保持相对顺序 + O(1) 空间
 */

// ============================================================
// 🏢 前端业务场景
// ============================================================
/**
 * 1. 列表排序：把空项/无效项移到末尾
 * 2. 数据清洗：把无效数据集中到一起，方便批量删除
 * 3. 任务队列：把已完成的任务移到队列末尾
 * 4. DOM 操作：把隐藏元素移到容器末尾，优化渲染
 */

// 导出主解法
export { moveZeroes_v1, moveZeroes_v2, moveZeroes_v3 };
export default moveZeroes_v3;

