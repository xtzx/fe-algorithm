/**
 * 📝 题目：盛最多水的容器
 * 🔗 链接：https://leetcode.cn/problems/container-with-most-water/
 * 🏷️ 难度：Medium
 * 🏷️ 标签：数组、双指针、贪心
 *
 * 📋 题目描述：
 * 给定一个长度为 n 的整数数组 height。有 n 条垂线，第 i 条线的两个端点是
 * (i, 0) 和 (i, height[i])。找出其中的两条线，使得它们与 x 轴共同构成的容器
 * 可以容纳最多的水。返回容器可以储存的最大水量。
 *
 * 示例：
 * 输入：height = [1,8,6,2,5,4,8,3,7]
 * 输出：49
 *
 * 图解：
 *     |         |
 *     |         |     |
 *     |   |     |     |
 *     |   |  |  |     |
 *     |   |  |  |  |  |
 *     |   |  |  |  |  |  |
 *     |   |  |  |  |  |  |
 *  |  |   |  |  |  |  |  |
 *  1  8   6  2  5  4  8  3  7
 *
 *  最大面积 = min(8, 7) × 7 = 49
 */

// ============================================================
// 💡 思路分析：这道题的解法是怎么想出来的？
// ============================================================
//
// 1. 暴力解法：枚举所有两条边的组合 O(n²)
//
// 2. 关键洞察：
//    - 面积 = 宽度 × 高度 = (right - left) × min(height[left], height[right])
//    - 如果我们从两端开始（宽度最大），宽度只会减少
//    - 要让面积可能变大，只能让高度变大
//    - 所以应该移动较矮的那一边，希望找到更高的边
//
// 3. 贪心策略：
//    - 移动较矮的边 → 有可能找到更高的边 → 面积可能变大
//    - 移动较高的边 → 高度不会变大（受限于矮边）→ 面积只会变小
//
// 📊 为什么移动短边？
//
//    假设 left 比 right 矮：
//    ┌──────────────────────────┐
//    │  移动 left (短边)         │ → 宽度-1，高度可能↑ → 面积可能↑
//    │  移动 right (长边)        │ → 宽度-1，高度不变或↓ → 面积必定↓
//    └──────────────────────────┘
//
//    所以移动短边是唯一可能让面积变大的选择！

// ============================================================
// 解法一：对撞指针（推荐）
// ============================================================
// ⏱️ 时间复杂度：O(n) | 空间复杂度：O(1)

/**
 * 📊 执行过程图解：
 *
 * height = [1, 8, 6, 2, 5, 4, 8, 3, 7]
 *           0  1  2  3  4  5  6  7  8
 *
 * Step 1:  left=0, right=8
 *          area = min(1, 7) × 8 = 8
 *          1 < 7, 移动 left
 *
 * Step 2:  left=1, right=8
 *          area = min(8, 7) × 7 = 49 ✓ 最大
 *          7 < 8, 移动 right
 *
 * Step 3:  left=1, right=7
 *          area = min(8, 3) × 6 = 18
 *          3 < 8, 移动 right
 *
 * Step 4:  left=1, right=6
 *          area = min(8, 8) × 5 = 40
 *          相等，移动任意一边（这里移动 right）
 *
 * ... 继续直到 left >= right ...
 *
 * 最大面积 = 49
 *
 * 🔄 流程图 (Mermaid):
 * ```mermaid
 * flowchart TD
 *     A[left=0, right=n-1, maxArea=0] --> B{left < right?}
 *     B -->|Yes| C[计算当前面积]
 *     C --> D[更新 maxArea]
 *     D --> E{height[left] < height[right]?}
 *     E -->|Yes| F[left++]
 *     E -->|No| G[right--]
 *     F --> B
 *     G --> B
 *     B -->|No| H[返回 maxArea]
 * ```
 */
function maxArea_v1(height: number[]): number {
  let left = 0;
  let right = height.length - 1;
  let maxArea = 0;

  while (left < right) {
    // 计算当前面积
    const width = right - left;
    const h = Math.min(height[left], height[right]);
    const area = width * h;

    maxArea = Math.max(maxArea, area);

    // 移动较矮的边
    if (height[left] < height[right]) {
      left++;
    } else {
      right--;
    }
  }

  return maxArea;
}

// ============================================================
// 解法二：暴力枚举（不推荐）
// ============================================================
// ⏱️ 时间复杂度：O(n²) | 空间复杂度：O(1)
// ❌ 不推荐：超时
function maxArea_v2(height: number[]): number {
  let maxArea = 0;
  const n = height.length;

  for (let i = 0; i < n; i++) {
    for (let j = i + 1; j < n; j++) {
      const area = (j - i) * Math.min(height[i], height[j]);
      maxArea = Math.max(maxArea, area);
    }
  }

  return maxArea;
}

// ============================================================
// 🔄 解法对比
// ============================================================
/**
 * | 解法     | 时间   | 空间  | 特点                     |
 * |---------|--------|-------|-------------------------|
 * | 双指针   | O(n)   | O(1)  | 贪心策略，最优解          |
 * | 暴力    | O(n²)  | O(1)  | 超时，不推荐              |
 *
 * 双指针为什么是对的？（正确性证明）
 *
 * 假设最优解是 (i, j)，我们从 (0, n-1) 开始：
 * - 在某一步，我们一定会遇到 left=i 或 right=j 的情况
 * - 此时另一边还没移动过去，所以 (i, j) 一定会被考虑到
 * - 因此不会漏掉最优解
 */

// ============================================================
// ⚠️ 易错点
// ============================================================
/**
 * 1. 面积计算：min(height[left], height[right]) × (right - left)
 *    - 高度取两边的最小值（木桶效应）
 *    - 宽度是下标之差
 *
 * 2. 移动策略：移动较矮的一边
 *    - 不是移动较高的一边！
 *    - 相等时移动哪边都可以
 *
 * 3. 为什么不会漏掉最优解？
 *    - 每次移动都是在确定当前短边不可能参与最优解后才移动
 */

// ============================================================
// 🔗 举一反三：相似题目
// ============================================================
/**
 * - 接雨水 → 双指针 / 单调栈（更复杂）
 * - 两数之和 II → 对撞指针
 * - 最长回文子串 → 中心扩展（类似双指针）
 */

// ============================================================
// 🏢 前端业务场景
// ============================================================
/**
 * 1. 布局计算：计算两个元素之间能容纳的最大内容区域
 * 2. 资源分配：在约束条件下最大化利用率
 * 3. 响应式设计：计算容器在不同断点下的最大可用空间
 */

// 导出主解法
export { maxArea_v1, maxArea_v2 };
export default maxArea_v1;

