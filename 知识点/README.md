# 🎯 资深前端面试通关指南

> 面向 5 年以上经验的前端开发者，目标：资深/专家级前端工程师

## 👤 目标画像

```
┌─────────────────────────────────────────────────────────────────────────┐
│                         资深前端工程师能力模型                            │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│   技术深度                    技术广度                     软实力        │
│   ─────────                  ─────────                   ─────────     │
│   • 底层原理                  • 全栈视野                   • 技术影响力   │
│   • 源码阅读                  • 跨端能力                   • 带人能力     │
│   • 性能极致优化              • 架构设计                   • 项目推动     │
│   • 疑难问题攻坚              • 技术选型                   • 技术规划     │
│                                                                         │
│                        核心要求：能独当一面，能带领团队                    │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## 📊 学习路线图

```
                           ┌─────────────────┐
                           │   技术领导力     │
                           │   (Step 12)     │
                           └────────┬────────┘
                                    │
              ┌─────────────────────┼─────────────────────┐
              │                     │                     │
    ┌─────────┴─────────┐ ┌────────┴────────┐ ┌─────────┴─────────┐
    │    架构设计        │ │   领域深耕       │ │    工程体系        │
    │   (Step 09)       │ │  (Step 10)      │ │   (Step 11)       │
    └─────────┬─────────┘ └────────┬────────┘ └─────────┬─────────┘
              │                     │                     │
              └─────────────────────┼─────────────────────┘
                                    │
┌────────────────────────────────────────────────────────────────────────┐
│                              进阶篇                                     │
│  Step 05 ──► Step 06 ──► Step 07 ──► Step 08                          │
│  性能优化     框架原理     工程化       手写代码                          │
└────────────────────────────────────────────────────────────────────────┘
                                    │
┌────────────────────────────────────────────────────────────────────────┐
│                              基础篇                                     │
│  Step 01 ──► Step 02 ──► Step 03 ──► Step 04                          │
│  JavaScript   CSS深入     浏览器原理    网络协议                         │
└────────────────────────────────────────────────────────────────────────┘
```

---

## 📚 完整学习大纲

### 第一层：基础篇（快速过一遍，查漏补缺）

> 💡 7 年经验应该已经熟悉，但要能**讲清楚原理**、**说出 trade-off**

| 步骤 | 主题 | 核心内容 | 面试考察点 | 时间 |
|:---:|------|----------|-----------|:---:|
| 01 | [JavaScript 核心](./01-javascript/) | 类型系统、作用域、原型链、事件循环 | 能讲清楚底层原理，能解释设计思想 | 2天 |
| 02 | [CSS 深入](./02-css/) | 布局、BFC、层叠上下文、动画性能 | 能解决复杂布局问题，懂 GPU 加速原理 | 1天 |
| 03 | [浏览器原理](./03-browser/) | 渲染流水线、V8、内存管理 | 能从浏览器层面分析性能问题 | 2天 |
| 04 | [网络协议](./04-network/) | HTTP/2/3、HTTPS、WebSocket | 能做网络层面的性能优化 | 2天 |

### 第二层：进阶篇（核心竞争力）

> 💡 这是**区分度最高**的部分，需要有深度思考和实战经验

| 步骤 | 主题 | 核心内容 | 面试考察点 | 时间 |
|:---:|------|----------|-----------|:---:|
| 05 | [性能优化](./05-performance/) | 指标体系、优化手段、监控方案 | 有完整的性能优化方法论和落地经验 | 2天 |
| 06 | [框架原理](./06-framework/) | 响应式、虚拟DOM、Diff、调度 | 能讲清楚原理，能对比不同框架设计 | 3天 |
| 07 | [工程化体系](./07-engineering/) | 构建、CI/CD、规范、质量保障 | 能设计完整的工程化体系 | 2天 |
| 08 | [手写代码](./08-handwriting/) | 高频手写 + 设计模式 | 代码质量高，考虑边界和扩展性 | 2天 |

### 第三层：高级篇（资深必备）

> 💡 这是**资深/专家级**的核心考察点

| 步骤 | 主题 | 核心内容 | 面试考察点 | 时间 |
|:---:|------|----------|-----------|:---:|
| 09 | [架构设计](./09-architecture/) | 前端架构、微前端、BFF、跨端 | 能做技术选型，能设计合理架构 | 3天 |
| 10 | [领域深耕](./10-domain/) | 可视化/低代码/编辑器/跨端 | 至少一个领域有深入研究 | 3天 |
| 11 | [工程体系](./11-system/) | 研发效能、质量体系、技术治理 | 能建设团队技术体系 | 2天 |
| 12 | [技术领导力](./12-leadership/) | 技术规划、团队管理、影响力 | 能带团队、能做技术决策 | 2天 |

**总计约 26 天**

---

## 📐 内容标准（重要）

> 💡 每个知识点都必须按照以下标准来编写，确保面试时能够**讲清楚、答全面、有深度**

### 知识点结构模板

每个 `.ts` 文件应包含以下 6 个核心模块：

```typescript
/**
 * ============================================================
 * 📚 知识点名称
 * ============================================================
 */

// ============================================================
// 1. 核心概念
// ============================================================
/**
 * 📖 是什么（What）
 * - 定义和本质
 * - 解决什么问题
 * - 与相关概念的关系/区别
 */

// ============================================================
// 2. 底层原理
// ============================================================
/**
 * 📊 怎么工作（How）
 * - 实现原理
 * - 流程图/示意图（Mermaid）
 * - 源码级理解（如适用）
 */

// ============================================================
// 3. 代码实现
// ============================================================
/**
 * 💻 代码示例
 * - 基础用法
 * - 高级用法
 * - 手写实现（如适用）
 */

// ============================================================
// 4. ⚠️ 注意事项（易错点）
// ============================================================
/**
 * ⚠️ 常见错误
 * - 新手容易犯的错误
 * - 隐藏的陷阱
 * - 边界情况
 * - 性能影响
 */

// ============================================================
// 5. 💡 面试追问
// ============================================================
/**
 * 💡 深度追问
 * - 为什么这样设计？（设计思想）
 * - 和 XXX 有什么区别？（对比分析）
 * - 实际项目中怎么用？（实战经验）
 * - 有什么缺点/trade-off？（批判性思维）
 * - 如何优化/解决？（解决方案）
 */

// ============================================================
// 6. 🏢 实战场景
// ============================================================
/**
 * 🏢 业务应用
 * - 前端项目中的实际应用
 * - 常见问题排查
 * - 最佳实践
 */
```

### Summary 文件规范

每个章节的 `summary.ts` 应包含：

```typescript
// 🔥🔥🔥 高频必考题（5-8 题）
// - 面试必问，需要能完整回答

// 🔥🔥 进阶深入题（5-8 题）
// - 考察深度，需要理解原理

// 📝 场景题（3-5 题）
// - 考察实战，需要有项目经验

// 🎯 资深追问清单
// - 展示思维深度，体现资深水平

// 📋 面试准备 Checklist
// - 自查清单，确保不遗漏
```

### 内容质量要求

| 维度 | 要求 | 示例 |
|------|------|------|
| **深度** | 不只是 What，更要 Why 和 How | "为什么 typeof null === 'object'？历史原因..." |
| **对比** | 相似概念要对比差异 | "== vs ===、let vs const、Cookie vs Storage" |
| **追问** | 预设面试官可能的追问 | "💡 追问：那如果...怎么办？" |
| **易错** | 标注常见错误和陷阱 | "⚠️ 注意：这里容易忽略..." |
| **实战** | 联系实际业务场景 | "🏢 在 React 项目中，这个问题通常..." |
| **图解** | 复杂流程用图解释 | Mermaid 流程图、ASCII 图示 |

### 资深面试的回答模式

```
标准回答结构：
1. 先给结论（是什么）
2. 再讲原理（为什么）
3. 举例说明（怎么用）
4. 对比分析（vs 其他方案）
5. 注意事项（踩过的坑）
6. 实战经验（项目中如何应用）

示例：
Q: 什么是闭包？

A:
【结论】闭包是函数和其词法环境的组合，让函数能访问外部作用域的变量。

【原理】JS 采用词法作用域，函数定义时就确定了作用域链。即使函数在外部执行，
仍能通过作用域链访问定义时的外部变量。

【示例】防抖函数就是典型应用，timer 变量被闭包保持...

【对比】和全局变量不同，闭包实现了私有化；和类的私有属性相比，更轻量...

【注意】不当使用会导致内存泄漏，特别是在循环中绑定事件时...

【实战】在 React Hooks 中，useCallback 依赖数组就和闭包相关，
如果依赖不正确会获取到旧的 state 值...
```

---

## 🎯 详细内容大纲

### Step 01: JavaScript 核心（资深视角）

```
📁 01-javascript/
├── 01-type-system.ts         # 类型系统深入
│   ├── 类型系统设计哲学（动态类型的优劣）
│   ├── 类型转换的完整规则（ToPrimitive）
│   ├── Symbol 和 BigInt 的设计目的
│   └── 【追问】为什么 typeof null === 'object'？
│
├── 02-scope-closure.ts       # 作用域与闭包
│   ├── 词法作用域 vs 动态作用域（设计选择）
│   ├── 闭包的内存模型
│   ├── 闭包在框架中的应用（React Hooks）
│   └── 【实战】如何排查闭包导致的内存泄漏
│
├── 03-prototype.ts           # 原型系统
│   ├── 为什么 JS 选择原型而非类
│   ├── 原型链的性能影响
│   ├── ES6 class 的本质（语法糖 vs 新特性）
│   └── 【追问】原型继承 vs 类继承的 trade-off
│
├── 04-this.ts                # this 机制
│   ├── this 设计的历史原因
│   ├── 箭头函数的 this 设计考量
│   ├── 严格模式对 this 的影响
│   └── 【实战】React 中 this 丢失问题的多种解法
│
├── 05-event-loop.ts          # 事件循环深入
│   ├── 事件循环的设计目的（单线程 + 非阻塞）
│   ├── 宏任务/微任务的调度时机
│   ├── requestAnimationFrame 和 requestIdleCallback
│   ├── Node.js 事件循环差异及原因
│   └── 【追问】为什么微任务优先级更高？
│
├── 06-async.ts               # 异步编程演进
│   ├── 回调 → Promise → async/await 的演进
│   ├── Generator 与协程
│   ├── async/await 的编译产物
│   └── 【实战】异步错误处理最佳实践
│
├── 07-v8-engine.ts           # V8 引擎原理
│   ├── 解释执行 vs JIT 编译
│   ├── 隐藏类和内联缓存
│   ├── 垃圾回收（新生代/老生代）
│   └── 【实战】如何写出 V8 友好的代码
│
└── summary.ts                # 高频面试题 + 追问清单
```

### Step 02: CSS 深入（资深视角）

```
📁 02-css/
├── 01-layout-system.ts       # 布局系统
│   ├── 正常流、浮动、定位的设计演进
│   ├── Flex 布局算法
│   ├── Grid 布局与二维布局的优势
│   └── 【实战】复杂布局方案选型
│
├── 02-rendering.ts           # 渲染机制
│   ├── 层叠上下文完整规则
│   ├── 合成层与 GPU 加速
│   ├── will-change 的正确使用
│   └── 【追问】为什么 transform 不触发回流？
│
├── 03-responsive.ts          # 响应式架构
│   ├── 移动端适配方案对比
│   ├── 容器查询 vs 媒体查询
│   ├── 响应式设计最佳实践
│   └── 【实战】设计一套适配方案
│
├── 04-css-engineering.ts     # CSS 工程化
│   ├── CSS Modules vs CSS-in-JS vs 原子化
│   ├── 设计系统与 Design Token
│   ├── 主题切换方案
│   └── 【选型】不同方案的 trade-off
│
├── 05-animation.ts           # 动画与性能
│   ├── CSS 动画 vs JS 动画
│   ├── FLIP 动画技术
│   ├── 动画性能优化
│   └── 【实战】高性能动画方案
│
└── summary.ts
```

### Step 03: 浏览器原理（资深视角）

```
📁 03-browser/
├── 01-rendering-pipeline.ts  # 渲染流水线
│   ├── 解析 → 样式 → 布局 → 分层 → 绘制 → 合成
│   ├── 增量渲染与渲染优化
│   ├── 浏览器架构（多进程模型）
│   └── 【追问】为什么 Chrome 用多进程？
│
├── 02-v8-deep.ts             # V8 深入
│   ├── 解析与 AST
│   ├── Ignition 解释器
│   ├── TurboFan 优化编译器
│   ├── 反优化（Deoptimization）
│   └── 【实战】如何避免触发反优化
│
├── 03-memory.ts              # 内存管理
│   ├── 堆内存与栈内存
│   ├── 内存泄漏的常见场景
│   ├── WeakMap/WeakSet 的作用
│   ├── Chrome DevTools 内存分析
│   └── 【实战】内存泄漏排查流程
│
├── 04-security.ts            # 安全深入
│   ├── 同源策略的设计目的
│   ├── XSS 的完整防御体系
│   ├── CSRF 的完整防御体系
│   ├── CSP 配置最佳实践
│   └── 【实战】安全方案设计
│
├── 05-storage.ts             # 存储方案
│   ├── 各存储方案对比与选型
│   ├── IndexedDB 应用场景
│   ├── Service Worker 与离线存储
│   └── 【实战】离线优先架构设计
│
└── summary.ts
```

### Step 04: 网络协议（资深视角）

```
📁 04-network/
├── 01-http-evolution.ts      # HTTP 演进
│   ├── HTTP/1.1 的问题（队头阻塞）
│   ├── HTTP/2 的优化（多路复用、头部压缩）
│   ├── HTTP/3 与 QUIC
│   └── 【追问】为什么 HTTP/2 还会有队头阻塞？
│
├── 02-https-deep.ts          # HTTPS 深入
│   ├── TLS 1.2 vs 1.3
│   ├── 证书链验证
│   ├── HSTS、证书透明度
│   └── 【实战】HTTPS 性能优化
│
├── 03-cache-strategy.ts      # 缓存策略
│   ├── 缓存决策树
│   ├── Service Worker 缓存策略
│   ├── CDN 缓存策略
│   └── 【实战】设计一套缓存方案
│
├── 04-api-design.ts          # API 设计
│   ├── RESTful vs GraphQL vs gRPC
│   ├── BFF 模式
│   ├── API 版本管理
│   └── 【选型】不同场景的 API 方案
│
├── 05-realtime.ts            # 实时通信
│   ├── WebSocket 原理
│   ├── SSE vs WebSocket
│   ├── Socket.IO 原理
│   └── 【实战】实时通信方案选型
│
└── summary.ts
```

### Step 05: 性能优化（系统化）

```
📁 05-performance/
├── 01-metrics.ts             # 性能指标体系
│   ├── Core Web Vitals（LCP、FID、CLS）
│   ├── 自定义业务指标
│   ├── 性能预算
│   └── 【实战】建立性能监控体系
│
├── 02-loading.ts             # 加载性能
│   ├── 关键渲染路径优化
│   ├── 资源优先级（preload、prefetch）
│   ├── 代码分割策略
│   ├── 图片优化完整方案
│   └── 【实战】首屏优化方案
│
├── 03-runtime.ts             # 运行时性能
│   ├── 长任务优化（时间切片）
│   ├── 虚拟列表原理与实现
│   ├── Web Worker 应用
│   └── 【实战】大数据量渲染方案
│
├── 04-rendering.ts           # 渲染性能
│   ├── 减少重排重绘
│   ├── 合成层优化
│   ├── React/Vue 渲染优化
│   └── 【追问】如何定位渲染性能问题？
│
├── 05-monitoring.ts          # 性能监控
│   ├── Performance API
│   ├── 性能数据采集
│   ├── 性能分析平台
│   └── 【实战】搭建性能监控系统
│
├── 06-case-study.ts          # 优化案例
│   ├── 首屏加载优化案例
│   ├── 列表页优化案例
│   ├── 动画卡顿优化案例
│   └── 【方法论】性能优化 checklist
│
└── summary.ts
```

### Step 06: 框架原理（对比视角）

```
📁 06-framework/
├── 01-reactivity.ts          # 响应式对比
│   ├── Vue2 响应式（Object.defineProperty）
│   ├── Vue3 响应式（Proxy）
│   ├── React 状态更新机制
│   ├── Solid.js 细粒度响应式
│   └── 【追问】不同响应式方案的 trade-off
│
├── 02-virtual-dom.ts         # 虚拟 DOM 深入
│   ├── 虚拟 DOM 的真正价值
│   ├── 虚拟 DOM 的代价
│   ├── 无虚拟 DOM 方案（Svelte、Solid）
│   └── 【追问】虚拟 DOM 一定更快吗？
│
├── 03-diff.ts                # Diff 算法对比
│   ├── React Diff（Fiber）
│   ├── Vue2 Diff（双端对比）
│   ├── Vue3 Diff（最长递增子序列）
│   ├── key 的作用与最佳实践
│   └── 【追问】为什么不用最优 Diff？
│
├── 04-scheduler.ts           # 调度机制
│   ├── React Fiber 架构
│   ├── 时间切片原理
│   ├── 优先级调度
│   ├── Vue3 的调度机制
│   └── 【追问】为什么 Vue 不需要 Fiber？
│
├── 05-hooks.ts               # Hooks 深入
│   ├── Hooks 的设计动机
│   ├── Hooks 实现原理（链表）
│   ├── 闭包陷阱与解决方案
│   ├── Vue Composition API 对比
│   └── 【追问】Hooks 的限制为什么存在？
│
├── 06-compiler.ts            # 编译优化
│   ├── Vue3 编译优化（静态提升、patchFlag）
│   ├── React Compiler（React Forget）
│   ├── Svelte 编译时框架
│   └── 【趋势】编译时优化的未来
│
├── 07-ssr.ts                 # 服务端渲染
│   ├── SSR vs CSR vs SSG vs ISR
│   ├── 同构渲染原理
│   ├── 流式渲染
│   ├── Next.js / Nuxt.js 原理
│   └── 【选型】渲染模式选择
│
└── summary.ts                # 框架选型指南
```

### Step 07: 工程化体系

```
📁 07-engineering/
├── 01-build.ts               # 构建工具
│   ├── Webpack 构建流程与原理
│   ├── Vite 原理（ESM + esbuild）
│   ├── Rollup vs Webpack vs Vite
│   ├── esbuild / swc 的崛起
│   └── 【选型】构建工具选择
│
├── 02-module.ts              # 模块化
│   ├── ESM 规范深入
│   ├── 循环依赖处理
│   ├── Tree Shaking 原理与限制
│   └── 【追问】ESM 和 CJS 的本质区别？
│
├── 03-typescript.ts          # TypeScript 进阶
│   ├── 类型体操（实用工具类型实现）
│   ├── 类型编程技巧
│   ├── 声明文件编写
│   ├── TS 编译配置优化
│   └── 【实战】大型项目 TS 最佳实践
│
├── 04-quality.ts             # 质量保障
│   ├── 代码规范（ESLint 规则设计）
│   ├── 单元测试策略
│   ├── E2E 测试策略
│   ├── 代码 Review 机制
│   └── 【实战】质量保障体系设计
│
├── 05-cicd.ts                # CI/CD
│   ├── Git 工作流（Git Flow、Trunk Based）
│   ├── CI 流水线设计
│   ├── 部署策略（蓝绿、金丝雀）
│   ├── 回滚机制
│   └── 【实战】CI/CD 流程设计
│
├── 06-monorepo.ts            # Monorepo
│   ├── Monorepo vs Multirepo
│   ├── pnpm workspace
│   ├── Turborepo / Nx
│   ├── 依赖管理
│   └── 【实战】Monorepo 最佳实践
│
└── summary.ts
```

### Step 08: 手写代码（高质量）

```
📁 08-handwriting/
├── 01-async.ts               # 异步相关
│   ├── Promise（完整实现 + 并发控制）
│   ├── async/await 语法糖模拟
│   ├── 异步调度器
│   └── 重试机制、超时控制
│
├── 02-function.ts            # 函数相关
│   ├── 防抖节流（完整版 + 取消 + 立即执行）
│   ├── 柯里化与偏函数
│   ├── compose / pipe
│   └── memoize（带缓存策略）
│
├── 03-object.ts              # 对象相关
│   ├── 深拷贝（完整版，处理所有类型）
│   ├── 深比较
│   ├── 对象扁平化 / 反扁平化
│   └── immutable 更新
│
├── 04-prototype.ts           # 原型相关
│   ├── new / instanceof
│   ├── Object.create
│   ├── call / apply / bind
│   └── 继承（寄生组合继承）
│
├── 05-design-pattern.ts      # 设计模式
│   ├── 单例模式
│   ├── 发布订阅 / 观察者
│   ├── 装饰器模式
│   └── 策略模式
│
├── 06-data-structure.ts      # 数据结构
│   ├── LRU Cache
│   ├── 链表操作
│   ├── 树遍历
│   └── 堆（优先队列）
│
├── 07-dom.ts                 # DOM 相关
│   ├── 事件委托
│   ├── 虚拟列表
│   ├── 图片懒加载
│   ├── 无限滚动
│   └── 拖拽排序
│
├── 08-framework.ts           # 框架相关
│   ├── 简易响应式系统
│   ├── 简易虚拟 DOM
│   ├── 简易模板引擎
│   └── 简易路由
│
└── summary.ts                # 手写代码清单
```

### Step 09: 架构设计（资深核心）

```
📁 09-architecture/
├── 01-frontend-arch.ts       # 前端架构
│   ├── 分层架构设计
│   ├── 状态管理架构
│   ├── 组件设计原则
│   └── 【实战】大型项目架构设计
│
├── 02-micro-frontend.ts      # 微前端
│   ├── 微前端的适用场景
│   ├── 实现方案对比（qiankun、Module Federation、iframe）
│   ├── 沙箱隔离原理
│   ├── 样式隔离方案
│   ├── 通信机制
│   └── 【实战】微前端架构设计
│
├── 03-cross-platform.ts      # 跨端方案
│   ├── React Native / Flutter / Weex
│   ├── 小程序架构
│   ├── Electron / Tauri
│   ├── 跨端方案选型
│   └── 【追问】不同跨端方案的 trade-off
│
├── 04-bff.ts                 # BFF 层
│   ├── BFF 的价值
│   ├── GraphQL 实践
│   ├── Node.js BFF 设计
│   └── 【实战】BFF 层架构设计
│
├── 05-design-system.ts       # 设计系统
│   ├── Design Token 体系
│   ├── 组件库设计原则
│   ├── 主题系统设计
│   └── 【实战】设计系统建设
│
├── 06-system-design.ts       # 系统设计题
│   ├── 设计一个富文本编辑器
│   ├── 设计一个实时协作系统
│   ├── 设计一个直播弹幕系统
│   ├── 设计一个图片裁剪上传组件
│   └── 【方法论】系统设计答题框架
│
└── summary.ts
```

### Step 10: 领域深耕（选择 1-2 个）

```
📁 10-domain/
├── 01-visualization/         # 可视化
│   ├── Canvas vs SVG vs WebGL
│   ├── 可视化引擎（ECharts、D3、Three.js）
│   ├── 大数据量可视化
│   ├── 地图可视化
│   └── 3D 可视化
│
├── 02-lowcode/               # 低代码
│   ├── 低代码平台架构
│   ├── 可视化搭建原理
│   ├── 组件协议设计
│   ├── 出码能力
│   └── Schema 设计
│
├── 03-editor/                # 编辑器
│   ├── 富文本编辑器原理
│   ├── contentEditable vs 自绘
│   ├── 协同编辑（OT / CRDT）
│   ├── 编辑器架构设计
│   └── 实时协作
│
├── 04-hybrid/                # 混合开发
│   ├── JSBridge 原理
│   ├── 离线包方案
│   ├── 性能优化
│   └── 容器化方案
│
├── 05-node/                  # Node.js
│   ├── Node.js 架构
│   ├── 异步 IO 原理
│   ├── 进程管理
│   ├── 性能优化
│   └── SSR 服务设计
│
└── summary.ts
```

### Step 11: 工程体系（团队视角）

```
📁 11-system/
├── 01-efficiency.ts          # 研发效能
│   ├── 开发提效工具链
│   ├── CLI 脚手架设计
│   ├── 代码生成
│   ├── 物料市场
│   └── 【实战】提效方案设计
│
├── 02-standard.ts            # 规范体系
│   ├── 代码规范（制定与落地）
│   ├── Git 规范
│   ├── 文档规范
│   ├── API 规范
│   └── 【实战】规范体系建设
│
├── 03-quality-system.ts      # 质量体系
│   ├── 代码质量度量
│   ├── 测试覆盖率
│   ├── 线上质量监控
│   ├── 故障复盘机制
│   └── 【实战】质量体系建设
│
├── 04-monitoring.ts          # 监控体系
│   ├── 错误监控
│   ├── 性能监控
│   ├── 业务监控
│   ├── 告警机制
│   └── 【实战】监控体系建设
│
├── 05-security.ts            # 安全体系
│   ├── 安全编码规范
│   ├── 安全扫描
│   ├── 供应链安全
│   └── 【实战】安全体系建设
│
└── summary.ts
```

### Step 12: 技术领导力

```
📁 12-leadership/
├── 01-tech-vision.ts         # 技术规划
│   ├── 技术调研方法论
│   ├── 技术选型决策
│   ├── 技术路线规划
│   └── 技术债务管理
│
├── 02-team.ts                # 团队管理
│   ├── 团队梯队建设
│   ├── 新人培养
│   ├── 代码 Review 文化
│   ├── 技术分享机制
│   └── 1on1 技巧
│
├── 03-influence.ts           # 技术影响力
│   ├── 技术博客写作
│   ├── 开源项目
│   ├── 技术演讲
│   └── 专利/论文
│
├── 04-communication.ts       # 跨团队协作
│   ├── 与产品协作
│   ├── 与后端协作
│   ├── 向上管理
│   └── 跨部门推动
│
├── 05-project.ts             # 项目推动
│   ├── 技术方案评审
│   ├── 风险识别与应对
│   ├── 复盘方法论
│   └── 项目管理技巧
│
└── summary.ts
```

---

## 📈 学习进度

### 基础篇
- [x] Step 01: JavaScript 核心 ✅
- [x] Step 02: CSS 深入 ✅
- [x] Step 03: 浏览器原理 ✅
- [x] Step 04: 网络协议 ✅

### 进阶篇
- [x] Step 05: 性能优化 ✅
- [x] Step 06: 框架原理 ✅
- [x] Step 07: 工程化体系 ✅
- [x] Step 08: 手写代码 ✅

### 高级篇
- [ ] Step 09: 架构设计
- [ ] Step 10: 领域深耕
- [ ] Step 11: 工程体系
- [ ] Step 12: 技术领导力

---

## 🎯 资深面试特点

### 面试考察重点转变

```
┌─────────────────────────────────────────────────────────────────────────┐
│                       初中级 vs 资深 面试差异                             │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│   初中级                              资深                              │
│   ──────                              ────                              │
│   • 知道是什么                         • 知道为什么这样设计               │
│   • 会用框架 API                       • 懂框架原理，能对比选型           │
│   • 能完成功能                         • 能设计方案，考虑扩展性           │
│   • 知道有性能问题                     • 有完整的性能优化方法论           │
│   • 能写代码                           • 能设计架构、带人、推动项目       │
│                                                                         │
│                    【核心差异：从执行者到设计者】                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 面试问答技巧

```
1️⃣ 先给结论 ──► 2️⃣ 分点阐述 ──► 3️⃣ 举例说明 ──► 4️⃣ 对比思考
     │               │               │               │
   总结能力        条理清晰        结合实践        深度思考
```

### 常见追问方向

- **为什么**：为什么这样设计？为什么选这个方案？
- **对比**：不同方案的 trade-off？
- **实践**：你在项目中是怎么做的？遇到什么问题？
- **边界**：这个方案的局限性？什么场景不适用？
- **演进**：技术是怎么演进的？未来趋势？

---

## 🔗 推荐资源

### 技术深度
- [V8 官方博客](https://v8.dev/blog)
- [Chrome 开发者文档](https://developer.chrome.com/)
- [React 官方博客](https://react.dev/blog)
- [Vue 设计与实现](https://book.douban.com/subject/35768338/)

### 架构设计
- [前端架构师成长指南](https://juejin.cn/)
- [系统设计面试](https://github.com/donnemartin/system-design-primer)

### 领导力
- [技术领导力：程序员如何才能带团队](https://book.douban.com/)
- [Staff Engineer](https://staffeng.com/)

---
