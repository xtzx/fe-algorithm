/**
 * ============================================================
 * 📚 性能优化 - 高频面试题汇总
 * ============================================================
 *
 * 按照面试频率和难度进行分类
 * 包含常见追问和易错点
 */

// ============================================================
// 🔥🔥🔥 高频必考题
// ============================================================

/**
 * 1. 什么是 Core Web Vitals？如何优化？
 *
 * Core Web Vitals 是 Google 定义的核心用户体验指标：
 *
 * LCP（Largest Contentful Paint）- 最大内容绘制
 * - 标准：≤ 2.5s
 * - 优化：预加载关键资源、优化图片、减少阻塞
 *
 * INP（Interaction to Next Paint）- 交互响应
 * - 标准：≤ 200ms
 * - 优化：减少长任务、优化事件处理、Web Worker
 *
 * CLS（Cumulative Layout Shift）- 布局稳定性
 * - 标准：≤ 0.1
 * - 优化：图片设置尺寸、预留广告位、字体优化
 *
 * ⚠️ 易错点：
 * - INP 在 2024 年取代 FID
 * - CLS 是累积值，不是单次
 *
 * 💡 追问：实验室数据和真实用户数据有什么区别？
 * - 实验室：Lighthouse，可控环境，可复现
 * - 真实：RUM，真实设备和网络，反映实际体验
 */

/**
 * 2. 首屏优化有哪些手段？
 *
 * 减少资源体积：
 * - 代码压缩（Gzip/Brotli）
 * - Tree Shaking
 * - 图片压缩 + WebP
 *
 * 减少请求数量：
 * - 代码分割 + 懒加载
 * - 合理的 splitChunks
 *
 * 优化加载顺序：
 * - CSS 放 head，JS 放 body 底部
 * - 关键资源 preload
 * - 非关键资源 defer
 *
 * 利用缓存：
 * - 强缓存（contenthash）
 * - CDN 加速
 *
 * 服务端优化：
 * - SSR/SSG
 * - 边缘渲染
 *
 * ⚠️ 易错点：
 * - preload 滥用反而抢占带宽
 * - 首屏内容不要懒加载
 *
 * 💡 追问：如何量化首屏优化效果？
 * - 对比优化前后 LCP、FCP
 * - 关注 P75、P95，不只是平均值
 */

/**
 * 3. 什么是回流和重绘？如何优化？
 *
 * 回流（Reflow）：计算几何属性（位置、大小）
 * - 触发：尺寸、位置、内容变化
 *
 * 重绘（Repaint）：绘制外观（颜色、背景）
 * - 触发：外观变化，不影响布局
 *
 * 回流必触发重绘，重绘不一定触发回流
 *
 * 优化：
 * - 使用 transform/opacity 做动画
 * - 批量修改 DOM
 * - 避免强制同步布局
 * - 使用 will-change 提示
 *
 * ⚠️ 易错点：
 * - 读取 offsetTop 等会强制同步布局
 * - will-change 过度使用消耗内存
 *
 * 💡 追问：为什么 transform 性能好？
 * - transform 在合成层处理，GPU 加速
 * - 不影响文档流，不触发回流
 */

/**
 * 4. 防抖和节流的区别？如何选择？
 *
 * 防抖（Debounce）：
 * - 延迟执行，期间再触发则重新计时
 * - 只执行最后一次
 * - 场景：搜索框输入、窗口 resize
 *
 * 节流（Throttle）：
 * - 固定间隔执行一次
 * - 场景：滚动事件、拖拽、游戏循环
 *
 * ⚠️ 易错点：
 * - 时间设置：150-300ms 比较合适
 * - 组件卸载时要清理定时器
 *
 * 💡 追问：lodash 的 throttle 实现原理？
 * - 实际是带 maxWait 的 debounce
 * - 兼具防抖和节流的特点
 */

/**
 * 5. 如何优化图片加载？
 *
 * 格式选择：
 * - JPEG：照片
 * - PNG：透明图
 * - WebP：通用（比 JPEG 小 25-35%）
 * - AVIF：最新格式，更小
 *
 * 响应式图片：
 * - srcset + sizes
 * - <picture> 元素
 *
 * 懒加载：
 * - loading="lazy"
 * - Intersection Observer
 *
 * 压缩：
 * - 构建时自动压缩
 * - 在线工具压缩
 *
 * ⚠️ 易错点：
 * - 首屏图片不要懒加载
 * - 图片要设置尺寸防止 CLS
 *
 * 💡 追问：loading="lazy" 的原理？
 * - 浏览器原生支持
 * - 基于 Intersection Observer
 * - 接近视口时才加载
 */

// ============================================================
// 🔥🔥 进阶深入题
// ============================================================

/**
 * 6. 虚拟滚动的原理？
 *
 * 原理：只渲染可视区域的元素
 *
 * 实现：
 * 1. 容器固定高度，overflow: auto
 * 2. 占位元素撑起总高度
 * 3. 计算可视区域的起始/结束索引
 * 4. 只渲染这部分元素
 * 5. 使用 transform 定位
 *
 * ⚠️ 注意：
 * - 需要处理滚动性能
 * - 动态高度更复杂
 *
 * 💡 追问：动态高度如何处理？
 * - 预估高度 + 实际高度缓存
 * - 滚动时动态调整
 */

/**
 * 7. Web Worker 的使用场景和限制？
 *
 * 场景：
 * - CPU 密集计算
 * - 大数据处理
 * - 图像处理
 *
 * 限制：
 * - 无法访问 DOM
 * - 无法访问 window
 * - 数据通过消息传递（结构化克隆）
 *
 * ⚠️ 注意：
 * - 通信开销可能抵消收益
 * - 小任务不值得用 Worker
 *
 * 💡 追问：Transferable Objects 是什么？
 * - 可以转移所有权而不是克隆
 * - ArrayBuffer、MessagePort 等
 * - 零拷贝传输
 */

/**
 * 8. 如何建立性能监控体系？
 *
 * 数据采集：
 * - Performance API
 * - web-vitals 库
 * - 自定义埋点
 *
 * 数据上报：
 * - sendBeacon（确保发送）
 * - 采样率控制
 *
 * 数据分析：
 * - 分维度（设备、网络、地域）
 * - 分位数（P50、P75、P95）
 *
 * 告警：
 * - 阈值告警
 * - 环比告警
 *
 * ⚠️ 注意：
 * - 采样率要合理（5%-10%）
 * - 要看分位数，不只是平均值
 *
 * 💡 追问：为什么用 sendBeacon？
 * - 页面卸载时仍能发送
 * - 不阻塞页面关闭
 * - 浏览器保证发送
 */

/**
 * 9. preload 和 prefetch 的区别？
 *
 * preload：
 * - 高优先级
 * - 当前页面一定要用
 * - 抢占带宽
 *
 * prefetch：
 * - 低优先级
 * - 下个页面可能用
 * - 空闲时加载
 *
 * ⚠️ 注意：
 * - preload 3s 内未使用会警告
 * - 字体需要 crossorigin 即使同源
 *
 * 💡 追问：还有哪些资源提示？
 * - dns-prefetch：预解析 DNS
 * - preconnect：预建立连接
 */

/**
 * 10. 长任务如何优化？
 *
 * 检测：
 * - PerformanceObserver（longtask）
 * - Chrome DevTools
 *
 * 优化：
 * - 任务分片（requestIdleCallback）
 * - 时间切片（每 5ms 让出主线程）
 * - Web Worker
 * - 防抖节流
 *
 * ⚠️ 注意：
 * - 长任务 > 50ms
 * - requestIdleCallback 可能长时间不调用
 *
 * 💡 追问：React 的时间切片原理？
 * - Fiber 架构
 * - 任务拆分成小单元
 * - 使用 MessageChannel 调度
 */

// ============================================================
// 📝 场景题
// ============================================================

/**
 * 场景 1：设计一个首页性能优化方案
 *
 * 分析阶段：
 * 1. Lighthouse 分析
 * 2. 真实用户数据分析
 * 3. 定位瓶颈
 *
 * 优化阶段：
 * 1. 关键资源 preload
 * 2. 非关键资源懒加载
 * 3. 图片优化（WebP、压缩、响应式）
 * 4. JS 分割 + defer
 * 5. CDN 加速
 *
 * 验证阶段：
 * 1. A/B 测试
 * 2. 监控数据对比
 */

/**
 * 场景 2：大列表页面卡顿如何解决？
 *
 * 分析：
 * - DOM 节点过多
 * - 滚动事件频繁
 *
 * 解决：
 * 1. 虚拟滚动
 * 2. 节流滚动事件
 * 3. 使用 transform 替代 top
 * 4. 减少重渲染
 */

/**
 * 场景 3：如何实现 60fps 动画？
 *
 * 原则：
 * 1. 只用 transform/opacity
 * 2. 使用 requestAnimationFrame
 * 3. 避免布局抖动
 * 4. 合理使用 will-change
 *
 * 检测：
 * - Chrome Performance 面板
 * - FPS meter
 */

// ============================================================
// 🎯 资深追问清单
// ============================================================

/**
 * 追问 1：HTTP/2 对性能优化策略的影响？
 *
 * 变化：
 * - 不再需要合并请求
 * - 雪碧图不再必要
 * - 域名拆分反而有害
 *
 * 原因：
 * - 多路复用
 * - 头部压缩
 * - 一个连接可发多个请求
 */

/**
 * 追问 2：如何做性能预算？
 *
 * 定义：
 * - JS 总大小 < 200KB
 * - LCP < 2.5s
 * - TTI < 3.8s
 *
 * 实施：
 * - CI 检查
 * - 超标阻止合并
 */

/**
 * 追问 3：SSR/SSG 的性能收益？
 *
 * SSR（Server Side Rendering）：
 * - 首屏快（HTML 直出）
 * - SEO 好
 * - 服务器压力大
 *
 * SSG（Static Site Generation）：
 * - 性能最好（纯静态）
 * - CDN 缓存
 * - 适合内容不变的页面
 *
 * ISR（Incremental Static Regeneration）：
 * - 结合 SSG 和 SSR
 * - 按需重新生成
 */

/**
 * 追问 4：性能和用户体验如何平衡？
 *
 * 原则：
 * - 感知性能有时比实际性能重要
 * - 骨架屏、进度条改善体验
 * - 乐观更新提升响应感
 *
 * 举例：
 * - 图片渐进加载（blur → clear）
 * - 按钮立即反馈，后台处理
 */

// ============================================================
// 📋 面试准备 Checklist
// ============================================================

/**
 * ✅ 指标体系
 *    - [ ] Core Web Vitals（LCP/INP/CLS）
 *    - [ ] 其他指标（FCP/TTFB/TTI/TBT）
 *    - [ ] 如何采集和上报
 *
 * ✅ 加载优化
 *    - [ ] 资源预加载（preload/prefetch）
 *    - [ ] 代码分割和懒加载
 *    - [ ] 图片优化
 *    - [ ] 缓存策略
 *
 * ✅ 渲染优化
 *    - [ ] 回流重绘原理
 *    - [ ] 合成层和 GPU 加速
 *    - [ ] 动画性能
 *    - [ ] 虚拟滚动
 *
 * ✅ 运行时优化
 *    - [ ] 防抖节流
 *    - [ ] 任务分片
 *    - [ ] Web Worker
 *
 * ✅ 监控体系
 *    - [ ] 数据采集方案
 *    - [ ] 告警策略
 *    - [ ] 性能分析
 */

export {};

