/**
 * ============================================================
 * 📚 框架原理 - 高频面试题汇总
 * ============================================================
 *
 * 按照面试频率和难度进行分类
 * 包含常见追问和易错点
 */

// ============================================================
// 🔥🔥🔥 高频必考题
// ============================================================

/**
 * 1. 虚拟 DOM 是什么？有什么优势？
 *
 * 定义：用 JS 对象描述真实 DOM 结构
 *
 * 优势：
 * - 批量更新，减少 DOM 操作
 * - Diff 算法找出最小变更
 * - 跨平台能力
 * - 声明式编程体验
 *
 * ⚠️ 易错点：
 * - 虚拟 DOM 不一定比直接操作 DOM 快
 * - 简单场景直接操作 DOM 更快
 * - 优势在于复杂场景和开发体验
 *
 * 💡 追问：虚拟 DOM 一定比直接操作 DOM 快吗？
 * 不一定。虚拟 DOM 有额外的创建和 Diff 开销。
 * 主要价值是声明式编程和跨平台。
 */

/**
 * 2. React 和 Vue 的 Diff 算法有什么区别？
 *
 * React：
 * - 单向从左到右遍历
 * - 记录 lastIndex，判断是否移动
 * - 只会把节点往右移
 *
 * Vue2：
 * - 双端对比
 * - 四个指针从两端向中间收缩
 * - 能处理更多移动场景
 *
 * Vue3：
 * - 快速 Diff
 * - 预处理 + 最长递增子序列
 * - 移动次数最少
 *
 * ⚠️ 易错点：
 * - 头部插入时 React 性能差
 * - Vue3 的 LIS 是 O(n log n)
 *
 * 💡 追问：为什么不推荐用 index 作为 key？
 * - index 会随列表变化而变化
 * - 导致错误的节点复用
 * - 可能导致状态错乱
 */

/**
 * 3. Vue2 和 Vue3 的响应式有什么区别？
 *
 * Vue2（defineProperty）：
 * - 需要递归遍历所有属性
 * - 无法检测属性添加/删除
 * - 数组需要重写方法
 *
 * Vue3（Proxy）：
 * - 惰性代理，访问时才处理
 * - 可以检测属性添加/删除
 * - 可以监听数组变化
 *
 * ⚠️ 易错点：
 * - Proxy 不支持 IE
 * - 解构会丢失响应式
 *
 * 💡 追问：Vue3 的 ref 和 reactive 怎么选？
 * - ref：基本类型、需要整体替换的对象
 * - reactive：对象/数组
 */

/**
 * 4. React Hooks 为什么不能在条件语句中使用？
 *
 * 原因：
 * - Hooks 按调用顺序存储在链表中
 * - 条件语句会导致顺序不确定
 * - 顺序变化会导致 Hook 对应错误的状态
 *
 * 规则：
 * - 只在最顶层使用 Hooks
 * - 只在 React 函数中调用
 *
 * ⚠️ 易错点：
 * - 循环中也不能使用
 * - 嵌套函数中也不能使用
 *
 * 💡 追问：Hooks 底层是如何存储状态的？
 * - 链表结构
 * - 每个 Hook 是一个节点
 * - 按顺序遍历读取/更新
 */

/**
 * 5. useEffect 和 useLayoutEffect 的区别？
 *
 * useEffect：
 * - 异步执行
 * - 在浏览器绑定后执行
 * - 不会阻塞渲染
 *
 * useLayoutEffect：
 * - 同步执行
 * - 在 DOM 更新后、浏览器绑定前
 * - 可能阻塞渲染
 * - 适合读取 DOM 布局信息
 *
 * ⚠️ 易错点：
 * - useLayoutEffect 会阻塞渲染
 * - 大部分场景用 useEffect
 *
 * 💡 追问：什么时候用 useLayoutEffect？
 * - 需要读取 DOM 布局
 * - 需要同步修改 DOM
 * - 避免闪烁
 */

// ============================================================
// 🔥🔥 进阶深入题
// ============================================================

/**
 * 6. React Fiber 解决了什么问题？
 *
 * React 15 的问题：
 * - 递归遍历虚拟 DOM
 * - 无法中断
 * - 大组件树导致卡顿
 *
 * Fiber 的解决方案：
 * - 链表结构，可中断
 * - 时间切片
 * - 优先级调度
 *
 * ⚠️ 易错点：
 * - Fiber 不是虚拟 DOM
 * - Commit 阶段不能中断
 *
 * 💡 追问：什么时候会触发时间切片？
 * - 使用 createRoot（并发模式）
 * - 使用 startTransition
 */

/**
 * 7. useState 是同步还是异步更新？
 *
 * React 18 之前：
 * - 事件处理中：异步（批量）
 * - setTimeout/原生事件中：同步
 *
 * React 18 之后：
 * - 默认都是批量异步
 * - 可以用 flushSync 强制同步
 *
 * ⚠️ 易错点：
 * - 异步不是指 setTimeout
 * - 是指批量更新后一起执行
 *
 * 💡 追问：如何获取最新的 state？
 * - 函数式更新：setState(prev => prev + 1)
 * - 使用 ref 存储最新值
 */

/**
 * 8. Vue 的 nextTick 原理？
 *
 * 作用：在 DOM 更新后执行回调
 *
 * 原理：
 * - 利用微任务队列
 * - Promise > MutationObserver > setImmediate > setTimeout
 *
 * 使用场景：
 * - 获取更新后的 DOM
 * - 等待数据渲染完成
 *
 * 💡 追问：为什么用微任务？
 * - 微任务在当前宏任务结束后立即执行
 * - 比 setTimeout 更快
 * - 确保在渲染前执行
 */

/**
 * 9. React 的 useMemo 和 useCallback 的区别？
 *
 * useMemo：
 * - 缓存计算结果
 * - 返回值
 *
 * useCallback：
 * - 缓存函数引用
 * - 返回函数
 * - useCallback(fn, deps) = useMemo(() => fn, deps)
 *
 * ⚠️ 易错点：
 * - 不是所有函数都需要 useCallback
 * - 过度优化反而有开销
 *
 * 💡 追问：什么时候需要 useCallback？
 * - 传递给 memo 包裹的子组件
 * - 作为 useEffect 的依赖
 */

/**
 * 10. computed 和 watch 的区别？
 *
 * computed：
 * - 有返回值
 * - 自动缓存
 * - 同步执行
 * - 多个依赖 → 一个结果
 *
 * watch：
 * - 无返回值（执行副作用）
 * - 不缓存
 * - 可以异步
 * - 一个依赖 → 执行操作
 *
 * 💡 追问：Vue3 的 watchEffect 和 watch 的区别？
 * - watchEffect：自动收集依赖，立即执行
 * - watch：显式指定依赖，默认懒执行
 */

// ============================================================
// 📝 场景题
// ============================================================

/**
 * 场景 1：如何优化大列表渲染？
 *
 * React：
 * - 虚拟滚动（react-window）
 * - memo 避免不必要渲染
 * - useMemo 缓存列表数据
 *
 * Vue：
 * - 虚拟滚动
 * - v-memo 缓存
 * - 使用 shallowRef
 */

/**
 * 场景 2：如何解决闭包陷阱？
 *
 * 问题：useEffect/setTimeout 中获取到旧的 state
 *
 * 解决：
 * - 使用函数式更新
 * - 使用 ref 存储最新值
 * - 正确设置依赖数组
 */

/**
 * 场景 3：如何实现组件通信？
 *
 * React：
 * - props（父子）
 * - Context（跨层级）
 * - 状态管理库（全局）
 *
 * Vue：
 * - props/emit（父子）
 * - provide/inject（跨层级）
 * - Pinia（全局）
 */

// ============================================================
// 🎯 资深追问清单
// ============================================================

/**
 * 追问 1：React 的合成事件是什么？
 *
 * - React 自己实现的事件系统
 * - 事件委托到 root 节点
 * - 跨浏览器兼容
 * - 事件池复用（React 17 移除）
 *
 * 💡 与原生事件的执行顺序？
 * 原生事件（捕获） → 原生事件（冒泡） → 合成事件
 */

/**
 * 追问 2：Vue 的编译优化有哪些？
 *
 * - 静态提升（hoistStatic）
 * - 预字符串化
 * - 缓存事件处理函数
 * - Block Tree + PatchFlags
 * - 静态节点标记
 */

/**
 * 追问 3：React 18 的新特性？
 *
 * - 并发渲染
 * - 自动批量更新
 * - useTransition / useDeferredValue
 * - Suspense 增强
 * - 新的 Root API
 */

/**
 * 追问 4：React Server Components 是什么？
 *
 * - 服务端渲染组件
 * - 减少客户端 JS 体积
 * - 直接访问后端资源
 * - 与 Client Components 配合使用
 */

// ============================================================
// 📋 面试准备 Checklist
// ============================================================

/**
 * ✅ 虚拟 DOM
 *    - [ ] 虚拟 DOM 的概念和优势
 *    - [ ] 为什么需要虚拟 DOM
 *    - [ ] 虚拟 DOM 的局限性
 *
 * ✅ Diff 算法
 *    - [ ] Diff 的核心思想
 *    - [ ] React vs Vue 的 Diff 区别
 *    - [ ] key 的作用
 *
 * ✅ 响应式原理
 *    - [ ] Vue2 defineProperty
 *    - [ ] Vue3 Proxy
 *    - [ ] 依赖收集和派发更新
 *
 * ✅ React Hooks
 *    - [ ] Hooks 的设计思想
 *    - [ ] useState/useEffect 原理
 *    - [ ] Hooks 规则和原因
 *    - [ ] 闭包陷阱
 *
 * ✅ Fiber 架构
 *    - [ ] Fiber 解决的问题
 *    - [ ] 时间切片
 *    - [ ] 双缓冲机制
 *    - [ ] 调度优先级
 */

export {};

