/**
 * ============================================================
 * 📚 浏览器内存管理
 * ============================================================
 *
 * 面试考察重点：
 * 1. 内存模型（堆/栈）
 * 2. 垃圾回收机制
 * 3. 内存泄漏的常见场景
 * 4. 内存问题排查
 */

// ============================================================
// 1. JavaScript 内存模型
// ============================================================

/**
 * 📊 内存结构
 *
 * ┌─────────────────────────────────────────────────────────────────────┐
 * │                           栈内存 (Stack)                            │
 * │  ┌─────────────────────────────────────────────────────────────┐   │
 * │  │ 执行上下文、基本类型值、引用类型的引用（指针）                  │   │
 * │  │ 大小固定，系统自动分配和释放                                   │   │
 * │  │ 后进先出（LIFO）                                              │   │
 * │  └─────────────────────────────────────────────────────────────┘   │
 * └─────────────────────────────────────────────────────────────────────┘
 *
 * ┌─────────────────────────────────────────────────────────────────────┐
 * │                           堆内存 (Heap)                             │
 * │  ┌───────────────────┐  ┌───────────────────┐                      │
 * │  │    新生代 (Young)  │  │    老生代 (Old)    │                      │
 * │  │  ┌──────┬──────┐  │  │                   │                      │
 * │  │  │ From │  To  │  │  │  长期存活的对象    │                      │
 * │  │  └──────┴──────┘  │  │  大对象            │                      │
 * │  │  短期存活的对象    │  │                   │                      │
 * │  └───────────────────┘  └───────────────────┘                      │
 * │                                                                     │
 * │  引用类型的实际数据存储在这里                                         │
 * │  由垃圾回收器管理                                                    │
 * └─────────────────────────────────────────────────────────────────────┘
 */

/**
 * 📊 栈和堆的区别
 *
 * ┌─────────────┬──────────────────────┬──────────────────────┐
 * │   特性       │       栈             │        堆            │
 * ├─────────────┼──────────────────────┼──────────────────────┤
 * │ 存储内容     │ 基本类型、引用        │ 对象、数组           │
 * │ 大小        │ 固定，较小            │ 动态，较大           │
 * │ 分配方式     │ 系统自动分配/释放     │ 程序员控制（GC 回收）│
 * │ 访问速度     │ 快                   │ 较慢                 │
 * │ 内存结构     │ 连续                 │ 不连续               │
 * └─────────────┴──────────────────────┴──────────────────────┘
 */

// 示例
let a = 1; // 栈：直接存储值 1
let b = { x: 1 }; // 栈：存储引用，堆：存储 { x: 1 }
let c = [1, 2, 3]; // 栈：存储引用，堆：存储 [1, 2, 3]

// ============================================================
// 2. 垃圾回收（Garbage Collection）
// ============================================================

/**
 * 📖 垃圾回收的基本概念
 *
 * 垃圾：不再被引用的对象
 * 回收：释放垃圾占用的内存
 *
 * V8 采用分代回收策略：
 * - 新生代：存活时间短的对象
 * - 老生代：存活时间长的对象
 */

/**
 * 📊 新生代回收：Scavenge 算法（复制算法）
 *
 * 新生代分为两个等大的空间：From 和 To
 *
 * 回收过程：
 * 1. 新对象分配在 From 空间
 * 2. GC 时，存活对象复制到 To 空间
 * 3. From 和 To 角色互换
 * 4. 经历多次 GC 仍存活的对象晋升到老生代
 *
 *     GC 前                        GC 后
 * ┌──────┬──────┐              ┌──────┬──────┐
 * │ From │  To  │              │ From │  To  │
 * │ ┌──┐ │      │              │      │ ┌──┐ │
 * │ │A │ │      │     ───►     │      │ │A │ │
 * │ └──┘ │      │              │      │ └──┘ │
 * │ ┌──┐ │      │              │      │      │
 * │ │B │ │      │  (B 是垃圾)   │      │      │
 * │ └──┘ │      │              │      │      │
 * └──────┴──────┘              └──────┴──────┘
 *
 * 优点：简单高效，无内存碎片
 * 缺点：空间利用率 50%
 */

/**
 * 📊 老生代回收：Mark-Sweep + Mark-Compact
 *
 * Mark-Sweep（标记-清除）：
 * 1. 标记阶段：从根对象遍历，标记所有可达对象
 * 2. 清除阶段：清除未标记的对象
 *
 *     标记前                      清除后
 * ┌─────────────────┐        ┌─────────────────┐
 * │ ┌──┐ ┌──┐ ┌──┐ │        │ ┌──┐      ┌──┐ │
 * │ │A●│ │B │ │C●│ │  ───►  │ │A │      │C │ │
 * │ └──┘ └──┘ └──┘ │        │ └──┘      └──┘ │
 * │ ┌──┐ ┌──┐      │        │ ┌──┐           │
 * │ │D●│ │E │      │        │ │D │           │
 * │ └──┘ └──┘      │        │ └──┘           │
 * └─────────────────┘        └─────────────────┘
 *   ● = 标记的存活对象           产生内存碎片
 *
 * Mark-Compact（标记-整理）：
 * 在 Mark-Sweep 基础上，将存活对象移动到一端，消除碎片
 *
 *     整理后
 * ┌─────────────────┐
 * │ ┌──┐┌──┐┌──┐    │
 * │ │A ││C ││D │    │
 * │ └──┘└──┘└──┘    │
 * │                 │
 * │    连续空闲空间  │
 * └─────────────────┘
 */

/**
 * 📊 增量标记（Incremental Marking）
 *
 * 问题：GC 时主线程暂停（Stop-The-World），影响性能
 *
 * 解决方案：增量标记
 * - 将标记过程分成多个小步骤
 * - 与 JavaScript 执行交替进行
 * - 使用三色标记法追踪进度
 *
 * 三色标记：
 * - 白色：未访问
 * - 灰色：已访问，子节点未处理
 * - 黑色：已访问，子节点已处理
 *
 *   JS执行  │标记│ JS执行 │标记│ JS执行 │标记│ 清除
 *  ─────────┼───┼────────┼───┼────────┼───┼─────►
 */

/**
 * 📊 并发标记（Concurrent Marking）
 *
 * V8 6.3+ 引入并发标记：
 * - 标记工作在辅助线程执行
 * - 主线程可以继续执行 JavaScript
 * - 进一步减少主线程暂停时间
 */

// ============================================================
// 3. 内存泄漏
// ============================================================

/**
 * 📖 什么是内存泄漏？
 *
 * 程序不再使用的内存没有被回收，导致内存占用持续增长。
 *
 * 📊 常见内存泄漏场景
 */

// 3.1 意外的全局变量
function leak1() {
  // 没有 var/let/const，成为全局变量
  // @ts-ignore
  leakedVar = 'I am global';

  // this 指向 window
  // @ts-ignore
  this.anotherLeak = 'Also global';
}

// 3.2 被遗忘的定时器
function leak2() {
  const data = { largeData: new Array(1000000) };

  setInterval(() => {
    // 定时器一直引用 data，不会被回收
    console.log(data);
  }, 1000);

  // 忘记清除定时器
}

// ✅ 正确做法
function noLeak2() {
  const data = { largeData: new Array(1000000) };

  const timer = setInterval(() => {
    console.log(data);
  }, 1000);

  // 不需要时清除
  return () => clearInterval(timer);
}

// 3.3 DOM 引用
function leak3() {
  const elements: { button?: HTMLElement | null } = {};

  elements.button = document.getElementById('button');

  document.body.removeChild(elements.button!);
  // DOM 已移除，但 JS 中仍有引用，不会被回收

  // ✅ 正确做法：同时清除 JS 引用
  elements.button = null;
}

// 3.4 闭包
function leak4() {
  const largeData = new Array(1000000).fill('x');

  return function () {
    // 闭包引用了 largeData，即使不使用也不会被回收
    console.log('leaked');
  };
}

// ✅ 正确做法
function noLeak4() {
  let largeData: string[] | null = new Array(1000000).fill('x');
  const result = largeData.length;
  largeData = null; // 使用完立即释放

  return function () {
    console.log(result);
  };
}

// 3.5 事件监听器
function leak5() {
  const handler = () => console.log('clicked');

  window.addEventListener('click', handler);

  // 忘记移除监听器
  // 如果是 SPA，页面切换时监听器累积
}

// ✅ 正确做法
function noLeak5() {
  const handler = () => console.log('clicked');

  window.addEventListener('click', handler);

  // 返回清理函数
  return () => window.removeEventListener('click', handler);
}

// 3.6 Map/Set 中的对象引用
function leak6() {
  const map = new Map();
  const key = { id: 1 };

  map.set(key, 'value');

  // 即使不再需要 key，只要 map 存在，key 就不会被回收
}

// ✅ 使用 WeakMap/WeakSet
function noLeak6() {
  const weakMap = new WeakMap();
  let key: { id: number } | null = { id: 1 };

  weakMap.set(key, 'value');

  key = null; // key 可以被回收
}

// ============================================================
// 4. 内存问题排查
// ============================================================

/**
 * 📊 Chrome DevTools 内存分析工具
 *
 * 1. Memory 面板
 *    - Heap snapshot：堆快照，查看内存中的对象
 *    - Allocation instrumentation：分配时间线
 *    - Allocation sampling：分配采样
 *
 * 2. Performance 面板
 *    - 录制时勾选 Memory
 *    - 观察内存变化曲线
 *    - 定位内存增长点
 *
 * 3. Task Manager（任务管理器）
 *    - 更多工具 → 任务管理器
 *    - 查看每个标签页的内存使用
 */

/**
 * 📊 排查步骤
 *
 * 1. 确认是否有内存泄漏：
 *    - 打开 Task Manager
 *    - 重复操作，观察内存是否持续增长
 *    - 手动点击 GC，内存是否下降
 *
 * 2. 定位泄漏对象：
 *    - 操作前拍快照 A
 *    - 执行可疑操作
 *    - 操作后拍快照 B
 *    - 对比快照，查看 Delta
 *
 * 3. 查找泄漏原因：
 *    - 查看对象的 Retainers（谁引用了它）
 *    - 追踪引用链，找到根源
 *
 * 4. 验证修复：
 *    - 修改代码
 *    - 重复上述步骤确认
 */

/**
 * 📊 常用指标
 *
 * - JS Heap Size：JS 堆大小
 * - DOM Nodes：DOM 节点数量
 * - Event Listeners：事件监听器数量
 * - Documents：文档数量（iframe）
 */

// ============================================================
// 5. WeakMap 和 WeakSet
// ============================================================

/**
 * 📖 为什么需要 WeakMap/WeakSet？
 *
 * Map/Set 持有对象的强引用，阻止垃圾回收。
 * WeakMap/WeakSet 持有弱引用，不阻止垃圾回收。
 *
 * 适用场景：
 * - 存储 DOM 元素的附加数据
 * - 对象的私有数据
 * - 缓存（自动清理）
 */

// 使用 WeakMap 存储 DOM 元素数据
const elementData = new WeakMap<HTMLElement, { clicks: number }>();

function trackClicks(element: HTMLElement) {
  let data = elementData.get(element);
  if (!data) {
    data = { clicks: 0 };
    elementData.set(element, data);
  }
  data.clicks++;
}

// 当 element 从 DOM 移除且没有其他引用时，
// WeakMap 中的条目会自动被清理

// ============================================================
// 6. 高频面试题
// ============================================================

/**
 * 题目 1：V8 的垃圾回收机制？
 *
 * V8 采用分代回收：
 *
 * 新生代（Scavenge 算法）：
 * - 空间分为 From 和 To
 * - 存活对象从 From 复制到 To
 * - 多次存活的对象晋升到老生代
 *
 * 老生代（Mark-Sweep + Mark-Compact）：
 * - 标记-清除：标记存活对象，清除未标记的
 * - 标记-整理：消除内存碎片
 *
 * 优化：
 * - 增量标记：分步进行，减少暂停
 * - 并发标记：辅助线程执行，不阻塞主线程
 */

/**
 * 题目 2：常见的内存泄漏场景？如何避免？
 *
 * 1. 意外的全局变量 → 使用 let/const，开启严格模式
 * 2. 未清除的定时器 → 组件卸载时清除
 * 3. DOM 引用 → 移除 DOM 时清除 JS 引用
 * 4. 闭包 → 及时释放不需要的引用
 * 5. 事件监听器 → 移除不需要的监听器
 * 6. Map/Set → 考虑使用 WeakMap/WeakSet
 */

/**
 * 题目 3：如何排查内存泄漏？
 *
 * 1. 使用 Chrome DevTools Memory 面板
 * 2. 拍摄 Heap Snapshot 对比
 * 3. 查看对象的 Retainers 追踪引用链
 * 4. Performance 面板观察内存曲线
 * 5. 手动 GC 后观察内存是否下降
 */

/**
 * 题目 4：WeakMap 和 Map 的区别？
 *
 * Map：
 * - 键可以是任意值
 * - 强引用，阻止 GC
 * - 可迭代，有 size 属性
 *
 * WeakMap：
 * - 键必须是对象
 * - 弱引用，不阻止 GC
 * - 不可迭代，无 size 属性
 *
 * 使用场景：
 * - 需要自动清理的缓存
 * - 存储 DOM 元素的附加数据
 * - 对象的私有数据
 */

export {
  noLeak2,
  noLeak4,
  noLeak5,
  noLeak6,
  trackClicks,
};

