/**
 * ============================================================
 * 📚 浏览器渲染流水线
 * ============================================================
 *
 * 面试考察重点：
 * 1. 浏览器架构（多进程模型）
 * 2. 从 URL 到页面渲染的完整过程
 * 3. 关键渲染路径
 * 4. 渲染优化策略
 */

// ============================================================
// 1. 浏览器架构
// ============================================================

/**
 * 📊 Chrome 多进程架构
 *
 * ┌─────────────────────────────────────────────────────────────────────┐
 * │                        Browser Process（浏览器主进程）               │
 * │  负责：地址栏、书签、前进后退、网络请求、文件访问                      │
 * └─────────────────────────────────────────────────────────────────────┘
 *          │
 *          ├─────────────────────────────────────────────────────┐
 *          │                                                     │
 *          ▼                                                     ▼
 * ┌─────────────────────┐  ┌─────────────────────┐  ┌─────────────────────┐
 * │  Renderer Process   │  │  Renderer Process   │  │    GPU Process      │
 * │  （渲染进程）        │  │  （渲染进程）        │  │   （GPU 进程）       │
 * │  Tab 1              │  │  Tab 2              │  │  负责 GPU 任务       │
 * │  ┌───────────────┐  │  │  ┌───────────────┐  │  │  绘制、合成          │
 * │  │ Main Thread   │  │  │  │ Main Thread   │  │  └─────────────────────┘
 * │  │ (JS/DOM/CSS)  │  │  │  │               │  │
 * │  ├───────────────┤  │  │  ├───────────────┤  │  ┌─────────────────────┐
 * │  │ Compositor    │  │  │  │ Compositor    │  │  │   Plugin Process    │
 * │  │ Thread        │  │  │  │ Thread        │  │  │  （插件进程）        │
 * │  ├───────────────┤  │  │  ├───────────────┤  │  │  Flash、PDF 等       │
 * │  │ Raster Thread │  │  │  │ Raster Thread │  │  └─────────────────────┘
 * │  └───────────────┘  │  │  └───────────────┘  │
 * └─────────────────────┘  └─────────────────────┘
 *
 * 💡 为什么使用多进程？
 * 1. 稳定性：一个 Tab 崩溃不影响其他 Tab
 * 2. 安全性：沙箱隔离，渲染进程无法直接访问系统资源
 * 3. 性能：充分利用多核 CPU
 */

/**
 * 📊 渲染进程中的线程
 *
 * 1. Main Thread（主线程）
 *    - JavaScript 执行
 *    - DOM 解析
 *    - CSS 解析
 *    - 布局计算
 *    - 绑定事件
 *
 * 2. Compositor Thread（合成线程）
 *    - 接收用户输入（滚动）
 *    - 合成图层
 *    - 不阻塞主线程
 *
 * 3. Raster Thread（光栅化线程）
 *    - 将图层转换为位图
 *    - 可能有多个
 *
 * 4. Worker Threads
 *    - Web Worker
 *    - Service Worker
 */

// ============================================================
// 2. 导航过程
// ============================================================

/**
 * 📊 从输入 URL 到页面显示的完整过程
 *
 * ┌────────────────────────────────────────────────────────────────────┐
 * │ 1. 用户输入 URL                                                    │
 * │    └─► 浏览器进程 UI 线程处理输入                                   │
 * │        └─► 判断是搜索还是 URL                                       │
 * └────────────────────────────────────────────────────────────────────┘
 *                              │
 *                              ▼
 * ┌────────────────────────────────────────────────────────────────────┐
 * │ 2. URL 请求                                                        │
 * │    └─► DNS 解析（域名 → IP）                                        │
 * │        └─► 建立 TCP 连接（三次握手）                                │
 * │            └─► TLS 握手（HTTPS）                                    │
 * │                └─► 发送 HTTP 请求                                   │
 * │                    └─► 接收响应                                     │
 * └────────────────────────────────────────────────────────────────────┘
 *                              │
 *                              ▼
 * ┌────────────────────────────────────────────────────────────────────┐
 * │ 3. 响应处理                                                        │
 * │    └─► 检查响应类型（Content-Type）                                 │
 * │        ├─► HTML → 准备渲染进程                                     │
 * │        ├─► 文件下载 → 下载管理器                                   │
 * │        └─► 其他 → 对应处理                                         │
 * └────────────────────────────────────────────────────────────────────┘
 *                              │
 *                              ▼
 * ┌────────────────────────────────────────────────────────────────────┐
 * │ 4. 提交导航                                                        │
 * │    └─► 浏览器进程 → 渲染进程（IPC）                                  │
 * │        └─► 确认提交（开始渲染）                                     │
 * │            └─► 更新地址栏、安全状态、历史记录                        │
 * └────────────────────────────────────────────────────────────────────┘
 *                              │
 *                              ▼
 * ┌────────────────────────────────────────────────────────────────────┐
 * │ 5. 渲染阶段（详见下节）                                             │
 * └────────────────────────────────────────────────────────────────────┘
 */

// ============================================================
// 3. 渲染流水线
// ============================================================

/**
 * 📊 关键渲染路径（Critical Rendering Path）
 *
 * ┌─────────┐   ┌─────────┐   ┌─────────┐   ┌─────────┐   ┌─────────┐   ┌─────────┐
 * │  Parse  │──►│  Style  │──►│ Layout  │──►│  Layer  │──►│  Paint  │──►│Composite│
 * │  HTML   │   │ Compute │   │         │   │  Tree   │   │         │   │         │
 * └─────────┘   └─────────┘   └─────────┘   └─────────┘   └─────────┘   └─────────┘
 *     │              │             │             │             │             │
 *     ▼              ▼             ▼             ▼             ▼             ▼
 *   DOM树        CSSOM树       布局树        图层树       绘制指令      最终画面
 *               + 渲染树       (位置大小)    (分层)      (绘制记录)    (GPU合成)
 */

/**
 * 📊 Step 1: 解析 HTML → DOM 树
 *
 * 字节流 → 字符 → Token → 节点 → DOM 树
 *
 * <html>                          Document
 *   <head>                           │
 *     <title>Hi</title>         ┌────┴────┐
 *   </head>                   html
 *   <body>                      │
 *     <p>Hello</p>        ┌─────┴─────┐
 *   </body>              head        body
 * </html>                 │           │
 *                       title        p
 *                         │           │
 *                       "Hi"      "Hello"
 *
 * 特点：
 * - 增量构建（边接收边解析）
 * - 遇到 <script> 会阻塞解析（除非 async/defer）
 * - 预解析器会预先下载 CSS/JS/图片
 */

/**
 * 📊 Step 2: 解析 CSS → CSSOM 树
 *
 * CSS 来源：
 * - <link> 外部样式表
 * - <style> 内部样式
 * - style 属性内联样式
 * - 浏览器默认样式
 *
 * 特点：
 * - CSS 是渲染阻塞资源
 * - 必须完整下载和解析
 * - 不会增量构建
 */

/**
 * 📊 Step 3: 样式计算 → 渲染树（Render Tree）
 *
 * DOM + CSSOM = 渲染树
 *
 * 过程：
 * 1. 遍历 DOM 树的每个可见节点
 * 2. 对每个节点，找到匹配的 CSS 规则
 * 3. 计算最终样式（继承、层叠、默认值）
 *
 * 注意：
 * - display: none 的元素不在渲染树中
 * - visibility: hidden 的元素在渲染树中
 * - 伪元素（::before）在渲染树中，不在 DOM 树中
 */

/**
 * 📊 Step 4: 布局（Layout / Reflow）
 *
 * 计算每个节点的几何信息：
 * - 位置（x, y）
 * - 大小（width, height）
 *
 * 布局树（Layout Tree）与渲染树不完全对应：
 * - display: contents 在渲染树中，不在布局树中
 * - 匿名块/行盒会创建额外节点
 *
 * 触发布局的操作：
 * - 首次渲染
 * - 视口大小变化
 * - 元素尺寸/位置变化
 * - 添加/删除元素
 * - 读取某些属性（offsetWidth、scrollTop 等）
 */

/**
 * 📊 Step 5: 分层（Layer）
 *
 * 将页面分割成多个图层，便于：
 * - 局部更新（只更新变化的图层）
 * - GPU 加速
 *
 * 创建新图层的条件：
 * - position: fixed/sticky
 * - transform/opacity 动画
 * - will-change
 * - <video>、<canvas>、<iframe>
 * - 3D 变换
 * - filter
 *
 * 注意：过多图层会增加内存消耗
 */

/**
 * 📊 Step 6: 绘制（Paint）
 *
 * 主线程遍历布局树，生成绘制记录（Paint Records）。
 * 绘制记录是一系列绘制指令，如：
 * - 画背景
 * - 画边框
 * - 画文字
 * - 画图片
 *
 * 绘制顺序（Stacking Order）：
 * 1. 背景
 * 2. 边框
 * 3. 后代元素（按层叠上下文顺序）
 */

/**
 * 📊 Step 7: 合成（Composite）
 *
 * 1. 光栅化（Rasterize）：
 *    - 将图层转换为位图
 *    - 由 Raster 线程在 GPU 上执行
 *    - 分块处理（Tiles），优先处理视口内的
 *
 * 2. 合成（Composite）：
 *    - 将所有图层按正确顺序合成
 *    - 由 Compositor 线程执行
 *    - 生成 Compositor Frame
 *    - 提交给 GPU 显示
 *
 * 优势：
 * - 合成在独立线程，不阻塞主线程
 * - 纯合成操作（transform、opacity）性能最好
 */

// ============================================================
// 4. 渲染优化
// ============================================================

/**
 * 📊 减少关键资源
 *
 * 1. 减少阻塞渲染的 CSS：
 *    - 内联关键 CSS
 *    - 异步加载非关键 CSS
 *    - 使用媒体查询拆分
 *
 * 2. 减少阻塞解析的 JS：
 *    - 使用 async/defer
 *    - 将脚本放在 body 底部
 *    - 代码分割
 */

/**
 * 📊 async vs defer
 *
 *           HTML解析  ─────────────────────────────────────────►
 *
 * 普通脚本   ══════│停止├──下载──├──执行──├═══════════════════════►
 *
 * async     ══════├──下载──├│停止├──执行──├════════════════════►
 *                 （下载时不阻塞，下载完立即执行）
 *
 * defer     ══════├──下载────────────────├│停止├──执行──├═══════►
 *                 （下载时不阻塞，DOMContentLoaded 前执行）
 *
 * 区别：
 * - async：下载完立即执行，不保证顺序
 * - defer：DOMContentLoaded 前按顺序执行
 */

const scriptLoading = `
  <!-- 普通脚本：阻塞解析 -->
  <script src="main.js"></script>

  <!-- async：异步下载，下载完立即执行 -->
  <!-- 适合：独立脚本（统计、广告） -->
  <script async src="analytics.js"></script>

  <!-- defer：异步下载，DOMContentLoaded 前执行 -->
  <!-- 适合：需要 DOM 的脚本 -->
  <script defer src="app.js"></script>

  <!-- module：默认 defer 行为 -->
  <script type="module" src="module.js"></script>
`;

/**
 * 📊 优化关键渲染路径
 *
 * 1. 减少关键资源数量
 * 2. 减少关键资源大小
 * 3. 减少关键路径长度（往返次数）
 *
 * 工具：
 * - Chrome DevTools → Performance
 * - Lighthouse
 * - WebPageTest
 */

// ============================================================
// 5. 高频面试题
// ============================================================

/**
 * 题目 1：从输入 URL 到页面显示，发生了什么？
 *
 * 1. URL 解析：判断是搜索还是 URL
 * 2. DNS 解析：域名 → IP 地址
 * 3. TCP 连接：三次握手
 * 4. TLS 握手：（HTTPS）
 * 5. HTTP 请求：发送请求，接收响应
 * 6. 解析 HTML：构建 DOM 树
 * 7. 解析 CSS：构建 CSSOM 树
 * 8. 样式计算：DOM + CSSOM → 渲染树
 * 9. 布局：计算几何信息
 * 10. 分层：创建图层树
 * 11. 绘制：生成绘制指令
 * 12. 合成：合成图层，显示到屏幕
 */

/**
 * 题目 2：为什么 CSS 放 head，JS 放 body 底部？
 *
 * CSS 放 head：
 * - CSS 是渲染阻塞资源
 * - 尽早下载可以更快开始渲染
 * - 避免无样式内容闪烁（FOUC）
 *
 * JS 放 body 底部：
 * - JS 阻塞 HTML 解析
 * - 放底部可以先显示页面内容
 * - JS 通常需要操作 DOM，放底部确保 DOM 已就绪
 *
 * 现代方案：
 * - CSS：内联关键 CSS，异步加载其余
 * - JS：使用 defer/async
 */

/**
 * 题目 3：什么是重绘和回流？如何优化？
 *
 * 回流（Reflow/Layout）：
 * - 重新计算元素几何属性
 * - 触发：尺寸、位置、内容变化
 *
 * 重绘（Repaint）：
 * - 重新绘制元素外观
 * - 触发：颜色、背景、阴影变化
 *
 * 回流必触发重绘，重绘不一定触发回流
 *
 * 优化：
 * - 使用 transform/opacity（只触发合成）
 * - 批量修改 DOM
 * - 缓存布局信息
 * - 使用 documentFragment
 * - 脱离文档流后修改
 */

/**
 * 题目 4：浏览器是多进程还是多线程？
 *
 * Chrome 是多进程架构：
 * - Browser 进程：主进程，管理界面、网络
 * - Renderer 进程：每个 Tab 一个（通常），负责渲染
 * - GPU 进程：处理 GPU 任务
 * - Plugin 进程：插件
 *
 * 每个 Renderer 进程有多个线程：
 * - Main Thread：JS、DOM、CSS、布局
 * - Compositor Thread：合成
 * - Raster Threads：光栅化
 * - Worker Threads：Web Worker
 *
 * 优点：
 * - 稳定：一个 Tab 崩溃不影响其他
 * - 安全：沙箱隔离
 * - 性能：利用多核
 */

export { scriptLoading };

