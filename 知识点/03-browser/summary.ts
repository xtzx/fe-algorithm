/**
 * ============================================================
 * 📚 浏览器原理 - 高频面试题汇总
 * ============================================================
 *
 * 按照面试频率和难度进行分类
 */

// ============================================================
// 🔥🔥🔥 高频必考题
// ============================================================

/**
 * 1. 从输入 URL 到页面显示，发生了什么？
 *
 * 1. URL 解析：判断是搜索还是 URL
 * 2. DNS 解析：域名 → IP 地址
 *    - 浏览器缓存 → 系统缓存 → 路由器缓存 → ISP DNS → 根 DNS
 * 3. TCP 连接：三次握手
 * 4. TLS 握手：HTTPS 时建立安全连接
 * 5. HTTP 请求：发送请求报文
 * 6. 服务器处理：返回响应
 * 7. 解析 HTML：构建 DOM 树
 * 8. 解析 CSS：构建 CSSOM 树
 * 9. 样式计算：生成渲染树
 * 10. 布局：计算几何信息
 * 11. 分层：创建图层树
 * 12. 绘制：生成绘制指令
 * 13. 合成：合成图层，显示
 */

/**
 * 2. 什么是重绘和回流？如何优化？
 *
 * 回流（Reflow/Layout）：
 * - 计算元素几何属性（位置、大小）
 * - 触发：尺寸、位置、内容变化
 *
 * 重绘（Repaint）：
 * - 绘制元素外观（颜色、背景）
 * - 触发：颜色、阴影变化
 *
 * 回流必触发重绘，重绘不一定触发回流
 *
 * 优化：
 * - 使用 transform/opacity 做动画
 * - 批量修改 DOM（documentFragment）
 * - 缓存布局信息
 * - 脱离文档流后修改
 * - 使用 will-change
 */

/**
 * 3. V8 执行 JavaScript 的过程？
 *
 * 1. 解析（Parser）：源码 → AST
 * 2. 解释（Ignition）：AST → 字节码 → 执行
 * 3. 优化（TurboFan）：热点代码 → 机器码
 * 4. 反优化：假设失效 → 回退字节码
 *
 * 关键概念：
 * - 隐藏类：优化属性访问
 * - 内联缓存：缓存属性查找结果
 */

/**
 * 4. 垃圾回收机制？
 *
 * V8 分代回收：
 *
 * 新生代（Scavenge）：
 * - From/To 两个空间
 * - 存活对象复制到 To
 * - 多次存活晋升老生代
 *
 * 老生代（Mark-Sweep/Mark-Compact）：
 * - 标记-清除
 * - 标记-整理（消除碎片）
 *
 * 优化：
 * - 增量标记
 * - 并发标记
 */

/**
 * 5. Cookie、localStorage、sessionStorage 的区别？
 *
 * Cookie：
 * - 4KB，随请求发送
 * - 可设置过期时间
 * - HttpOnly 防 XSS
 *
 * localStorage：
 * - 5-10MB，永久存储
 * - 同源标签页共享
 *
 * sessionStorage：
 * - 5-10MB，会话存储
 * - 标签页独立
 */

/**
 * 6. 什么是 XSS？如何防御？
 *
 * XSS（跨站脚本）：注入恶意脚本
 *
 * 类型：
 * - 存储型：脚本存入数据库
 * - 反射型：脚本在 URL 中
 * - DOM 型：前端直接插入 DOM
 *
 * 防御：
 * - 输入验证
 * - 输出编码
 * - CSP 策略
 * - HttpOnly Cookie
 */

/**
 * 7. 什么是 CSRF？如何防御？
 *
 * CSRF（跨站请求伪造）：
 * 诱导用户在已登录的网站执行非预期操作
 *
 * 防御：
 * - CSRF Token
 * - SameSite Cookie
 * - 验证 Referer/Origin
 * - 双重 Cookie 验证
 */

// ============================================================
// 🔥🔥 进阶深入题
// ============================================================

/**
 * 8. 浏览器是多进程还是多线程？
 *
 * Chrome 多进程架构：
 * - Browser 进程：主进程
 * - Renderer 进程：每个 Tab
 * - GPU 进程
 * - Plugin 进程
 *
 * Renderer 进程的线程：
 * - Main Thread：JS、DOM、CSS
 * - Compositor Thread：合成
 * - Raster Threads：光栅化
 * - Worker Threads
 */

/**
 * 9. async 和 defer 的区别？
 *
 * async：
 * - 异步下载，下载完立即执行
 * - 不保证执行顺序
 * - 适合独立脚本
 *
 * defer：
 * - 异步下载，DOMContentLoaded 前执行
 * - 保证执行顺序
 * - 适合需要 DOM 的脚本
 */

/**
 * 10. 什么是隐藏类？如何保持？
 *
 * 隐藏类：V8 为动态对象创建的类型描述
 * 记录属性名、偏移量，加速属性访问
 *
 * 保持隐藏类稳定：
 * - 在构造函数中初始化所有属性
 * - 以相同顺序添加属性
 * - 避免使用 delete
 */

/**
 * 11. 常见的内存泄漏场景？
 *
 * 1. 意外的全局变量
 * 2. 未清除的定时器
 * 3. 未移除的 DOM 引用
 * 4. 闭包引用
 * 5. 未移除的事件监听器
 * 6. Map/Set 中的对象引用
 *
 * 排查：Chrome DevTools Memory 面板
 */

/**
 * 12. 什么是同源策略？如何跨域？
 *
 * 同源：协议 + 域名 + 端口 相同
 *
 * 跨域方案：
 * 1. CORS：服务器设置响应头
 * 2. JSONP：script 标签
 * 3. 代理服务器
 * 4. postMessage
 * 5. WebSocket
 */

/**
 * 13. CORS 简单请求和预检请求？
 *
 * 简单请求（同时满足）：
 * - GET/POST/HEAD
 * - 简单头部
 * - Content-Type 限于三种
 *
 * 预检请求：
 * - 其他方法
 * - 自定义头部
 * - 先发 OPTIONS
 */

// ============================================================
// 📝 场景题
// ============================================================

/**
 * 题目 1：如何优化首屏加载速度？
 *
 * 网络层面：
 * - 使用 CDN
 * - 开启 HTTP/2
 * - 使用 gzip/br 压缩
 * - DNS 预解析
 * - preconnect/prefetch/preload
 *
 * 资源层面：
 * - 代码分割
 * - 图片懒加载
 * - 小图片 base64
 * - 使用 WebP
 *
 * 渲染层面：
 * - 内联关键 CSS
 * - JS 使用 defer/async
 * - 骨架屏
 * - SSR/SSG
 *
 * 缓存层面：
 * - 合理设置缓存策略
 * - Service Worker 离线缓存
 */

/**
 * 题目 2：如何排查内存泄漏？
 *
 * 1. 确认泄漏：
 *    - 任务管理器观察内存变化
 *    - 手动 GC 后内存是否下降
 *
 * 2. 定位泄漏：
 *    - 操作前后拍摄 Heap Snapshot
 *    - 对比 Delta
 *
 * 3. 查找原因：
 *    - 查看 Retainers 引用链
 *
 * 4. 验证修复：
 *    - 重复上述步骤
 */

/**
 * 题目 3：如何实现跨标签页通信？
 *
 * 1. localStorage + storage 事件
 * 2. BroadcastChannel
 * 3. SharedWorker
 * 4. Service Worker + postMessage
 * 5. WebSocket
 * 6. IndexedDB + 轮询
 */

/**
 * 题目 4：什么是 CSP？有什么作用？
 *
 * CSP（内容安全策略）：
 * 通过 HTTP 响应头或 meta 标签限制资源加载
 *
 * 作用：
 * - 防止 XSS 攻击
 * - 限制脚本来源
 * - 限制内联脚本
 * - 禁止 eval
 *
 * 示例：
 * Content-Security-Policy: 
 *   default-src 'self';
 *   script-src 'self' 'nonce-xxx';
 *   style-src 'self' 'unsafe-inline';
 */

// ============================================================
// 🎯 资深面试追问清单
// ============================================================

/**
 * 追问 1：为什么 transform 动画性能好？
 *
 * - transform 只触发合成，不触发回流和重绘
 * - 创建独立的合成层
 * - 动画在 Compositor 线程执行，不阻塞主线程
 * - GPU 直接处理
 */

/**
 * 追问 2：V8 的内联缓存是什么？
 *
 * 内联缓存（IC）缓存属性访问的查找结果：
 *
 * 状态：
 * - Uninitialized：未初始化
 * - Monomorphic：单态，只见过一种类型
 * - Polymorphic：多态，见过 2-4 种类型
 * - Megamorphic：超多态，退化为字典查找
 *
 * 保持单态：参数类型保持一致
 */

/**
 * 追问 3：Service Worker 的生命周期？
 *
 * 1. register：注册
 * 2. install：安装，缓存资源
 * 3. activate：激活，清理旧缓存
 * 4. fetch：拦截请求
 *
 * 更新流程：
 * - 检测到新版本 → 安装新 SW
 * - 等待旧 SW 停止 → 激活新 SW
 * - 可用 skipWaiting() 跳过等待
 */

/**
 * 追问 4：为什么浏览器用多进程架构？
 *
 * 1. 稳定性：一个 Tab 崩溃不影响其他
 * 2. 安全性：沙箱隔离，限制系统访问
 * 3. 性能：利用多核 CPU 并行处理
 *
 * 缺点：内存占用更高
 */

// ============================================================
// 📋 面试准备 Checklist
// ============================================================

/**
 * ✅ 渲染流程
 *    - [ ] 关键渲染路径
 *    - [ ] 回流与重绘
 *    - [ ] 合成层与 GPU 加速
 *    - [ ] async/defer 区别
 *
 * ✅ V8 引擎
 *    - [ ] 执行流程
 *    - [ ] 隐藏类与内联缓存
 *    - [ ] JIT 编译
 *
 * ✅ 内存管理
 *    - [ ] 垃圾回收机制
 *    - [ ] 内存泄漏场景
 *    - [ ] WeakMap/WeakSet
 *
 * ✅ 安全
 *    - [ ] 同源策略与 CORS
 *    - [ ] XSS 防御
 *    - [ ] CSRF 防御
 *    - [ ] CSP 策略
 *
 * ✅ 存储
 *    - [ ] Cookie/localStorage/sessionStorage
 *    - [ ] IndexedDB
 *    - [ ] Service Worker
 */

export {};

