/**
 * ============================================================
 * 📚 架构设计 - 高频面试题汇总
 * ============================================================
 *
 * 按照面试频率和难度进行分类
 * 包含常见追问和易错点
 */

// ============================================================
// 🔥🔥🔥 高频必考题
// ============================================================

/**
 * 1. 什么是微前端？有哪些实现方案？
 *
 * 定义：
 * 将前端应用拆分为多个独立子应用，可独立开发、部署、运行
 *
 * 主流方案：
 * - iframe：天然隔离，但体验差
 * - qiankun：基于 single-spa，成熟稳定
 * - micro-app：类 WebComponent，接入简单
 * - Module Federation：Webpack 5 原生，运行时共享
 *
 * ⚠️ 易错点：
 * - 样式隔离方案选择
 * - 路由冲突处理
 *
 * 💡 追问：如何实现 JS 沙箱？
 * - 快照沙箱：保存/恢复 window
 * - 代理沙箱：Proxy 拦截，支持多实例
 */

/**
 * 2. 前端状态管理方案有哪些？如何选择？
 *
 * 方案对比：
 * - Redux：可预测，生态好，样板多
 * - MobX：响应式，使用简单
 * - Zustand：轻量，API 简洁
 * - Jotai/Recoil：原子化，细粒度更新
 * - Pinia：Vue 3 推荐
 *
 * 选择建议：
 * - 简单项目：Zustand / Jotai
 * - 复杂项目：Redux Toolkit
 * - Vue 项目：Pinia
 * - 服务端状态：React Query / SWR
 *
 * ⚠️ 易错点：
 * - 过度使用全局状态
 * - 混淆服务端和客户端状态
 *
 * 💡 追问：Redux 和 MobX 的区别？
 * - Redux：函数式，不可变，显式更新
 * - MobX：响应式，可变，隐式更新
 */

/**
 * 3. 如何设计一个组件库？
 *
 * 设计原则：
 * - 一致性：统一 API 设计
 * - 可访问性：a11y 支持
 * - 主题化：支持自定义主题
 * - 按需加载：Tree Shaking
 *
 * 组件模式：
 * - 组合组件（Compound Components）
 * - 受控/非受控
 * - Render Props
 * - HOC
 *
 * ⚠️ 易错点：
 * - Props 过多
 * - 忽视可访问性
 *
 * 💡 追问：HOC、Render Props、Hooks 如何选择？
 * - Hooks：首选，逻辑复用
 * - Render Props：需要灵活渲染
 * - HOC：需要包装整个组件
 */

/**
 * 4. 什么是 BFF？为什么需要 BFF？
 *
 * 定义：
 * Backend For Frontend，服务于前端的后端
 *
 * 价值：
 * - 接口聚合：多接口合一
 * - 数据裁剪：只返回需要的字段
 * - 格式转换：适配前端数据结构
 * - 解耦：前端与微服务解耦
 *
 * ⚠️ 易错点：
 * - 职责边界不清
 * - 放太多业务逻辑
 *
 * 💡 追问：BFF 和 API Gateway 的区别？
 * - API Gateway：通用网关，路由限流认证
 * - BFF：面向特定前端，接口聚合裁剪
 */

// ============================================================
// 🔥🔥 进阶深入题
// ============================================================

/**
 * 5. 微前端如何实现样式隔离？
 *
 * 方案：
 * - Shadow DOM：完全隔离，但弹窗有问题
 * - CSS Scoped：选择器加前缀
 * - CSS Modules：类名 hash 化
 * - CSS-in-JS：运行时生成，天然隔离
 *
 * ⚠️ 易错点：
 * - Shadow DOM 下弹窗样式丢失
 *
 * 💡 追问：qiankun 的 experimentalStyleIsolation 原理？
 * - 给选择器加 [data-qiankun="app-name"] 前缀
 */

/**
 * 6. 微前端子应用之间如何通信？
 *
 * 方案：
 * - Props 传递
 * - 全局状态（qiankun initGlobalState）
 * - CustomEvent
 * - EventBus
 *
 * ⚠️ 易错点：
 * - 事件订阅需要及时清理
 *
 * 💡 追问：如何避免通信导致的强耦合？
 * - 定义清晰的通信协议
 * - 最小化共享数据
 */

/**
 * 7. GraphQL vs REST 如何选择？
 *
 * GraphQL 适合：
 * - 复杂数据关系
 * - 多端复用
 * - 快速迭代
 *
 * REST 适合：
 * - 简单 CRUD
 * - 缓存友好
 * - 团队熟悉
 *
 * ⚠️ 易错点：
 * - GraphQL 的 N+1 问题
 *
 * 💡 追问：如何解决 N+1 问题？
 * - DataLoader 批量加载
 */

/**
 * 8. 如何进行技术选型？
 *
 * 评估维度：
 * - 功能匹配度
 * - 团队熟悉度
 * - 生态与社区
 * - 性能表现
 * - 长期维护
 *
 * ⚠️ 易错点：
 * - 只看技术不看团队
 * - 过度追求新技术
 *
 * 💡 追问：如何权衡？
 * - 明确优先级
 * - 列出各方案优缺点
 * - 考虑约束条件
 */

// ============================================================
// 📝 场景题
// ============================================================

/**
 * 场景 1：设计一个在线文档系统
 *
 * 核心问题：
 * - 实时协作（CRDT/OT）
 * - 编辑器引擎（ProseMirror/Slate）
 * - 离线支持（IndexedDB + Service Worker）
 * - 版本历史
 *
 * 技术选型：
 * - 编辑器：ProseMirror
 * - 协作：Yjs（CRDT）
 * - 通信：WebSocket
 */

/**
 * 场景 2：设计一个大型中后台系统
 *
 * 核心问题：
 * - 模块划分
 * - 权限系统
 * - 微前端架构
 * - 状态管理
 *
 * 技术选型：
 * - 框架：React + Ant Design
 * - 状态：Zustand + React Query
 * - 微前端：qiankun（可选）
 */

/**
 * 场景 3：设计一个监控大盘
 *
 * 核心问题：
 * - 实时数据（WebSocket/SSE）
 * - 大数据量渲染（Canvas/WebGL）
 * - 自定义布局
 * - 大屏适配
 *
 * 技术选型：
 * - 图表：ECharts
 * - 布局：react-grid-layout
 * - 数据：WebSocket + 数据聚合
 */

// ============================================================
// 🎯 资深追问清单
// ============================================================

/**
 * 追问 1：如何保证系统的可扩展性？
 *
 * - 模块化设计
 * - 依赖抽象不依赖具体
 * - 预留扩展点
 * - 配置化
 * - 插件机制
 */

/**
 * 追问 2：微前端的性能优化？
 *
 * - 预加载（prefetch）
 * - 共享依赖
 * - 按需加载
 * - 资源缓存
 * - 并行加载
 */

/**
 * 追问 3：状态管理的最佳实践？
 *
 * - 区分服务端/客户端状态
 * - 状态扁平化
 * - 避免冗余
 * - 选择器优化
 * - 持久化策略
 */

/**
 * 追问 4：组件设计的原则？
 *
 * - 单一职责
 * - 开闭原则
 * - 组合优于继承
 * - 受控与非受控兼容
 * - 可访问性
 */

// ============================================================
// 📋 面试准备 Checklist
// ============================================================

/**
 * ✅ 微前端
 *    - [ ] 概念和价值
 *    - [ ] 主流方案对比
 *    - [ ] JS 沙箱原理
 *    - [ ] 样式隔离方案
 *    - [ ] 应用通信
 *
 * ✅ 状态管理
 *    - [ ] 主流方案对比
 *    - [ ] Redux 原理
 *    - [ ] 响应式原理
 *    - [ ] 服务端状态管理
 *
 * ✅ 组件设计
 *    - [ ] 设计原则
 *    - [ ] 组合组件
 *    - [ ] HOC/Render Props/Hooks
 *    - [ ] 组件库设计
 *
 * ✅ 系统设计
 *    - [ ] 设计方法论
 *    - [ ] 技术选型
 *    - [ ] 常见系统设计案例
 *
 * ✅ BFF 与接口
 *    - [ ] BFF 概念和价值
 *    - [ ] GraphQL vs REST
 *    - [ ] API 设计规范
 *    - [ ] 接口安全
 */

// ============================================================
// 💡 架构设计思维
// ============================================================

/**
 * 📊 架构师思维
 *
 * 1. 全局视角
 *    - 不只关注技术细节
 *    - 考虑业务、团队、成本
 *
 * 2. 权衡意识
 *    - 没有银弹
 *    - 每个决策都是权衡
 *
 * 3. 演进思维
 *    - 架构是演进的
 *    - 不要过度设计
 *
 * 4. 抽象能力
 *    - 识别共性
 *    - 提取抽象
 *
 * 5. 风险意识
 *    - 考虑边界情况
 *    - 准备降级方案
 */

export {};

