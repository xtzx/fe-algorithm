/**
 * ============================================================
 * 📚 系统设计方法论
 * ============================================================
 *
 * 面试考察重点：
 * 1. 系统设计思维
 * 2. 前端系统设计案例
 * 3. 技术选型
 * 4. 权衡与决策
 */

// ============================================================
// 1. 系统设计方法论
// ============================================================

/**
 * 📊 系统设计四步法
 *
 * 1. 明确需求（Clarify Requirements）
 *    - 功能性需求
 *    - 非功能性需求（性能、可用性、安全性）
 *    - 约束条件（时间、团队、技术栈）
 *
 * 2. 高层设计（High-Level Design）
 *    - 系统架构图
 *    - 模块划分
 *    - 数据流
 *
 * 3. 详细设计（Detailed Design）
 *    - 核心模块设计
 *    - API 设计
 *    - 数据结构
 *
 * 4. 总结与扩展（Summary & Extensions）
 *    - 方案权衡
 *    - 潜在问题
 *    - 扩展方向
 */

// ============================================================
// 2. 前端系统设计模板
// ============================================================

/**
 * 📊 前端系统设计 Checklist
 *
 * □ 需求分析
 *   - 核心功能
 *   - 用户规模
 *   - 性能要求
 *   - 兼容性要求
 *
 * □ 技术选型
 *   - 框架选择
 *   - 状态管理
 *   - UI 组件库
 *   - 构建工具
 *
 * □ 架构设计
 *   - 目录结构
 *   - 模块划分
 *   - 数据流
 *   - 路由设计
 *
 * □ 核心功能设计
 *   - 组件设计
 *   - 状态设计
 *   - API 设计
 *
 * □ 性能优化
 *   - 加载优化
 *   - 渲染优化
 *   - 缓存策略
 *
 * □ 可扩展性
 *   - 插件机制
 *   - 主题定制
 *   - 国际化
 *
 * □ 监控与运维
 *   - 错误监控
 *   - 性能监控
 *   - 日志上报
 */

// ============================================================
// 3. 案例：设计一个在线文档系统
// ============================================================

/**
 * 📊 案例：类 Notion 在线文档系统
 *
 * 📋 需求分析
 *
 * 功能性需求：
 * - 文档编辑（富文本、Markdown）
 * - 实时协作（多人同时编辑）
 * - 版本历史
 * - 评论批注
 * - 权限管理
 *
 * 非功能性需求：
 * - 实时同步延迟 < 200ms
 * - 支持 1000+ 人同时在线
 * - 离线编辑
 * - 数据安全
 */

const docSystemDesign = `
📊 高层架构

┌─────────────────────────────────────────────────────────────────────┐
│                           前端架构                                  │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │                    编辑器核心（Editor Core）                 │   │
│  │  ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐        │   │
│  │  │ 文档模型 │  │ 选区管理 │  │ 操作转换 │  │ 渲染引擎 │        │   │
│  │  └─────────┘  └─────────┘  └─────────┘  └─────────┘        │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐              │
│  │  协作引擎     │  │  插件系统     │  │  状态管理     │              │
│  │  (CRDT/OT)   │  │  (Plugins)   │  │  (Zustand)   │              │
│  └──────────────┘  └──────────────┘  └──────────────┘              │
│                                                                     │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐              │
│  │  WebSocket   │  │  IndexedDB   │  │  Service     │              │
│  │  (实时同步)   │  │  (离线存储)   │  │  Worker      │              │
│  └──────────────┘  └──────────────┘  └──────────────┘              │
└─────────────────────────────────────────────────────────────────────┘

📊 核心技术选型

- 编辑器引擎：ProseMirror / Slate
- 协作算法：CRDT（Yjs）
- 通信：WebSocket
- 离线：IndexedDB + Service Worker
- 状态：Zustand
- UI：Headless UI + Tailwind

📊 数据结构设计

// 文档模型
interface Document {
  id: string;
  title: string;
  content: Block[];
  version: number;
  createdAt: Date;
  updatedAt: Date;
  createdBy: string;
}

// 块结构
interface Block {
  id: string;
  type: 'paragraph' | 'heading' | 'list' | 'code' | 'image';
  content: InlineContent[];
  children?: Block[];
  props: Record<string, any>;
}

// 操作定义（CRDT）
interface Operation {
  type: 'insert' | 'delete' | 'format';
  path: number[];
  offset: number;
  data: any;
  timestamp: number;
  userId: string;
}
`;

// ============================================================
// 4. 案例：设计一个大型表单系统
// ============================================================

const formSystemDesign = `
📊 案例：企业级表单引擎

📋 需求分析

功能性需求：
- 可视化表单设计器
- 支持 50+ 种字段类型
- 表单逻辑（联动、校验）
- 数据提交与回显
- 流程审批集成

非功能性需求：
- 表单渲染性能 < 100ms
- 支持 1000+ 字段大表单
- 低代码/零代码

📊 高层架构

┌─────────────────────────────────────────────────────────────┐
│                    表单引擎架构                             │
│                                                             │
│  ┌─────────────────────────────────────────────────────┐   │
│  │              Schema 设计器（Designer）               │   │
│  │  拖拽面板 │ 画布 │ 属性配置 │ 逻辑配置                │   │
│  └─────────────────────────────────────────────────────┘   │
│                          │                                  │
│                          ▼                                  │
│  ┌─────────────────────────────────────────────────────┐   │
│  │                   Schema（JSON）                     │   │
│  └─────────────────────────────────────────────────────┘   │
│                          │                                  │
│                          ▼                                  │
│  ┌─────────────────────────────────────────────────────┐   │
│  │              表单渲染器（Renderer）                  │   │
│  │  Schema 解析 │ 组件映射 │ 数据绑定 │ 校验             │   │
│  └─────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────┘

📊 Schema 设计

interface FormSchema {
  version: string;
  fields: FieldSchema[];
  layout: LayoutSchema;
  rules: RuleSchema[];
  actions: ActionSchema[];
}

interface FieldSchema {
  id: string;
  type: string;
  name: string;
  label: string;
  required: boolean;
  defaultValue: any;
  props: Record<string, any>;
  rules: ValidationRule[];
  dependencies: Dependency[];
}

interface Dependency {
  field: string;
  condition: 'eq' | 'ne' | 'gt' | 'lt' | 'contains';
  value: any;
  action: 'show' | 'hide' | 'enable' | 'disable' | 'setValue';
}

📊 渲染器实现

function FormRenderer({ schema, data, onSubmit }) {
  const [formData, setFormData] = useState(data);
  const [errors, setErrors] = useState({});
  
  const renderedFields = useMemo(() => {
    return schema.fields.map(field => {
      // 根据依赖计算可见性
      const visible = evaluateDependencies(field.dependencies, formData);
      if (!visible) return null;
      
      // 获取组件
      const Component = fieldComponents[field.type];
      
      return (
        <Component
          key={field.id}
          {...field.props}
          value={formData[field.name]}
          error={errors[field.name]}
          onChange={value => handleChange(field.name, value)}
        />
      );
    });
  }, [schema, formData, errors]);
  
  return <form onSubmit={handleSubmit}>{renderedFields}</form>;
}
`;

// ============================================================
// 5. 案例：设计一个监控大盘系统
// ============================================================

const dashboardSystemDesign = `
📊 案例：实时监控大盘

📋 需求分析

功能性需求：
- 实时数据展示
- 多种图表类型
- 自定义布局
- 告警配置
- 数据下钻

非功能性需求：
- 数据刷新延迟 < 1s
- 支持 100+ 图表同时渲染
- 大屏适配

📊 高层架构

┌─────────────────────────────────────────────────────────────┐
│                     监控大盘架构                            │
│                                                             │
│  ┌─────────────────────────────────────────────────────┐   │
│  │                  数据层                              │   │
│  │  WebSocket 订阅 │ 轮询 │ SSE │ 数据聚合 │ 缓存        │   │
│  └─────────────────────────────────────────────────────┘   │
│                          │                                  │
│                          ▼                                  │
│  ┌─────────────────────────────────────────────────────┐   │
│  │                  状态管理                            │   │
│  │  数据 Store │ 配置 Store │ 告警 Store                │   │
│  └─────────────────────────────────────────────────────┘   │
│                          │                                  │
│                          ▼                                  │
│  ┌─────────────────────────────────────────────────────┐   │
│  │                  可视化层                            │   │
│  │  ECharts │ D3 │ Canvas │ WebGL                       │   │
│  └─────────────────────────────────────────────────────┘   │
│                          │                                  │
│                          ▼                                  │
│  ┌─────────────────────────────────────────────────────┐   │
│  │                  布局系统                            │   │
│  │  Grid 布局 │ 拖拽调整 │ 响应式 │ 大屏适配            │   │
│  └─────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────┘

📊 性能优化策略

1. 数据层优化
   - WebSocket 订阅替代轮询
   - 数据增量更新
   - 数据聚合减少渲染

2. 渲染层优化
   - 虚拟化大列表
   - Canvas 渲染大数据图表
   - 离屏渲染
   - 帧率控制

3. 内存优化
   - 数据窗口（只保留最近 N 条）
   - 图表销毁时清理
   - 定时 GC
`;

// ============================================================
// 6. 技术选型方法论
// ============================================================

/**
 * 📊 技术选型评估维度
 *
 * 1. 功能匹配度
 *    - 是否满足核心需求
 *    - 扩展性如何
 *
 * 2. 团队因素
 *    - 团队熟悉度
 *    - 学习成本
 *
 * 3. 生态与社区
 *    - 社区活跃度
 *    - 文档质量
 *    - 插件/工具链
 *
 * 4. 性能
 *    - Bundle 大小
 *    - 运行时性能
 *
 * 5. 长期维护
 *    - 版本稳定性
 *    - 长期支持
 *    - 商业支持
 */

const techSelectionExample = `
📊 案例：React vs Vue 选型

评估项          │ React              │ Vue
─────────────────────────────────────────────────
功能匹配度      │ ★★★★★              │ ★★★★★
团队熟悉度      │ ★★★★☆              │ ★★★☆☆
生态           │ ★★★★★              │ ★★★★☆
性能           │ ★★★★☆              │ ★★★★★
Bundle 大小    │ 42KB (react + dom)  │ 33KB (vue 3)
TypeScript     │ ★★★★★              │ ★★★★☆
就业市场       │ ★★★★★              │ ★★★★☆

结论：团队熟悉 React，生态需求高 → 选 React
`;

// ============================================================
// 7. ⚠️ 注意事项（易错点）
// ============================================================

/**
 * ⚠️ 系统设计常见问题
 *
 * 1. 过度设计
 *    - 先解决当前问题
 *    - 避免过早优化
 *
 * 2. 忽视非功能需求
 *    - 性能、安全、可用性
 *    - 运维、监控
 *
 * 3. 技术选型偏见
 *    - 客观评估
 *    - 考虑团队实际情况
 *
 * 4. 忽视边界情况
 *    - 异常处理
 *    - 降级方案
 *
 * 5. 缺乏可扩展性
 *    - 预留扩展点
 *    - 模块化设计
 */

// ============================================================
// 8. 💡 面试追问
// ============================================================

/**
 * 💡 深度追问
 *
 * Q1: 如何评估技术选型？
 * A:
 *    - 功能匹配度
 *    - 团队熟悉度
 *    - 生态与社区
 *    - 性能表现
 *    - 长期维护
 *
 * Q2: 系统设计中如何权衡？
 * A:
 *    - 明确优先级
 *    - 列出各方案优缺点
 *    - 考虑约束条件
 *    - 做出决策并记录
 *
 * Q3: 如何保证系统可扩展性？
 * A:
 *    - 模块化设计
 *    - 依赖抽象
 *    - 预留扩展点
 *    - 配置化
 *
 * Q4: 如何处理复杂度？
 * A:
 *    - 分而治之
 *    - 抽象封装
 *    - 渐进式复杂度
 */

export {
  docSystemDesign,
  formSystemDesign,
  dashboardSystemDesign,
  techSelectionExample,
};

