/**
 * ============================================================
 * 📚 工程体系 - 高频面试题汇总
 * ============================================================
 *
 * 按照面试频率和难度进行分类
 * 包含常见追问和易错点
 */

// ============================================================
// 🔥🔥🔥 高频必考题
// ============================================================

/**
 * 1. 如何保证代码质量？
 *
 * 多层次保障：
 * - 代码规范：ESLint + Prettier
 * - Git 规范：commitlint + husky
 * - Code Review：CODEOWNERS
 * - 自动化测试：单元/集成/E2E
 * - 质量门禁：CI 检查
 *
 * ⚠️ 易错点：
 * - 规范太严影响效率
 * - 规范不落地
 *
 * 💡 追问：ESLint 和 Prettier 的区别？
 * - ESLint：代码质量
 * - Prettier：代码风格
 */

/**
 * 2. 如何做前端测试？
 *
 * 测试金字塔：
 * - 单元测试（70%）：Vitest/Jest
 * - 集成测试（20%）：React Testing Library
 * - E2E 测试（10%）：Playwright/Cypress
 *
 * ⚠️ 易错点：
 * - 测试实现而非行为
 * - 高覆盖率 ≠ 高质量
 *
 * 💡 追问：如何测试 React 组件？
 * - React Testing Library
 * - 测试用户行为
 * - 可访问性查询
 */

/**
 * 3. 如何做前端监控？
 *
 * 监控体系：
 * - 错误监控：JS 错误、Promise 错误、资源错误
 * - 性能监控：Core Web Vitals（LCP/FID/CLS）
 * - 用户行为：PV/UV、点击、停留
 *
 * ⚠️ 易错点：
 * - 数据采集过多影响性能
 * - 告警阈值设置不合理
 *
 * 💡 追问：如何保证数据上报可靠性？
 * - navigator.sendBeacon
 * - 离线存储 + 重试
 */

/**
 * 4. 如何度量研发效能？
 *
 * DORA 指标：
 * - 部署频率
 * - 变更前置时间
 * - 变更失败率
 * - 服务恢复时间
 *
 * 前端特有指标：
 * - 构建时间
 * - 首屏性能
 * - Bug 逃逸率
 *
 * ⚠️ 易错点：
 * - 把指标当 KPI
 * - 只看数字不看趋势
 *
 * 💡 追问：如何提升研发效率？
 * - 脚手架和模板
 * - 代码生成
 * - 自动化流程
 */

// ============================================================
// 🔥🔥 进阶深入题
// ============================================================

/**
 * 5. 如何设计 CLI 脚手架？
 *
 * 核心模块：
 * - 命令解析：commander
 * - 交互问询：inquirer
 * - 模板引擎：ejs
 * - 模板仓库
 *
 * 功能：
 * - 项目初始化
 * - 代码生成
 * - 规范检查
 *
 * ⚠️ 易错点：
 * - 模板维护成本
 *
 * 💡 追问：如何实现模板更新？
 * - 远程模板仓库
 * - 版本管理
 */

/**
 * 6. 什么是 Core Web Vitals？
 *
 * 三大核心指标：
 * - LCP：最大内容绘制 < 2.5s
 * - FID：首次输入延迟 < 100ms
 * - CLS：累计布局偏移 < 0.1
 *
 * 采集方式：
 * - PerformanceObserver
 * - web-vitals 库
 *
 * ⚠️ 易错点：
 * - FID 只能在用户交互时采集
 *
 * 💡 追问：如何优化 LCP？
 * - 优化关键资源
 * - 预加载
 * - SSR/SSG
 */

/**
 * 7. 如何做好 Code Review？
 *
 * 关注点：
 * - 正确性
 * - 设计合理性
 * - 可读性
 * - 安全性
 * - 性能
 *
 * 最佳实践：
 * - 小批量 PR
 * - 明确标准
 * - 及时 Review
 * - 建设性反馈
 *
 * ⚠️ 易错点：
 * - LGTM 敷衍
 * - Review 太慢阻塞
 *
 * 💡 追问：如何配置 CODEOWNERS？
 * - 按目录指定 Owner
 * - 敏感文件特殊审批
 */

/**
 * 8. 如何管理技术文档？
 *
 * 文档类型：
 * - 项目文档：README、架构说明
 * - API 文档：TypeDoc、Swagger
 * - 组件文档：Storybook
 * - 团队规范
 *
 * ⚠️ 易错点：
 * - 文档不及时更新
 * - 示例代码不可运行
 *
 * 💡 追问：如何保证文档及时更新？
 * - 文档作为 PR 必需项
 * - 自动化生成
 */

// ============================================================
// 📝 场景题
// ============================================================

/**
 * 场景 1：搭建前端研发平台
 *
 * 核心模块：
 * - 开发阶段：脚手架、Mock、组件库
 * - 构建阶段：CI/CD、构建优化
 * - 发布阶段：灰度、回滚
 * - 运行阶段：监控、告警
 * - 效能度量
 */

/**
 * 场景 2：项目质量治理
 *
 * 方案：
 * - 建立规范：编码、Git、设计
 * - 工具保障：ESLint、Prettier、husky
 * - 自动化：CI 质量门禁
 * - 测试覆盖：单元测试 80%+
 * - Code Review 机制
 */

/**
 * 场景 3：建立监控告警体系
 *
 * 方案：
 * - 数据采集：错误/性能/行为
 * - 数据上报：批量、采样
 * - 存储分析：聚合、可视化
 * - 告警机制：分级、分渠道
 */

// ============================================================
// 🎯 资深追问清单
// ============================================================

/**
 * 追问 1：如何设计告警策略？
 *
 * - 分级：P0-P3
 * - 分渠道：电话/短信/邮件/IM
 * - 聚合收敛：避免告警风暴
 * - 值班机制：on-call
 */

/**
 * 追问 2：什么是圈复杂度？
 *
 * - 代码路径数量
 * - if/else/for 增加复杂度
 * - 建议 <= 10
 * - 工具：ESLint complexity 规则
 */

/**
 * 追问 3：如何做测试数据管理？
 *
 * - Fixtures：固定测试数据
 * - Factories：动态生成
 * - Mock：模拟外部依赖
 * - Seed：数据库种子
 */

/**
 * 追问 4：如何保证 E2E 测试稳定性？
 *
 * - 独立测试环境
 * - 数据隔离
 * - 等待机制
 * - 重试策略
 * - 定期维护
 */

// ============================================================
// 📋 面试准备 Checklist
// ============================================================

/**
 * ✅ 研发效能
 *    - [ ] DORA 指标
 *    - [ ] 脚手架设计
 *    - [ ] 代码生成
 *    - [ ] 自动化流程
 *
 * ✅ 代码质量
 *    - [ ] ESLint/Prettier
 *    - [ ] Git 规范
 *    - [ ] Code Review
 *    - [ ] 质量门禁
 *
 * ✅ 测试体系
 *    - [ ] 测试金字塔
 *    - [ ] 单元测试
 *    - [ ] 组件测试
 *    - [ ] E2E 测试
 *
 * ✅ 监控告警
 *    - [ ] 错误监控
 *    - [ ] 性能监控
 *    - [ ] 用户行为
 *    - [ ] 告警机制
 *
 * ✅ 文档规范
 *    - [ ] 文档体系
 *    - [ ] Storybook
 *    - [ ] 团队规范
 */

// ============================================================
// 💡 工程化思维
// ============================================================

/**
 * 📊 工程化的本质
 *
 * 1. 标准化
 *    - 统一规范
 *    - 减少决策成本
 *
 * 2. 自动化
 *    - 重复工作自动化
 *    - 减少人为错误
 *
 * 3. 可度量
 *    - 有数据支撑
 *    - 持续改进
 *
 * 4. 可持续
 *    - 不依赖个人
 *    - 团队可复制
 *
 * 📊 资深工程师视角
 *
 * - 不只是使用工具，更要设计工具
 * - 不只是遵守规范，更要制定规范
 * - 不只是解决问题，更要建立体系
 * - 不只是个人效率，更要团队效能
 */

export {};

